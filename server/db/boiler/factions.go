// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Faction is an object representing the database table.
type Faction struct {
	ID             string      `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	VotePrice      string      `boiler:"vote_price" boil:"vote_price" json:"vote_price" toml:"vote_price" yaml:"vote_price"`
	ContractReward string      `boiler:"contract_reward" boil:"contract_reward" json:"contract_reward" toml:"contract_reward" yaml:"contract_reward"`
	Label          string      `boiler:"label" boil:"label" json:"label" toml:"label" yaml:"label"`
	GuildID        null.String `boiler:"guild_id" boil:"guild_id" json:"guild_id,omitempty" toml:"guild_id" yaml:"guild_id,omitempty"`
	DeletedAt      null.Time   `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	UpdatedAt      time.Time   `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt      time.Time   `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	LogoURL        string      `boiler:"logo_url" boil:"logo_url" json:"logo_url" toml:"logo_url" yaml:"logo_url"`
	BackgroundURL  string      `boiler:"background_url" boil:"background_url" json:"background_url" toml:"background_url" yaml:"background_url"`
	Description    string      `boiler:"description" boil:"description" json:"description" toml:"description" yaml:"description"`
	WallpaperURL   null.String `boiler:"wallpaper_url" boil:"wallpaper_url" json:"wallpaper_url,omitempty" toml:"wallpaper_url" yaml:"wallpaper_url,omitempty"`

	R *factionR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L factionL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var FactionColumns = struct {
	ID             string
	VotePrice      string
	ContractReward string
	Label          string
	GuildID        string
	DeletedAt      string
	UpdatedAt      string
	CreatedAt      string
	LogoURL        string
	BackgroundURL  string
	Description    string
	WallpaperURL   string
}{
	ID:             "id",
	VotePrice:      "vote_price",
	ContractReward: "contract_reward",
	Label:          "label",
	GuildID:        "guild_id",
	DeletedAt:      "deleted_at",
	UpdatedAt:      "updated_at",
	CreatedAt:      "created_at",
	LogoURL:        "logo_url",
	BackgroundURL:  "background_url",
	Description:    "description",
	WallpaperURL:   "wallpaper_url",
}

var FactionTableColumns = struct {
	ID             string
	VotePrice      string
	ContractReward string
	Label          string
	GuildID        string
	DeletedAt      string
	UpdatedAt      string
	CreatedAt      string
	LogoURL        string
	BackgroundURL  string
	Description    string
	WallpaperURL   string
}{
	ID:             "factions.id",
	VotePrice:      "factions.vote_price",
	ContractReward: "factions.contract_reward",
	Label:          "factions.label",
	GuildID:        "factions.guild_id",
	DeletedAt:      "factions.deleted_at",
	UpdatedAt:      "factions.updated_at",
	CreatedAt:      "factions.created_at",
	LogoURL:        "factions.logo_url",
	BackgroundURL:  "factions.background_url",
	Description:    "factions.description",
	WallpaperURL:   "factions.wallpaper_url",
}

// Generated where

var FactionWhere = struct {
	ID             whereHelperstring
	VotePrice      whereHelperstring
	ContractReward whereHelperstring
	Label          whereHelperstring
	GuildID        whereHelpernull_String
	DeletedAt      whereHelpernull_Time
	UpdatedAt      whereHelpertime_Time
	CreatedAt      whereHelpertime_Time
	LogoURL        whereHelperstring
	BackgroundURL  whereHelperstring
	Description    whereHelperstring
	WallpaperURL   whereHelpernull_String
}{
	ID:             whereHelperstring{field: "\"factions\".\"id\""},
	VotePrice:      whereHelperstring{field: "\"factions\".\"vote_price\""},
	ContractReward: whereHelperstring{field: "\"factions\".\"contract_reward\""},
	Label:          whereHelperstring{field: "\"factions\".\"label\""},
	GuildID:        whereHelpernull_String{field: "\"factions\".\"guild_id\""},
	DeletedAt:      whereHelpernull_Time{field: "\"factions\".\"deleted_at\""},
	UpdatedAt:      whereHelpertime_Time{field: "\"factions\".\"updated_at\""},
	CreatedAt:      whereHelpertime_Time{field: "\"factions\".\"created_at\""},
	LogoURL:        whereHelperstring{field: "\"factions\".\"logo_url\""},
	BackgroundURL:  whereHelperstring{field: "\"factions\".\"background_url\""},
	Description:    whereHelperstring{field: "\"factions\".\"description\""},
	WallpaperURL:   whereHelpernull_String{field: "\"factions\".\"wallpaper_url\""},
}

// FactionRels is where relationship names are stored.
var FactionRels = struct {
	FactionPalette             string
	IDFactionStat              string
	BattleAbilityOptInLogs     string
	BattleAbilityTriggers      string
	BattleContracts            string
	BattleContributions        string
	BattleLobbiesMechs         string
	BattleLobbySupporterOptIns string
	BattleLobbySupporters      string
	BattleMechs                string
	BattleQueueOlds            string
	BattleWins                 string
	Brands                     string
	ChatHistories              string
	GameAbilities              string
	ItemKeycardSales           string
	ItemSales                  string
	MysteryCrates              string
	PlayerActiveLogs           string
	PlayerKillLogs             string
	PlayerLanguages            string
	Players                    string
	PunishVotes                string
	StakedMechBattleLogs       string
	StakedMechs                string
	StorefrontMysteryCrates    string
	Syndicates                 string
	TemplatesOlds              string
	VoiceStreams               string
}{
	FactionPalette:             "FactionPalette",
	IDFactionStat:              "IDFactionStat",
	BattleAbilityOptInLogs:     "BattleAbilityOptInLogs",
	BattleAbilityTriggers:      "BattleAbilityTriggers",
	BattleContracts:            "BattleContracts",
	BattleContributions:        "BattleContributions",
	BattleLobbiesMechs:         "BattleLobbiesMechs",
	BattleLobbySupporterOptIns: "BattleLobbySupporterOptIns",
	BattleLobbySupporters:      "BattleLobbySupporters",
	BattleMechs:                "BattleMechs",
	BattleQueueOlds:            "BattleQueueOlds",
	BattleWins:                 "BattleWins",
	Brands:                     "Brands",
	ChatHistories:              "ChatHistories",
	GameAbilities:              "GameAbilities",
	ItemKeycardSales:           "ItemKeycardSales",
	ItemSales:                  "ItemSales",
	MysteryCrates:              "MysteryCrates",
	PlayerActiveLogs:           "PlayerActiveLogs",
	PlayerKillLogs:             "PlayerKillLogs",
	PlayerLanguages:            "PlayerLanguages",
	Players:                    "Players",
	PunishVotes:                "PunishVotes",
	StakedMechBattleLogs:       "StakedMechBattleLogs",
	StakedMechs:                "StakedMechs",
	StorefrontMysteryCrates:    "StorefrontMysteryCrates",
	Syndicates:                 "Syndicates",
	TemplatesOlds:              "TemplatesOlds",
	VoiceStreams:               "VoiceStreams",
}

// factionR is where relationships are stored.
type factionR struct {
	FactionPalette             *FactionPalette                `boiler:"FactionPalette" boil:"FactionPalette" json:"FactionPalette" toml:"FactionPalette" yaml:"FactionPalette"`
	IDFactionStat              *FactionStat                   `boiler:"IDFactionStat" boil:"IDFactionStat" json:"IDFactionStat" toml:"IDFactionStat" yaml:"IDFactionStat"`
	BattleAbilityOptInLogs     BattleAbilityOptInLogSlice     `boiler:"BattleAbilityOptInLogs" boil:"BattleAbilityOptInLogs" json:"BattleAbilityOptInLogs" toml:"BattleAbilityOptInLogs" yaml:"BattleAbilityOptInLogs"`
	BattleAbilityTriggers      BattleAbilityTriggerSlice      `boiler:"BattleAbilityTriggers" boil:"BattleAbilityTriggers" json:"BattleAbilityTriggers" toml:"BattleAbilityTriggers" yaml:"BattleAbilityTriggers"`
	BattleContracts            BattleContractSlice            `boiler:"BattleContracts" boil:"BattleContracts" json:"BattleContracts" toml:"BattleContracts" yaml:"BattleContracts"`
	BattleContributions        BattleContributionSlice        `boiler:"BattleContributions" boil:"BattleContributions" json:"BattleContributions" toml:"BattleContributions" yaml:"BattleContributions"`
	BattleLobbiesMechs         BattleLobbiesMechSlice         `boiler:"BattleLobbiesMechs" boil:"BattleLobbiesMechs" json:"BattleLobbiesMechs" toml:"BattleLobbiesMechs" yaml:"BattleLobbiesMechs"`
	BattleLobbySupporterOptIns BattleLobbySupporterOptInSlice `boiler:"BattleLobbySupporterOptIns" boil:"BattleLobbySupporterOptIns" json:"BattleLobbySupporterOptIns" toml:"BattleLobbySupporterOptIns" yaml:"BattleLobbySupporterOptIns"`
	BattleLobbySupporters      BattleLobbySupporterSlice      `boiler:"BattleLobbySupporters" boil:"BattleLobbySupporters" json:"BattleLobbySupporters" toml:"BattleLobbySupporters" yaml:"BattleLobbySupporters"`
	BattleMechs                BattleMechSlice                `boiler:"BattleMechs" boil:"BattleMechs" json:"BattleMechs" toml:"BattleMechs" yaml:"BattleMechs"`
	BattleQueueOlds            BattleQueueOldSlice            `boiler:"BattleQueueOlds" boil:"BattleQueueOlds" json:"BattleQueueOlds" toml:"BattleQueueOlds" yaml:"BattleQueueOlds"`
	BattleWins                 BattleWinSlice                 `boiler:"BattleWins" boil:"BattleWins" json:"BattleWins" toml:"BattleWins" yaml:"BattleWins"`
	Brands                     BrandSlice                     `boiler:"Brands" boil:"Brands" json:"Brands" toml:"Brands" yaml:"Brands"`
	ChatHistories              ChatHistorySlice               `boiler:"ChatHistories" boil:"ChatHistories" json:"ChatHistories" toml:"ChatHistories" yaml:"ChatHistories"`
	GameAbilities              GameAbilitySlice               `boiler:"GameAbilities" boil:"GameAbilities" json:"GameAbilities" toml:"GameAbilities" yaml:"GameAbilities"`
	ItemKeycardSales           ItemKeycardSaleSlice           `boiler:"ItemKeycardSales" boil:"ItemKeycardSales" json:"ItemKeycardSales" toml:"ItemKeycardSales" yaml:"ItemKeycardSales"`
	ItemSales                  ItemSaleSlice                  `boiler:"ItemSales" boil:"ItemSales" json:"ItemSales" toml:"ItemSales" yaml:"ItemSales"`
	MysteryCrates              MysteryCrateSlice              `boiler:"MysteryCrates" boil:"MysteryCrates" json:"MysteryCrates" toml:"MysteryCrates" yaml:"MysteryCrates"`
	PlayerActiveLogs           PlayerActiveLogSlice           `boiler:"PlayerActiveLogs" boil:"PlayerActiveLogs" json:"PlayerActiveLogs" toml:"PlayerActiveLogs" yaml:"PlayerActiveLogs"`
	PlayerKillLogs             PlayerKillLogSlice             `boiler:"PlayerKillLogs" boil:"PlayerKillLogs" json:"PlayerKillLogs" toml:"PlayerKillLogs" yaml:"PlayerKillLogs"`
	PlayerLanguages            PlayerLanguageSlice            `boiler:"PlayerLanguages" boil:"PlayerLanguages" json:"PlayerLanguages" toml:"PlayerLanguages" yaml:"PlayerLanguages"`
	Players                    PlayerSlice                    `boiler:"Players" boil:"Players" json:"Players" toml:"Players" yaml:"Players"`
	PunishVotes                PunishVoteSlice                `boiler:"PunishVotes" boil:"PunishVotes" json:"PunishVotes" toml:"PunishVotes" yaml:"PunishVotes"`
	StakedMechBattleLogs       StakedMechBattleLogSlice       `boiler:"StakedMechBattleLogs" boil:"StakedMechBattleLogs" json:"StakedMechBattleLogs" toml:"StakedMechBattleLogs" yaml:"StakedMechBattleLogs"`
	StakedMechs                StakedMechSlice                `boiler:"StakedMechs" boil:"StakedMechs" json:"StakedMechs" toml:"StakedMechs" yaml:"StakedMechs"`
	StorefrontMysteryCrates    StorefrontMysteryCrateSlice    `boiler:"StorefrontMysteryCrates" boil:"StorefrontMysteryCrates" json:"StorefrontMysteryCrates" toml:"StorefrontMysteryCrates" yaml:"StorefrontMysteryCrates"`
	Syndicates                 SyndicateSlice                 `boiler:"Syndicates" boil:"Syndicates" json:"Syndicates" toml:"Syndicates" yaml:"Syndicates"`
	TemplatesOlds              TemplatesOldSlice              `boiler:"TemplatesOlds" boil:"TemplatesOlds" json:"TemplatesOlds" toml:"TemplatesOlds" yaml:"TemplatesOlds"`
	VoiceStreams               VoiceStreamSlice               `boiler:"VoiceStreams" boil:"VoiceStreams" json:"VoiceStreams" toml:"VoiceStreams" yaml:"VoiceStreams"`
}

// NewStruct creates a new relationship struct
func (*factionR) NewStruct() *factionR {
	return &factionR{}
}

// factionL is where Load methods for each relationship are stored.
type factionL struct{}

var (
	factionAllColumns            = []string{"id", "vote_price", "contract_reward", "label", "guild_id", "deleted_at", "updated_at", "created_at", "logo_url", "background_url", "description", "wallpaper_url"}
	factionColumnsWithoutDefault = []string{"label"}
	factionColumnsWithDefault    = []string{"id", "vote_price", "contract_reward", "guild_id", "deleted_at", "updated_at", "created_at", "logo_url", "background_url", "description", "wallpaper_url"}
	factionPrimaryKeyColumns     = []string{"id"}
	factionGeneratedColumns      = []string{}
)

type (
	// FactionSlice is an alias for a slice of pointers to Faction.
	// This should almost always be used instead of []Faction.
	FactionSlice []*Faction
	// FactionHook is the signature for custom Faction hook methods
	FactionHook func(boil.Executor, *Faction) error

	factionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	factionType                 = reflect.TypeOf(&Faction{})
	factionMapping              = queries.MakeStructMapping(factionType)
	factionPrimaryKeyMapping, _ = queries.BindMapping(factionType, factionMapping, factionPrimaryKeyColumns)
	factionInsertCacheMut       sync.RWMutex
	factionInsertCache          = make(map[string]insertCache)
	factionUpdateCacheMut       sync.RWMutex
	factionUpdateCache          = make(map[string]updateCache)
	factionUpsertCacheMut       sync.RWMutex
	factionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var factionAfterSelectHooks []FactionHook

var factionBeforeInsertHooks []FactionHook
var factionAfterInsertHooks []FactionHook

var factionBeforeUpdateHooks []FactionHook
var factionAfterUpdateHooks []FactionHook

var factionBeforeDeleteHooks []FactionHook
var factionAfterDeleteHooks []FactionHook

var factionBeforeUpsertHooks []FactionHook
var factionAfterUpsertHooks []FactionHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Faction) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range factionAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Faction) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range factionBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Faction) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range factionAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Faction) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range factionBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Faction) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range factionAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Faction) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range factionBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Faction) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range factionAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Faction) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range factionBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Faction) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range factionAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddFactionHook registers your hook function for all future operations.
func AddFactionHook(hookPoint boil.HookPoint, factionHook FactionHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		factionAfterSelectHooks = append(factionAfterSelectHooks, factionHook)
	case boil.BeforeInsertHook:
		factionBeforeInsertHooks = append(factionBeforeInsertHooks, factionHook)
	case boil.AfterInsertHook:
		factionAfterInsertHooks = append(factionAfterInsertHooks, factionHook)
	case boil.BeforeUpdateHook:
		factionBeforeUpdateHooks = append(factionBeforeUpdateHooks, factionHook)
	case boil.AfterUpdateHook:
		factionAfterUpdateHooks = append(factionAfterUpdateHooks, factionHook)
	case boil.BeforeDeleteHook:
		factionBeforeDeleteHooks = append(factionBeforeDeleteHooks, factionHook)
	case boil.AfterDeleteHook:
		factionAfterDeleteHooks = append(factionAfterDeleteHooks, factionHook)
	case boil.BeforeUpsertHook:
		factionBeforeUpsertHooks = append(factionBeforeUpsertHooks, factionHook)
	case boil.AfterUpsertHook:
		factionAfterUpsertHooks = append(factionAfterUpsertHooks, factionHook)
	}
}

// One returns a single faction record from the query.
func (q factionQuery) One(exec boil.Executor) (*Faction, error) {
	o := &Faction{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for factions")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Faction records from the query.
func (q factionQuery) All(exec boil.Executor) (FactionSlice, error) {
	var o []*Faction

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to Faction slice")
	}

	if len(factionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Faction records in the query.
func (q factionQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count factions rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q factionQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if factions exists")
	}

	return count > 0, nil
}

// FactionPalette pointed to by the foreign key.
func (o *Faction) FactionPalette(mods ...qm.QueryMod) factionPaletteQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"faction_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := FactionPalettes(queryMods...)
	queries.SetFrom(query.Query, "\"faction_palettes\"")

	return query
}

// IDFactionStat pointed to by the foreign key.
func (o *Faction) IDFactionStat(mods ...qm.QueryMod) factionStatQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := FactionStats(queryMods...)
	queries.SetFrom(query.Query, "\"faction_stats\"")

	return query
}

// BattleAbilityOptInLogs retrieves all the battle_ability_opt_in_log's BattleAbilityOptInLogs with an executor.
func (o *Faction) BattleAbilityOptInLogs(mods ...qm.QueryMod) battleAbilityOptInLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_ability_opt_in_logs\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_ability_opt_in_logs\".\"deleted_at\""),
	)

	query := BattleAbilityOptInLogs(queryMods...)
	queries.SetFrom(query.Query, "\"battle_ability_opt_in_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_ability_opt_in_logs\".*"})
	}

	return query
}

// BattleAbilityTriggers retrieves all the battle_ability_trigger's BattleAbilityTriggers with an executor.
func (o *Faction) BattleAbilityTriggers(mods ...qm.QueryMod) battleAbilityTriggerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_ability_triggers\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_ability_triggers\".\"deleted_at\""),
	)

	query := BattleAbilityTriggers(queryMods...)
	queries.SetFrom(query.Query, "\"battle_ability_triggers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_ability_triggers\".*"})
	}

	return query
}

// BattleContracts retrieves all the battle_contract's BattleContracts with an executor.
func (o *Faction) BattleContracts(mods ...qm.QueryMod) battleContractQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contracts\".\"faction_id\"=?", o.ID),
	)

	query := BattleContracts(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contracts\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contracts\".*"})
	}

	return query
}

// BattleContributions retrieves all the battle_contribution's BattleContributions with an executor.
func (o *Faction) BattleContributions(mods ...qm.QueryMod) battleContributionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contributions\".\"faction_id\"=?", o.ID),
	)

	query := BattleContributions(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contributions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contributions\".*"})
	}

	return query
}

// BattleLobbiesMechs retrieves all the battle_lobbies_mech's BattleLobbiesMechs with an executor.
func (o *Faction) BattleLobbiesMechs(mods ...qm.QueryMod) battleLobbiesMechQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_lobbies_mechs\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_lobbies_mechs\".\"deleted_at\""),
	)

	query := BattleLobbiesMechs(queryMods...)
	queries.SetFrom(query.Query, "\"battle_lobbies_mechs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_lobbies_mechs\".*"})
	}

	return query
}

// BattleLobbySupporterOptIns retrieves all the battle_lobby_supporter_opt_in's BattleLobbySupporterOptIns with an executor.
func (o *Faction) BattleLobbySupporterOptIns(mods ...qm.QueryMod) battleLobbySupporterOptInQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_lobby_supporter_opt_ins\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_lobby_supporter_opt_ins\".\"deleted_at\""),
	)

	query := BattleLobbySupporterOptIns(queryMods...)
	queries.SetFrom(query.Query, "\"battle_lobby_supporter_opt_ins\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_lobby_supporter_opt_ins\".*"})
	}

	return query
}

// BattleLobbySupporters retrieves all the battle_lobby_supporter's BattleLobbySupporters with an executor.
func (o *Faction) BattleLobbySupporters(mods ...qm.QueryMod) battleLobbySupporterQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_lobby_supporters\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_lobby_supporters\".\"deleted_at\""),
	)

	query := BattleLobbySupporters(queryMods...)
	queries.SetFrom(query.Query, "\"battle_lobby_supporters\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_lobby_supporters\".*"})
	}

	return query
}

// BattleMechs retrieves all the battle_mech's BattleMechs with an executor.
func (o *Faction) BattleMechs(mods ...qm.QueryMod) battleMechQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_mechs\".\"faction_id\"=?", o.ID),
	)

	query := BattleMechs(queryMods...)
	queries.SetFrom(query.Query, "\"battle_mechs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_mechs\".*"})
	}

	return query
}

// BattleQueueOlds retrieves all the battle_queue_old's BattleQueueOlds with an executor.
func (o *Faction) BattleQueueOlds(mods ...qm.QueryMod) battleQueueOldQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_queue_old\".\"faction_id\"=?", o.ID),
	)

	query := BattleQueueOlds(queryMods...)
	queries.SetFrom(query.Query, "\"battle_queue_old\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_queue_old\".*"})
	}

	return query
}

// BattleWins retrieves all the battle_win's BattleWins with an executor.
func (o *Faction) BattleWins(mods ...qm.QueryMod) battleWinQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_wins\".\"faction_id\"=?", o.ID),
	)

	query := BattleWins(queryMods...)
	queries.SetFrom(query.Query, "\"battle_wins\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_wins\".*"})
	}

	return query
}

// Brands retrieves all the brand's Brands with an executor.
func (o *Faction) Brands(mods ...qm.QueryMod) brandQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"brands\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"brands\".\"deleted_at\""),
	)

	query := Brands(queryMods...)
	queries.SetFrom(query.Query, "\"brands\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"brands\".*"})
	}

	return query
}

// ChatHistories retrieves all the chat_history's ChatHistories with an executor.
func (o *Faction) ChatHistories(mods ...qm.QueryMod) chatHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"chat_history\".\"faction_id\"=?", o.ID),
	)

	query := ChatHistories(queryMods...)
	queries.SetFrom(query.Query, "\"chat_history\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"chat_history\".*"})
	}

	return query
}

// GameAbilities retrieves all the game_ability's GameAbilities with an executor.
func (o *Faction) GameAbilities(mods ...qm.QueryMod) gameAbilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"game_abilities\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"game_abilities\".\"deleted_at\""),
	)

	query := GameAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"game_abilities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"game_abilities\".*"})
	}

	return query
}

// ItemKeycardSales retrieves all the item_keycard_sale's ItemKeycardSales with an executor.
func (o *Faction) ItemKeycardSales(mods ...qm.QueryMod) itemKeycardSaleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_keycard_sales\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"item_keycard_sales\".\"deleted_at\""),
	)

	query := ItemKeycardSales(queryMods...)
	queries.SetFrom(query.Query, "\"item_keycard_sales\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_keycard_sales\".*"})
	}

	return query
}

// ItemSales retrieves all the item_sale's ItemSales with an executor.
func (o *Faction) ItemSales(mods ...qm.QueryMod) itemSaleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_sales\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"item_sales\".\"deleted_at\""),
	)

	query := ItemSales(queryMods...)
	queries.SetFrom(query.Query, "\"item_sales\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_sales\".*"})
	}

	return query
}

// MysteryCrates retrieves all the mystery_crate's MysteryCrates with an executor.
func (o *Faction) MysteryCrates(mods ...qm.QueryMod) mysteryCrateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mystery_crate\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"mystery_crate\".\"deleted_at\""),
	)

	query := MysteryCrates(queryMods...)
	queries.SetFrom(query.Query, "\"mystery_crate\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mystery_crate\".*"})
	}

	return query
}

// PlayerActiveLogs retrieves all the player_active_log's PlayerActiveLogs with an executor.
func (o *Faction) PlayerActiveLogs(mods ...qm.QueryMod) playerActiveLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_active_logs\".\"faction_id\"=?", o.ID),
	)

	query := PlayerActiveLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_active_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_active_logs\".*"})
	}

	return query
}

// PlayerKillLogs retrieves all the player_kill_log's PlayerKillLogs with an executor.
func (o *Faction) PlayerKillLogs(mods ...qm.QueryMod) playerKillLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_kill_log\".\"faction_id\"=?", o.ID),
	)

	query := PlayerKillLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_kill_log\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_kill_log\".*"})
	}

	return query
}

// PlayerLanguages retrieves all the player_language's PlayerLanguages with an executor.
func (o *Faction) PlayerLanguages(mods ...qm.QueryMod) playerLanguageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_languages\".\"faction_id\"=?", o.ID),
	)

	query := PlayerLanguages(queryMods...)
	queries.SetFrom(query.Query, "\"player_languages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_languages\".*"})
	}

	return query
}

// Players retrieves all the player's Players with an executor.
func (o *Faction) Players(mods ...qm.QueryMod) playerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"players\".\"deleted_at\""),
	)

	query := Players(queryMods...)
	queries.SetFrom(query.Query, "\"players\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players\".*"})
	}

	return query
}

// PunishVotes retrieves all the punish_vote's PunishVotes with an executor.
func (o *Faction) PunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// StakedMechBattleLogs retrieves all the staked_mech_battle_log's StakedMechBattleLogs with an executor.
func (o *Faction) StakedMechBattleLogs(mods ...qm.QueryMod) stakedMechBattleLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"staked_mech_battle_logs\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"staked_mech_battle_logs\".\"deleted_at\""),
	)

	query := StakedMechBattleLogs(queryMods...)
	queries.SetFrom(query.Query, "\"staked_mech_battle_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"staked_mech_battle_logs\".*"})
	}

	return query
}

// StakedMechs retrieves all the staked_mech's StakedMechs with an executor.
func (o *Faction) StakedMechs(mods ...qm.QueryMod) stakedMechQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"staked_mechs\".\"faction_id\"=?", o.ID),
	)

	query := StakedMechs(queryMods...)
	queries.SetFrom(query.Query, "\"staked_mechs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"staked_mechs\".*"})
	}

	return query
}

// StorefrontMysteryCrates retrieves all the storefront_mystery_crate's StorefrontMysteryCrates with an executor.
func (o *Faction) StorefrontMysteryCrates(mods ...qm.QueryMod) storefrontMysteryCrateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"storefront_mystery_crates\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"storefront_mystery_crates\".\"deleted_at\""),
	)

	query := StorefrontMysteryCrates(queryMods...)
	queries.SetFrom(query.Query, "\"storefront_mystery_crates\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"storefront_mystery_crates\".*"})
	}

	return query
}

// Syndicates retrieves all the syndicate's Syndicates with an executor.
func (o *Faction) Syndicates(mods ...qm.QueryMod) syndicateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicates\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicates\".\"deleted_at\""),
	)

	query := Syndicates(queryMods...)
	queries.SetFrom(query.Query, "\"syndicates\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicates\".*"})
	}

	return query
}

// TemplatesOlds retrieves all the templates_old's TemplatesOlds with an executor.
func (o *Faction) TemplatesOlds(mods ...qm.QueryMod) templatesOldQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"templates_old\".\"faction_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"templates_old\".\"deleted_at\""),
	)

	query := TemplatesOlds(queryMods...)
	queries.SetFrom(query.Query, "\"templates_old\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"templates_old\".*"})
	}

	return query
}

// VoiceStreams retrieves all the voice_stream's VoiceStreams with an executor.
func (o *Faction) VoiceStreams(mods ...qm.QueryMod) voiceStreamQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"voice_streams\".\"faction_id\"=?", o.ID),
	)

	query := VoiceStreams(queryMods...)
	queries.SetFrom(query.Query, "\"voice_streams\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"voice_streams\".*"})
	}

	return query
}

// LoadFactionPalette allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (factionL) LoadFactionPalette(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`faction_palettes`),
		qm.WhereIn(`faction_palettes.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FactionPalette")
	}

	var resultSlice []*FactionPalette
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FactionPalette")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for faction_palettes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for faction_palettes")
	}

	if len(factionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FactionPalette = foreign
		if foreign.R == nil {
			foreign.R = &factionPaletteR{}
		}
		foreign.R.Faction = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.FactionID {
				local.R.FactionPalette = foreign
				if foreign.R == nil {
					foreign.R = &factionPaletteR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadIDFactionStat allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (factionL) LoadIDFactionStat(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`faction_stats`),
		qm.WhereIn(`faction_stats.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FactionStat")
	}

	var resultSlice []*FactionStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FactionStat")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for faction_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for faction_stats")
	}

	if len(factionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IDFactionStat = foreign
		if foreign.R == nil {
			foreign.R = &factionStatR{}
		}
		foreign.R.IDFaction = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.ID {
				local.R.IDFactionStat = foreign
				if foreign.R == nil {
					foreign.R = &factionStatR{}
				}
				foreign.R.IDFaction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleAbilityOptInLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleAbilityOptInLogs(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_ability_opt_in_logs`),
		qm.WhereIn(`battle_ability_opt_in_logs.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_ability_opt_in_logs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_ability_opt_in_logs")
	}

	var resultSlice []*BattleAbilityOptInLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_ability_opt_in_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_ability_opt_in_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_ability_opt_in_logs")
	}

	if len(battleAbilityOptInLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleAbilityOptInLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleAbilityOptInLogR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleAbilityOptInLogs = append(local.R.BattleAbilityOptInLogs, foreign)
				if foreign.R == nil {
					foreign.R = &battleAbilityOptInLogR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleAbilityTriggers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleAbilityTriggers(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_ability_triggers`),
		qm.WhereIn(`battle_ability_triggers.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_ability_triggers.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_ability_triggers")
	}

	var resultSlice []*BattleAbilityTrigger
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_ability_triggers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_ability_triggers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_ability_triggers")
	}

	if len(battleAbilityTriggerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleAbilityTriggers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleAbilityTriggerR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleAbilityTriggers = append(local.R.BattleAbilityTriggers, foreign)
				if foreign.R == nil {
					foreign.R = &battleAbilityTriggerR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContracts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleContracts(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contracts`),
		qm.WhereIn(`battle_contracts.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contracts")
	}

	var resultSlice []*BattleContract
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contracts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contracts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contracts")
	}

	if len(battleContractAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContracts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContractR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleContracts = append(local.R.BattleContracts, foreign)
				if foreign.R == nil {
					foreign.R = &battleContractR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContributions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleContributions(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contributions`),
		qm.WhereIn(`battle_contributions.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contributions")
	}

	var resultSlice []*BattleContribution
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contributions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contributions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contributions")
	}

	if len(battleContributionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContributions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContributionR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleContributions = append(local.R.BattleContributions, foreign)
				if foreign.R == nil {
					foreign.R = &battleContributionR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleLobbiesMechs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleLobbiesMechs(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_lobbies_mechs`),
		qm.WhereIn(`battle_lobbies_mechs.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_lobbies_mechs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_lobbies_mechs")
	}

	var resultSlice []*BattleLobbiesMech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_lobbies_mechs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_lobbies_mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_lobbies_mechs")
	}

	if len(battleLobbiesMechAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleLobbiesMechs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleLobbiesMechR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleLobbiesMechs = append(local.R.BattleLobbiesMechs, foreign)
				if foreign.R == nil {
					foreign.R = &battleLobbiesMechR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleLobbySupporterOptIns allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleLobbySupporterOptIns(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_lobby_supporter_opt_ins`),
		qm.WhereIn(`battle_lobby_supporter_opt_ins.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_lobby_supporter_opt_ins.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_lobby_supporter_opt_ins")
	}

	var resultSlice []*BattleLobbySupporterOptIn
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_lobby_supporter_opt_ins")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_lobby_supporter_opt_ins")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_lobby_supporter_opt_ins")
	}

	if len(battleLobbySupporterOptInAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleLobbySupporterOptIns = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleLobbySupporterOptInR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleLobbySupporterOptIns = append(local.R.BattleLobbySupporterOptIns, foreign)
				if foreign.R == nil {
					foreign.R = &battleLobbySupporterOptInR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleLobbySupporters allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleLobbySupporters(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_lobby_supporters`),
		qm.WhereIn(`battle_lobby_supporters.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_lobby_supporters.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_lobby_supporters")
	}

	var resultSlice []*BattleLobbySupporter
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_lobby_supporters")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_lobby_supporters")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_lobby_supporters")
	}

	if len(battleLobbySupporterAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleLobbySupporters = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleLobbySupporterR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleLobbySupporters = append(local.R.BattleLobbySupporters, foreign)
				if foreign.R == nil {
					foreign.R = &battleLobbySupporterR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleMechs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleMechs(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_mechs`),
		qm.WhereIn(`battle_mechs.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_mechs")
	}

	var resultSlice []*BattleMech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_mechs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_mechs")
	}

	if len(battleMechAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleMechs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleMechR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleMechs = append(local.R.BattleMechs, foreign)
				if foreign.R == nil {
					foreign.R = &battleMechR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleQueueOlds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleQueueOlds(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_queue_old`),
		qm.WhereIn(`battle_queue_old.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_queue_old")
	}

	var resultSlice []*BattleQueueOld
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_queue_old")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_queue_old")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_queue_old")
	}

	if len(battleQueueOldAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleQueueOlds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleQueueOldR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleQueueOlds = append(local.R.BattleQueueOlds, foreign)
				if foreign.R == nil {
					foreign.R = &battleQueueOldR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBattleWins allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBattleWins(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_wins`),
		qm.WhereIn(`battle_wins.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_wins")
	}

	var resultSlice []*BattleWin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_wins")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_wins")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_wins")
	}

	if len(battleWinAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleWins = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleWinR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.BattleWins = append(local.R.BattleWins, foreign)
				if foreign.R == nil {
					foreign.R = &battleWinR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadBrands allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadBrands(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`brands`),
		qm.WhereIn(`brands.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`brands.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load brands")
	}

	var resultSlice []*Brand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice brands")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on brands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for brands")
	}

	if len(brandAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Brands = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &brandR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.Brands = append(local.R.Brands, foreign)
				if foreign.R == nil {
					foreign.R = &brandR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadChatHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadChatHistories(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`chat_history`),
		qm.WhereIn(`chat_history.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load chat_history")
	}

	var resultSlice []*ChatHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice chat_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on chat_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chat_history")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ChatHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &chatHistoryR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.ChatHistories = append(local.R.ChatHistories, foreign)
				if foreign.R == nil {
					foreign.R = &chatHistoryR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadGameAbilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadGameAbilities(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`game_abilities`),
		qm.WhereIn(`game_abilities.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`game_abilities.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load game_abilities")
	}

	var resultSlice []*GameAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice game_abilities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on game_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for game_abilities")
	}

	if len(gameAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.GameAbilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &gameAbilityR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.GameAbilities = append(local.R.GameAbilities, foreign)
				if foreign.R == nil {
					foreign.R = &gameAbilityR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadItemKeycardSales allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadItemKeycardSales(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_keycard_sales`),
		qm.WhereIn(`item_keycard_sales.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`item_keycard_sales.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_keycard_sales")
	}

	var resultSlice []*ItemKeycardSale
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_keycard_sales")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_keycard_sales")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_keycard_sales")
	}

	if len(itemKeycardSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ItemKeycardSales = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemKeycardSaleR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.ItemKeycardSales = append(local.R.ItemKeycardSales, foreign)
				if foreign.R == nil {
					foreign.R = &itemKeycardSaleR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadItemSales allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadItemSales(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_sales`),
		qm.WhereIn(`item_sales.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`item_sales.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_sales")
	}

	var resultSlice []*ItemSale
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_sales")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_sales")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_sales")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ItemSales = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemSaleR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.ItemSales = append(local.R.ItemSales, foreign)
				if foreign.R == nil {
					foreign.R = &itemSaleR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadMysteryCrates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadMysteryCrates(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mystery_crate`),
		qm.WhereIn(`mystery_crate.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`mystery_crate.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mystery_crate")
	}

	var resultSlice []*MysteryCrate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mystery_crate")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mystery_crate")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mystery_crate")
	}

	if len(mysteryCrateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MysteryCrates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mysteryCrateR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.MysteryCrates = append(local.R.MysteryCrates, foreign)
				if foreign.R == nil {
					foreign.R = &mysteryCrateR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerActiveLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadPlayerActiveLogs(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_active_logs`),
		qm.WhereIn(`player_active_logs.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_active_logs")
	}

	var resultSlice []*PlayerActiveLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_active_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_active_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_active_logs")
	}

	if len(playerActiveLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerActiveLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerActiveLogR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.FactionID) {
				local.R.PlayerActiveLogs = append(local.R.PlayerActiveLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerActiveLogR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerKillLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadPlayerKillLogs(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_kill_log`),
		qm.WhereIn(`player_kill_log.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_kill_log")
	}

	var resultSlice []*PlayerKillLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_kill_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_kill_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_kill_log")
	}

	if len(playerKillLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerKillLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerKillLogR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.PlayerKillLogs = append(local.R.PlayerKillLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerKillLogR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerLanguages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadPlayerLanguages(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_languages`),
		qm.WhereIn(`player_languages.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_languages")
	}

	var resultSlice []*PlayerLanguage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_languages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_languages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_languages")
	}

	if len(playerLanguageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerLanguages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerLanguageR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.PlayerLanguages = append(local.R.PlayerLanguages, foreign)
				if foreign.R == nil {
					foreign.R = &playerLanguageR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadPlayers(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Players = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.FactionID) {
				local.R.Players = append(local.R.Players, foreign)
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadPunishVotes(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.PunishVotes = append(local.R.PunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadStakedMechBattleLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadStakedMechBattleLogs(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`staked_mech_battle_logs`),
		qm.WhereIn(`staked_mech_battle_logs.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`staked_mech_battle_logs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load staked_mech_battle_logs")
	}

	var resultSlice []*StakedMechBattleLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice staked_mech_battle_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on staked_mech_battle_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for staked_mech_battle_logs")
	}

	if len(stakedMechBattleLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StakedMechBattleLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &stakedMechBattleLogR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.StakedMechBattleLogs = append(local.R.StakedMechBattleLogs, foreign)
				if foreign.R == nil {
					foreign.R = &stakedMechBattleLogR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadStakedMechs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadStakedMechs(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`staked_mechs`),
		qm.WhereIn(`staked_mechs.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load staked_mechs")
	}

	var resultSlice []*StakedMech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice staked_mechs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on staked_mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for staked_mechs")
	}

	if len(stakedMechAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StakedMechs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &stakedMechR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.StakedMechs = append(local.R.StakedMechs, foreign)
				if foreign.R == nil {
					foreign.R = &stakedMechR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadStorefrontMysteryCrates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadStorefrontMysteryCrates(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`storefront_mystery_crates`),
		qm.WhereIn(`storefront_mystery_crates.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`storefront_mystery_crates.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load storefront_mystery_crates")
	}

	var resultSlice []*StorefrontMysteryCrate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice storefront_mystery_crates")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on storefront_mystery_crates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for storefront_mystery_crates")
	}

	if len(storefrontMysteryCrateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StorefrontMysteryCrates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &storefrontMysteryCrateR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.StorefrontMysteryCrates = append(local.R.StorefrontMysteryCrates, foreign)
				if foreign.R == nil {
					foreign.R = &storefrontMysteryCrateR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadSyndicates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadSyndicates(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicates`),
		qm.WhereIn(`syndicates.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicates.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicates")
	}

	var resultSlice []*Syndicate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicates")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicates")
	}

	if len(syndicateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Syndicates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.Syndicates = append(local.R.Syndicates, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadTemplatesOlds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadTemplatesOlds(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`templates_old`),
		qm.WhereIn(`templates_old.faction_id in ?`, args...),
		qmhelper.WhereIsNull(`templates_old.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load templates_old")
	}

	var resultSlice []*TemplatesOld
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice templates_old")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on templates_old")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for templates_old")
	}

	if len(templatesOldAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.TemplatesOlds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &templatesOldR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.TemplatesOlds = append(local.R.TemplatesOlds, foreign)
				if foreign.R == nil {
					foreign.R = &templatesOldR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// LoadVoiceStreams allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factionL) LoadVoiceStreams(e boil.Executor, singular bool, maybeFaction interface{}, mods queries.Applicator) error {
	var slice []*Faction
	var object *Faction

	if singular {
		object = maybeFaction.(*Faction)
	} else {
		slice = *maybeFaction.(*[]*Faction)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`voice_streams`),
		qm.WhereIn(`voice_streams.faction_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load voice_streams")
	}

	var resultSlice []*VoiceStream
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice voice_streams")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on voice_streams")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for voice_streams")
	}

	if len(voiceStreamAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VoiceStreams = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &voiceStreamR{}
			}
			foreign.R.Faction = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FactionID {
				local.R.VoiceStreams = append(local.R.VoiceStreams, foreign)
				if foreign.R == nil {
					foreign.R = &voiceStreamR{}
				}
				foreign.R.Faction = local
				break
			}
		}
	}

	return nil
}

// SetFactionPalette of the faction to the related item.
// Sets o.R.FactionPalette to related.
// Adds o to related.R.Faction.
func (o *Faction) SetFactionPalette(exec boil.Executor, insert bool, related *FactionPalette) error {
	var err error

	if insert {
		related.FactionID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"faction_palettes\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
			strmangle.WhereClause("\"", "\"", 2, factionPalettePrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.FactionID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FactionID = o.ID

	}

	if o.R == nil {
		o.R = &factionR{
			FactionPalette: related,
		}
	} else {
		o.R.FactionPalette = related
	}

	if related.R == nil {
		related.R = &factionPaletteR{
			Faction: o,
		}
	} else {
		related.R.Faction = o
	}
	return nil
}

// SetIDFactionStat of the faction to the related item.
// Sets o.R.IDFactionStat to related.
// Adds o to related.R.IDFaction.
func (o *Faction) SetIDFactionStat(exec boil.Executor, insert bool, related *FactionStat) error {
	var err error

	if insert {
		related.ID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"faction_stats\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"id"}),
			strmangle.WhereClause("\"", "\"", 2, factionStatPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.ID = o.ID

	}

	if o.R == nil {
		o.R = &factionR{
			IDFactionStat: related,
		}
	} else {
		o.R.IDFactionStat = related
	}

	if related.R == nil {
		related.R = &factionStatR{
			IDFaction: o,
		}
	} else {
		related.R.IDFaction = o
	}
	return nil
}

// AddBattleAbilityOptInLogs adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleAbilityOptInLogs.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleAbilityOptInLogs(exec boil.Executor, insert bool, related ...*BattleAbilityOptInLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_ability_opt_in_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleAbilityOptInLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleAbilityOptInLogs: related,
		}
	} else {
		o.R.BattleAbilityOptInLogs = append(o.R.BattleAbilityOptInLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleAbilityOptInLogR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleAbilityTriggers adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleAbilityTriggers.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_ability_triggers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleAbilityTriggerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleAbilityTriggers: related,
		}
	} else {
		o.R.BattleAbilityTriggers = append(o.R.BattleAbilityTriggers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleAbilityTriggerR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleContracts adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleContracts.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleContracts(exec boil.Executor, insert bool, related ...*BattleContract) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contracts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContractPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleContracts: related,
		}
	} else {
		o.R.BattleContracts = append(o.R.BattleContracts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContractR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleContributions adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleContributions.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleContributions(exec boil.Executor, insert bool, related ...*BattleContribution) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contributions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContributionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleContributions: related,
		}
	} else {
		o.R.BattleContributions = append(o.R.BattleContributions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContributionR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleLobbiesMechs adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleLobbiesMechs.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleLobbiesMechs(exec boil.Executor, insert bool, related ...*BattleLobbiesMech) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_lobbies_mechs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleLobbiesMechPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleLobbiesMechs: related,
		}
	} else {
		o.R.BattleLobbiesMechs = append(o.R.BattleLobbiesMechs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleLobbiesMechR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleLobbySupporterOptIns adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleLobbySupporterOptIns.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleLobbySupporterOptIns(exec boil.Executor, insert bool, related ...*BattleLobbySupporterOptIn) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_lobby_supporter_opt_ins\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleLobbySupporterOptInPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleLobbySupporterOptIns: related,
		}
	} else {
		o.R.BattleLobbySupporterOptIns = append(o.R.BattleLobbySupporterOptIns, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleLobbySupporterOptInR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleLobbySupporters adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleLobbySupporters.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleLobbySupporters(exec boil.Executor, insert bool, related ...*BattleLobbySupporter) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_lobby_supporters\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleLobbySupporterPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleLobbySupporters: related,
		}
	} else {
		o.R.BattleLobbySupporters = append(o.R.BattleLobbySupporters, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleLobbySupporterR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleMechs adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleMechs.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleMechs(exec boil.Executor, insert bool, related ...*BattleMech) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_mechs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleMechPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleMechs: related,
		}
	} else {
		o.R.BattleMechs = append(o.R.BattleMechs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleMechR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleQueueOlds adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleQueueOlds.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleQueueOlds(exec boil.Executor, insert bool, related ...*BattleQueueOld) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_queue_old\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleQueueOldPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleQueueOlds: related,
		}
	} else {
		o.R.BattleQueueOlds = append(o.R.BattleQueueOlds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleQueueOldR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBattleWins adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.BattleWins.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBattleWins(exec boil.Executor, insert bool, related ...*BattleWin) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_wins\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleWinPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			BattleWins: related,
		}
	} else {
		o.R.BattleWins = append(o.R.BattleWins, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleWinR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddBrands adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.Brands.
// Sets related.R.Faction appropriately.
func (o *Faction) AddBrands(exec boil.Executor, insert bool, related ...*Brand) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"brands\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, brandPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			Brands: related,
		}
	} else {
		o.R.Brands = append(o.R.Brands, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &brandR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddChatHistories adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.ChatHistories.
// Sets related.R.Faction appropriately.
func (o *Faction) AddChatHistories(exec boil.Executor, insert bool, related ...*ChatHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"chat_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			ChatHistories: related,
		}
	} else {
		o.R.ChatHistories = append(o.R.ChatHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &chatHistoryR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddGameAbilities adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.GameAbilities.
// Sets related.R.Faction appropriately.
func (o *Faction) AddGameAbilities(exec boil.Executor, insert bool, related ...*GameAbility) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"game_abilities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, gameAbilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			GameAbilities: related,
		}
	} else {
		o.R.GameAbilities = append(o.R.GameAbilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &gameAbilityR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddItemKeycardSales adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.ItemKeycardSales.
// Sets related.R.Faction appropriately.
func (o *Faction) AddItemKeycardSales(exec boil.Executor, insert bool, related ...*ItemKeycardSale) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_keycard_sales\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemKeycardSalePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			ItemKeycardSales: related,
		}
	} else {
		o.R.ItemKeycardSales = append(o.R.ItemKeycardSales, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemKeycardSaleR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddItemSales adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.ItemSales.
// Sets related.R.Faction appropriately.
func (o *Faction) AddItemSales(exec boil.Executor, insert bool, related ...*ItemSale) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_sales\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemSalePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			ItemSales: related,
		}
	} else {
		o.R.ItemSales = append(o.R.ItemSales, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemSaleR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddMysteryCrates adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.MysteryCrates.
// Sets related.R.Faction appropriately.
func (o *Faction) AddMysteryCrates(exec boil.Executor, insert bool, related ...*MysteryCrate) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mystery_crate\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, mysteryCratePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			MysteryCrates: related,
		}
	} else {
		o.R.MysteryCrates = append(o.R.MysteryCrates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mysteryCrateR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddPlayerActiveLogs adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.PlayerActiveLogs.
// Sets related.R.Faction appropriately.
func (o *Faction) AddPlayerActiveLogs(exec boil.Executor, insert bool, related ...*PlayerActiveLog) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FactionID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_active_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerActiveLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FactionID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &factionR{
			PlayerActiveLogs: related,
		}
	} else {
		o.R.PlayerActiveLogs = append(o.R.PlayerActiveLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerActiveLogR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// SetPlayerActiveLogs removes all previously related items of the
// faction replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Faction's PlayerActiveLogs accordingly.
// Replaces o.R.PlayerActiveLogs with related.
// Sets related.R.Faction's PlayerActiveLogs accordingly.
func (o *Faction) SetPlayerActiveLogs(exec boil.Executor, insert bool, related ...*PlayerActiveLog) error {
	query := "update \"player_active_logs\" set \"faction_id\" = null where \"faction_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PlayerActiveLogs {
			queries.SetScanner(&rel.FactionID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Faction = nil
		}

		o.R.PlayerActiveLogs = nil
	}
	return o.AddPlayerActiveLogs(exec, insert, related...)
}

// RemovePlayerActiveLogs relationships from objects passed in.
// Removes related items from R.PlayerActiveLogs (uses pointer comparison, removal does not keep order)
// Sets related.R.Faction.
func (o *Faction) RemovePlayerActiveLogs(exec boil.Executor, related ...*PlayerActiveLog) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FactionID, nil)
		if rel.R != nil {
			rel.R.Faction = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("faction_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PlayerActiveLogs {
			if rel != ri {
				continue
			}

			ln := len(o.R.PlayerActiveLogs)
			if ln > 1 && i < ln-1 {
				o.R.PlayerActiveLogs[i] = o.R.PlayerActiveLogs[ln-1]
			}
			o.R.PlayerActiveLogs = o.R.PlayerActiveLogs[:ln-1]
			break
		}
	}

	return nil
}

// AddPlayerKillLogs adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.PlayerKillLogs.
// Sets related.R.Faction appropriately.
func (o *Faction) AddPlayerKillLogs(exec boil.Executor, insert bool, related ...*PlayerKillLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_kill_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerKillLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			PlayerKillLogs: related,
		}
	} else {
		o.R.PlayerKillLogs = append(o.R.PlayerKillLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerKillLogR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddPlayerLanguages adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.PlayerLanguages.
// Sets related.R.Faction appropriately.
func (o *Faction) AddPlayerLanguages(exec boil.Executor, insert bool, related ...*PlayerLanguage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_languages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerLanguagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			PlayerLanguages: related,
		}
	} else {
		o.R.PlayerLanguages = append(o.R.PlayerLanguages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerLanguageR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddPlayers adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.Players.
// Sets related.R.Faction appropriately.
func (o *Faction) AddPlayers(exec boil.Executor, insert bool, related ...*Player) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FactionID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FactionID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &factionR{
			Players: related,
		}
	} else {
		o.R.Players = append(o.R.Players, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// SetPlayers removes all previously related items of the
// faction replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Faction's Players accordingly.
// Replaces o.R.Players with related.
// Sets related.R.Faction's Players accordingly.
func (o *Faction) SetPlayers(exec boil.Executor, insert bool, related ...*Player) error {
	query := "update \"players\" set \"faction_id\" = null where \"faction_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Players {
			queries.SetScanner(&rel.FactionID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Faction = nil
		}

		o.R.Players = nil
	}
	return o.AddPlayers(exec, insert, related...)
}

// RemovePlayers relationships from objects passed in.
// Removes related items from R.Players (uses pointer comparison, removal does not keep order)
// Sets related.R.Faction.
func (o *Faction) RemovePlayers(exec boil.Executor, related ...*Player) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FactionID, nil)
		if rel.R != nil {
			rel.R.Faction = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("faction_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Players {
			if rel != ri {
				continue
			}

			ln := len(o.R.Players)
			if ln > 1 && i < ln-1 {
				o.R.Players[i] = o.R.Players[ln-1]
			}
			o.R.Players = o.R.Players[:ln-1]
			break
		}
	}

	return nil
}

// AddPunishVotes adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.PunishVotes.
// Sets related.R.Faction appropriately.
func (o *Faction) AddPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			PunishVotes: related,
		}
	} else {
		o.R.PunishVotes = append(o.R.PunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddStakedMechBattleLogs adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.StakedMechBattleLogs.
// Sets related.R.Faction appropriately.
func (o *Faction) AddStakedMechBattleLogs(exec boil.Executor, insert bool, related ...*StakedMechBattleLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"staked_mech_battle_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, stakedMechBattleLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			StakedMechBattleLogs: related,
		}
	} else {
		o.R.StakedMechBattleLogs = append(o.R.StakedMechBattleLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &stakedMechBattleLogR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddStakedMechs adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.StakedMechs.
// Sets related.R.Faction appropriately.
func (o *Faction) AddStakedMechs(exec boil.Executor, insert bool, related ...*StakedMech) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"staked_mechs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, stakedMechPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			StakedMechs: related,
		}
	} else {
		o.R.StakedMechs = append(o.R.StakedMechs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &stakedMechR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddStorefrontMysteryCrates adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.StorefrontMysteryCrates.
// Sets related.R.Faction appropriately.
func (o *Faction) AddStorefrontMysteryCrates(exec boil.Executor, insert bool, related ...*StorefrontMysteryCrate) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"storefront_mystery_crates\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, storefrontMysteryCratePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			StorefrontMysteryCrates: related,
		}
	} else {
		o.R.StorefrontMysteryCrates = append(o.R.StorefrontMysteryCrates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &storefrontMysteryCrateR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddSyndicates adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.Syndicates.
// Sets related.R.Faction appropriately.
func (o *Faction) AddSyndicates(exec boil.Executor, insert bool, related ...*Syndicate) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicates\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			Syndicates: related,
		}
	} else {
		o.R.Syndicates = append(o.R.Syndicates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddTemplatesOlds adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.TemplatesOlds.
// Sets related.R.Faction appropriately.
func (o *Faction) AddTemplatesOlds(exec boil.Executor, insert bool, related ...*TemplatesOld) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"templates_old\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, templatesOldPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			TemplatesOlds: related,
		}
	} else {
		o.R.TemplatesOlds = append(o.R.TemplatesOlds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &templatesOldR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// AddVoiceStreams adds the given related objects to the existing relationships
// of the faction, optionally inserting them as new records.
// Appends related to o.R.VoiceStreams.
// Sets related.R.Faction appropriately.
func (o *Faction) AddVoiceStreams(exec boil.Executor, insert bool, related ...*VoiceStream) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"voice_streams\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
				strmangle.WhereClause("\"", "\"", 2, voiceStreamPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &factionR{
			VoiceStreams: related,
		}
	} else {
		o.R.VoiceStreams = append(o.R.VoiceStreams, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &voiceStreamR{
				Faction: o,
			}
		} else {
			rel.R.Faction = o
		}
	}
	return nil
}

// Factions retrieves all the records using an executor.
func Factions(mods ...qm.QueryMod) factionQuery {
	mods = append(mods, qm.From("\"factions\""), qmhelper.WhereIsNull("\"factions\".\"deleted_at\""))
	return factionQuery{NewQuery(mods...)}
}

// FindFaction retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindFaction(exec boil.Executor, iD string, selectCols ...string) (*Faction, error) {
	factionObj := &Faction{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"factions\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, factionObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from factions")
	}

	if err = factionObj.doAfterSelectHooks(exec); err != nil {
		return factionObj, err
	}

	return factionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Faction) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no factions provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(factionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	factionInsertCacheMut.RLock()
	cache, cached := factionInsertCache[key]
	factionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			factionAllColumns,
			factionColumnsWithDefault,
			factionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(factionType, factionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(factionType, factionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"factions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"factions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into factions")
	}

	if !cached {
		factionInsertCacheMut.Lock()
		factionInsertCache[key] = cache
		factionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the Faction.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Faction) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	factionUpdateCacheMut.RLock()
	cache, cached := factionUpdateCache[key]
	factionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			factionAllColumns,
			factionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update factions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"factions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, factionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(factionType, factionMapping, append(wl, factionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update factions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for factions")
	}

	if !cached {
		factionUpdateCacheMut.Lock()
		factionUpdateCache[key] = cache
		factionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q factionQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for factions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for factions")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o FactionSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), factionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"factions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, factionPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in faction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all faction")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Faction) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no factions provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(factionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	factionUpsertCacheMut.RLock()
	cache, cached := factionUpsertCache[key]
	factionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			factionAllColumns,
			factionColumnsWithDefault,
			factionColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			factionAllColumns,
			factionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert factions, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(factionPrimaryKeyColumns))
			copy(conflict, factionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"factions\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(factionType, factionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(factionType, factionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert factions")
	}

	if !cached {
		factionUpsertCacheMut.Lock()
		factionUpsertCache[key] = cache
		factionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single Faction record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Faction) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no Faction provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), factionPrimaryKeyMapping)
		sql = "DELETE FROM \"factions\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"factions\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(factionType, factionMapping, append(wl, factionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from factions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for factions")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q factionQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no factionQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from factions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for factions")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o FactionSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(factionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), factionPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"factions\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, factionPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), factionPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"factions\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, factionPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from faction slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for factions")
	}

	if len(factionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Faction) Reload(exec boil.Executor) error {
	ret, err := FindFaction(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *FactionSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := FactionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), factionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"factions\".* FROM \"factions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, factionPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in FactionSlice")
	}

	*o = slice

	return nil
}

// FactionExists checks if the Faction row exists.
func FactionExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"factions\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if factions exists")
	}

	return exists, nil
}
