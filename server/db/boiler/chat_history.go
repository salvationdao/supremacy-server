// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// ChatHistory is an object representing the database table.
type ChatHistory struct {
	ID              string      `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	FactionID       string      `boiler:"faction_id" boil:"faction_id" json:"faction_id" toml:"faction_id" yaml:"faction_id"`
	PlayerID        string      `boiler:"player_id" boil:"player_id" json:"player_id" toml:"player_id" yaml:"player_id"`
	MessageColor    string      `boiler:"message_color" boil:"message_color" json:"message_color" toml:"message_color" yaml:"message_color"`
	Text            string      `boiler:"text" boil:"text" json:"text" toml:"text" yaml:"text"`
	BattleID        null.String `boiler:"battle_id" boil:"battle_id" json:"battle_id,omitempty" toml:"battle_id" yaml:"battle_id,omitempty"`
	MSGType         string      `boiler:"msg_type" boil:"msg_type" json:"msg_type" toml:"msg_type" yaml:"msg_type"`
	ChatStream      string      `boiler:"chat_stream" boil:"chat_stream" json:"chat_stream" toml:"chat_stream" yaml:"chat_stream"`
	UserRank        string      `boiler:"user_rank" boil:"user_rank" json:"user_rank" toml:"user_rank" yaml:"user_rank"`
	TotalMultiplier string      `boiler:"total_multiplier" boil:"total_multiplier" json:"total_multiplier" toml:"total_multiplier" yaml:"total_multiplier"`
	KillCount       string      `boiler:"kill_count" boil:"kill_count" json:"kill_count" toml:"kill_count" yaml:"kill_count"`
	IsCitizen       bool        `boiler:"is_citizen" boil:"is_citizen" json:"is_citizen" toml:"is_citizen" yaml:"is_citizen"`
	Lang            string      `boiler:"lang" boil:"lang" json:"lang" toml:"lang" yaml:"lang"`
	CreatedAt       time.Time   `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	Metadata        null.JSON   `boiler:"metadata" boil:"metadata" json:"metadata,omitempty" toml:"metadata" yaml:"metadata,omitempty"`
	ArenaID         null.String `boiler:"arena_id" boil:"arena_id" json:"arena_id,omitempty" toml:"arena_id" yaml:"arena_id,omitempty"`

	R *chatHistoryR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L chatHistoryL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ChatHistoryColumns = struct {
	ID              string
	FactionID       string
	PlayerID        string
	MessageColor    string
	Text            string
	BattleID        string
	MSGType         string
	ChatStream      string
	UserRank        string
	TotalMultiplier string
	KillCount       string
	IsCitizen       string
	Lang            string
	CreatedAt       string
	Metadata        string
	ArenaID         string
}{
	ID:              "id",
	FactionID:       "faction_id",
	PlayerID:        "player_id",
	MessageColor:    "message_color",
	Text:            "text",
	BattleID:        "battle_id",
	MSGType:         "msg_type",
	ChatStream:      "chat_stream",
	UserRank:        "user_rank",
	TotalMultiplier: "total_multiplier",
	KillCount:       "kill_count",
	IsCitizen:       "is_citizen",
	Lang:            "lang",
	CreatedAt:       "created_at",
	Metadata:        "metadata",
	ArenaID:         "arena_id",
}

var ChatHistoryTableColumns = struct {
	ID              string
	FactionID       string
	PlayerID        string
	MessageColor    string
	Text            string
	BattleID        string
	MSGType         string
	ChatStream      string
	UserRank        string
	TotalMultiplier string
	KillCount       string
	IsCitizen       string
	Lang            string
	CreatedAt       string
	Metadata        string
	ArenaID         string
}{
	ID:              "chat_history.id",
	FactionID:       "chat_history.faction_id",
	PlayerID:        "chat_history.player_id",
	MessageColor:    "chat_history.message_color",
	Text:            "chat_history.text",
	BattleID:        "chat_history.battle_id",
	MSGType:         "chat_history.msg_type",
	ChatStream:      "chat_history.chat_stream",
	UserRank:        "chat_history.user_rank",
	TotalMultiplier: "chat_history.total_multiplier",
	KillCount:       "chat_history.kill_count",
	IsCitizen:       "chat_history.is_citizen",
	Lang:            "chat_history.lang",
	CreatedAt:       "chat_history.created_at",
	Metadata:        "chat_history.metadata",
	ArenaID:         "chat_history.arena_id",
}

// Generated where

var ChatHistoryWhere = struct {
	ID              whereHelperstring
	FactionID       whereHelperstring
	PlayerID        whereHelperstring
	MessageColor    whereHelperstring
	Text            whereHelperstring
	BattleID        whereHelpernull_String
	MSGType         whereHelperstring
	ChatStream      whereHelperstring
	UserRank        whereHelperstring
	TotalMultiplier whereHelperstring
	KillCount       whereHelperstring
	IsCitizen       whereHelperbool
	Lang            whereHelperstring
	CreatedAt       whereHelpertime_Time
	Metadata        whereHelpernull_JSON
	ArenaID         whereHelpernull_String
}{
	ID:              whereHelperstring{field: "\"chat_history\".\"id\""},
	FactionID:       whereHelperstring{field: "\"chat_history\".\"faction_id\""},
	PlayerID:        whereHelperstring{field: "\"chat_history\".\"player_id\""},
	MessageColor:    whereHelperstring{field: "\"chat_history\".\"message_color\""},
	Text:            whereHelperstring{field: "\"chat_history\".\"text\""},
	BattleID:        whereHelpernull_String{field: "\"chat_history\".\"battle_id\""},
	MSGType:         whereHelperstring{field: "\"chat_history\".\"msg_type\""},
	ChatStream:      whereHelperstring{field: "\"chat_history\".\"chat_stream\""},
	UserRank:        whereHelperstring{field: "\"chat_history\".\"user_rank\""},
	TotalMultiplier: whereHelperstring{field: "\"chat_history\".\"total_multiplier\""},
	KillCount:       whereHelperstring{field: "\"chat_history\".\"kill_count\""},
	IsCitizen:       whereHelperbool{field: "\"chat_history\".\"is_citizen\""},
	Lang:            whereHelperstring{field: "\"chat_history\".\"lang\""},
	CreatedAt:       whereHelpertime_Time{field: "\"chat_history\".\"created_at\""},
	Metadata:        whereHelpernull_JSON{field: "\"chat_history\".\"metadata\""},
	ArenaID:         whereHelpernull_String{field: "\"chat_history\".\"arena_id\""},
}

// ChatHistoryRels is where relationship names are stored.
var ChatHistoryRels = struct {
	Arena   string
	Battle  string
	Faction string
	Player  string
}{
	Arena:   "Arena",
	Battle:  "Battle",
	Faction: "Faction",
	Player:  "Player",
}

// chatHistoryR is where relationships are stored.
type chatHistoryR struct {
	Arena   *BattleArena `boiler:"Arena" boil:"Arena" json:"Arena" toml:"Arena" yaml:"Arena"`
	Battle  *Battle      `boiler:"Battle" boil:"Battle" json:"Battle" toml:"Battle" yaml:"Battle"`
	Faction *Faction     `boiler:"Faction" boil:"Faction" json:"Faction" toml:"Faction" yaml:"Faction"`
	Player  *Player      `boiler:"Player" boil:"Player" json:"Player" toml:"Player" yaml:"Player"`
}

// NewStruct creates a new relationship struct
func (*chatHistoryR) NewStruct() *chatHistoryR {
	return &chatHistoryR{}
}

// chatHistoryL is where Load methods for each relationship are stored.
type chatHistoryL struct{}

var (
	chatHistoryAllColumns            = []string{"id", "faction_id", "player_id", "message_color", "text", "battle_id", "msg_type", "chat_stream", "user_rank", "total_multiplier", "kill_count", "is_citizen", "lang", "created_at", "metadata", "arena_id"}
	chatHistoryColumnsWithoutDefault = []string{"faction_id", "player_id", "message_color", "text", "user_rank", "total_multiplier", "kill_count"}
	chatHistoryColumnsWithDefault    = []string{"id", "battle_id", "msg_type", "chat_stream", "is_citizen", "lang", "created_at", "metadata", "arena_id"}
	chatHistoryPrimaryKeyColumns     = []string{"id"}
	chatHistoryGeneratedColumns      = []string{}
)

type (
	// ChatHistorySlice is an alias for a slice of pointers to ChatHistory.
	// This should almost always be used instead of []ChatHistory.
	ChatHistorySlice []*ChatHistory
	// ChatHistoryHook is the signature for custom ChatHistory hook methods
	ChatHistoryHook func(boil.Executor, *ChatHistory) error

	chatHistoryQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	chatHistoryType                 = reflect.TypeOf(&ChatHistory{})
	chatHistoryMapping              = queries.MakeStructMapping(chatHistoryType)
	chatHistoryPrimaryKeyMapping, _ = queries.BindMapping(chatHistoryType, chatHistoryMapping, chatHistoryPrimaryKeyColumns)
	chatHistoryInsertCacheMut       sync.RWMutex
	chatHistoryInsertCache          = make(map[string]insertCache)
	chatHistoryUpdateCacheMut       sync.RWMutex
	chatHistoryUpdateCache          = make(map[string]updateCache)
	chatHistoryUpsertCacheMut       sync.RWMutex
	chatHistoryUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var chatHistoryAfterSelectHooks []ChatHistoryHook

var chatHistoryBeforeInsertHooks []ChatHistoryHook
var chatHistoryAfterInsertHooks []ChatHistoryHook

var chatHistoryBeforeUpdateHooks []ChatHistoryHook
var chatHistoryAfterUpdateHooks []ChatHistoryHook

var chatHistoryBeforeDeleteHooks []ChatHistoryHook
var chatHistoryAfterDeleteHooks []ChatHistoryHook

var chatHistoryBeforeUpsertHooks []ChatHistoryHook
var chatHistoryAfterUpsertHooks []ChatHistoryHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *ChatHistory) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *ChatHistory) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *ChatHistory) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *ChatHistory) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *ChatHistory) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *ChatHistory) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *ChatHistory) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *ChatHistory) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *ChatHistory) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range chatHistoryAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddChatHistoryHook registers your hook function for all future operations.
func AddChatHistoryHook(hookPoint boil.HookPoint, chatHistoryHook ChatHistoryHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		chatHistoryAfterSelectHooks = append(chatHistoryAfterSelectHooks, chatHistoryHook)
	case boil.BeforeInsertHook:
		chatHistoryBeforeInsertHooks = append(chatHistoryBeforeInsertHooks, chatHistoryHook)
	case boil.AfterInsertHook:
		chatHistoryAfterInsertHooks = append(chatHistoryAfterInsertHooks, chatHistoryHook)
	case boil.BeforeUpdateHook:
		chatHistoryBeforeUpdateHooks = append(chatHistoryBeforeUpdateHooks, chatHistoryHook)
	case boil.AfterUpdateHook:
		chatHistoryAfterUpdateHooks = append(chatHistoryAfterUpdateHooks, chatHistoryHook)
	case boil.BeforeDeleteHook:
		chatHistoryBeforeDeleteHooks = append(chatHistoryBeforeDeleteHooks, chatHistoryHook)
	case boil.AfterDeleteHook:
		chatHistoryAfterDeleteHooks = append(chatHistoryAfterDeleteHooks, chatHistoryHook)
	case boil.BeforeUpsertHook:
		chatHistoryBeforeUpsertHooks = append(chatHistoryBeforeUpsertHooks, chatHistoryHook)
	case boil.AfterUpsertHook:
		chatHistoryAfterUpsertHooks = append(chatHistoryAfterUpsertHooks, chatHistoryHook)
	}
}

// One returns a single chatHistory record from the query.
func (q chatHistoryQuery) One(exec boil.Executor) (*ChatHistory, error) {
	o := &ChatHistory{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for chat_history")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all ChatHistory records from the query.
func (q chatHistoryQuery) All(exec boil.Executor) (ChatHistorySlice, error) {
	var o []*ChatHistory

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to ChatHistory slice")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all ChatHistory records in the query.
func (q chatHistoryQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count chat_history rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q chatHistoryQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if chat_history exists")
	}

	return count > 0, nil
}

// Arena pointed to by the foreign key.
func (o *ChatHistory) Arena(mods ...qm.QueryMod) battleArenaQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ArenaID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := BattleArenas(queryMods...)
	queries.SetFrom(query.Query, "\"battle_arena\"")

	return query
}

// Battle pointed to by the foreign key.
func (o *ChatHistory) Battle(mods ...qm.QueryMod) battleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BattleID),
	}

	queryMods = append(queryMods, mods...)

	query := Battles(queryMods...)
	queries.SetFrom(query.Query, "\"battles\"")

	return query
}

// Faction pointed to by the foreign key.
func (o *ChatHistory) Faction(mods ...qm.QueryMod) factionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FactionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Factions(queryMods...)
	queries.SetFrom(query.Query, "\"factions\"")

	return query
}

// Player pointed to by the foreign key.
func (o *ChatHistory) Player(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PlayerID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Players(queryMods...)
	queries.SetFrom(query.Query, "\"players\"")

	return query
}

// LoadArena allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (chatHistoryL) LoadArena(e boil.Executor, singular bool, maybeChatHistory interface{}, mods queries.Applicator) error {
	var slice []*ChatHistory
	var object *ChatHistory

	if singular {
		object = maybeChatHistory.(*ChatHistory)
	} else {
		slice = *maybeChatHistory.(*[]*ChatHistory)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &chatHistoryR{}
		}
		if !queries.IsNil(object.ArenaID) {
			args = append(args, object.ArenaID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &chatHistoryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ArenaID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ArenaID) {
				args = append(args, obj.ArenaID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_arena`),
		qm.WhereIn(`battle_arena.id in ?`, args...),
		qmhelper.WhereIsNull(`battle_arena.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BattleArena")
	}

	var resultSlice []*BattleArena
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BattleArena")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for battle_arena")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_arena")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Arena = foreign
		if foreign.R == nil {
			foreign.R = &battleArenaR{}
		}
		foreign.R.ArenaChatHistories = append(foreign.R.ArenaChatHistories, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ArenaID, foreign.ID) {
				local.R.Arena = foreign
				if foreign.R == nil {
					foreign.R = &battleArenaR{}
				}
				foreign.R.ArenaChatHistories = append(foreign.R.ArenaChatHistories, local)
				break
			}
		}
	}

	return nil
}

// LoadBattle allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (chatHistoryL) LoadBattle(e boil.Executor, singular bool, maybeChatHistory interface{}, mods queries.Applicator) error {
	var slice []*ChatHistory
	var object *ChatHistory

	if singular {
		object = maybeChatHistory.(*ChatHistory)
	} else {
		slice = *maybeChatHistory.(*[]*ChatHistory)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &chatHistoryR{}
		}
		if !queries.IsNil(object.BattleID) {
			args = append(args, object.BattleID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &chatHistoryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BattleID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BattleID) {
				args = append(args, obj.BattleID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battles`),
		qm.WhereIn(`battles.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Battle")
	}

	var resultSlice []*Battle
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Battle")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for battles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battles")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Battle = foreign
		if foreign.R == nil {
			foreign.R = &battleR{}
		}
		foreign.R.ChatHistories = append(foreign.R.ChatHistories, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BattleID, foreign.ID) {
				local.R.Battle = foreign
				if foreign.R == nil {
					foreign.R = &battleR{}
				}
				foreign.R.ChatHistories = append(foreign.R.ChatHistories, local)
				break
			}
		}
	}

	return nil
}

// LoadFaction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (chatHistoryL) LoadFaction(e boil.Executor, singular bool, maybeChatHistory interface{}, mods queries.Applicator) error {
	var slice []*ChatHistory
	var object *ChatHistory

	if singular {
		object = maybeChatHistory.(*ChatHistory)
	} else {
		slice = *maybeChatHistory.(*[]*ChatHistory)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &chatHistoryR{}
		}
		args = append(args, object.FactionID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &chatHistoryR{}
			}

			for _, a := range args {
				if a == obj.FactionID {
					continue Outer
				}
			}

			args = append(args, obj.FactionID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`factions`),
		qm.WhereIn(`factions.id in ?`, args...),
		qmhelper.WhereIsNull(`factions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Faction")
	}

	var resultSlice []*Faction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Faction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factions")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Faction = foreign
		if foreign.R == nil {
			foreign.R = &factionR{}
		}
		foreign.R.ChatHistories = append(foreign.R.ChatHistories, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FactionID == foreign.ID {
				local.R.Faction = foreign
				if foreign.R == nil {
					foreign.R = &factionR{}
				}
				foreign.R.ChatHistories = append(foreign.R.ChatHistories, local)
				break
			}
		}
	}

	return nil
}

// LoadPlayer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (chatHistoryL) LoadPlayer(e boil.Executor, singular bool, maybeChatHistory interface{}, mods queries.Applicator) error {
	var slice []*ChatHistory
	var object *ChatHistory

	if singular {
		object = maybeChatHistory.(*ChatHistory)
	} else {
		slice = *maybeChatHistory.(*[]*ChatHistory)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &chatHistoryR{}
		}
		args = append(args, object.PlayerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &chatHistoryR{}
			}

			for _, a := range args {
				if a == obj.PlayerID {
					continue Outer
				}
			}

			args = append(args, obj.PlayerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.id in ?`, args...),
		qmhelper.WhereIsNull(`players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Player = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.ChatHistories = append(foreign.R.ChatHistories, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PlayerID == foreign.ID {
				local.R.Player = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.ChatHistories = append(foreign.R.ChatHistories, local)
				break
			}
		}
	}

	return nil
}

// SetArena of the chatHistory to the related item.
// Sets o.R.Arena to related.
// Adds o to related.R.ArenaChatHistories.
func (o *ChatHistory) SetArena(exec boil.Executor, insert bool, related *BattleArena) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"chat_history\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"arena_id"}),
		strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ArenaID, related.ID)
	if o.R == nil {
		o.R = &chatHistoryR{
			Arena: related,
		}
	} else {
		o.R.Arena = related
	}

	if related.R == nil {
		related.R = &battleArenaR{
			ArenaChatHistories: ChatHistorySlice{o},
		}
	} else {
		related.R.ArenaChatHistories = append(related.R.ArenaChatHistories, o)
	}

	return nil
}

// RemoveArena relationship.
// Sets o.R.Arena to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ChatHistory) RemoveArena(exec boil.Executor, related *BattleArena) error {
	var err error

	queries.SetScanner(&o.ArenaID, nil)
	if _, err = o.Update(exec, boil.Whitelist("arena_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Arena = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ArenaChatHistories {
		if queries.Equal(o.ArenaID, ri.ArenaID) {
			continue
		}

		ln := len(related.R.ArenaChatHistories)
		if ln > 1 && i < ln-1 {
			related.R.ArenaChatHistories[i] = related.R.ArenaChatHistories[ln-1]
		}
		related.R.ArenaChatHistories = related.R.ArenaChatHistories[:ln-1]
		break
	}
	return nil
}

// SetBattle of the chatHistory to the related item.
// Sets o.R.Battle to related.
// Adds o to related.R.ChatHistories.
func (o *ChatHistory) SetBattle(exec boil.Executor, insert bool, related *Battle) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"chat_history\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"battle_id"}),
		strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BattleID, related.ID)
	if o.R == nil {
		o.R = &chatHistoryR{
			Battle: related,
		}
	} else {
		o.R.Battle = related
	}

	if related.R == nil {
		related.R = &battleR{
			ChatHistories: ChatHistorySlice{o},
		}
	} else {
		related.R.ChatHistories = append(related.R.ChatHistories, o)
	}

	return nil
}

// RemoveBattle relationship.
// Sets o.R.Battle to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ChatHistory) RemoveBattle(exec boil.Executor, related *Battle) error {
	var err error

	queries.SetScanner(&o.BattleID, nil)
	if _, err = o.Update(exec, boil.Whitelist("battle_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Battle = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ChatHistories {
		if queries.Equal(o.BattleID, ri.BattleID) {
			continue
		}

		ln := len(related.R.ChatHistories)
		if ln > 1 && i < ln-1 {
			related.R.ChatHistories[i] = related.R.ChatHistories[ln-1]
		}
		related.R.ChatHistories = related.R.ChatHistories[:ln-1]
		break
	}
	return nil
}

// SetFaction of the chatHistory to the related item.
// Sets o.R.Faction to related.
// Adds o to related.R.ChatHistories.
func (o *ChatHistory) SetFaction(exec boil.Executor, insert bool, related *Faction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"chat_history\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
		strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FactionID = related.ID
	if o.R == nil {
		o.R = &chatHistoryR{
			Faction: related,
		}
	} else {
		o.R.Faction = related
	}

	if related.R == nil {
		related.R = &factionR{
			ChatHistories: ChatHistorySlice{o},
		}
	} else {
		related.R.ChatHistories = append(related.R.ChatHistories, o)
	}

	return nil
}

// SetPlayer of the chatHistory to the related item.
// Sets o.R.Player to related.
// Adds o to related.R.ChatHistories.
func (o *ChatHistory) SetPlayer(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"chat_history\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
		strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PlayerID = related.ID
	if o.R == nil {
		o.R = &chatHistoryR{
			Player: related,
		}
	} else {
		o.R.Player = related
	}

	if related.R == nil {
		related.R = &playerR{
			ChatHistories: ChatHistorySlice{o},
		}
	} else {
		related.R.ChatHistories = append(related.R.ChatHistories, o)
	}

	return nil
}

// ChatHistories retrieves all the records using an executor.
func ChatHistories(mods ...qm.QueryMod) chatHistoryQuery {
	mods = append(mods, qm.From("\"chat_history\""))
	return chatHistoryQuery{NewQuery(mods...)}
}

// FindChatHistory retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindChatHistory(exec boil.Executor, iD string, selectCols ...string) (*ChatHistory, error) {
	chatHistoryObj := &ChatHistory{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"chat_history\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, chatHistoryObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from chat_history")
	}

	if err = chatHistoryObj.doAfterSelectHooks(exec); err != nil {
		return chatHistoryObj, err
	}

	return chatHistoryObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *ChatHistory) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no chat_history provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(chatHistoryColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	chatHistoryInsertCacheMut.RLock()
	cache, cached := chatHistoryInsertCache[key]
	chatHistoryInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			chatHistoryAllColumns,
			chatHistoryColumnsWithDefault,
			chatHistoryColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(chatHistoryType, chatHistoryMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(chatHistoryType, chatHistoryMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"chat_history\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"chat_history\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into chat_history")
	}

	if !cached {
		chatHistoryInsertCacheMut.Lock()
		chatHistoryInsertCache[key] = cache
		chatHistoryInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the ChatHistory.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *ChatHistory) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	chatHistoryUpdateCacheMut.RLock()
	cache, cached := chatHistoryUpdateCache[key]
	chatHistoryUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			chatHistoryAllColumns,
			chatHistoryPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update chat_history, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"chat_history\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, chatHistoryPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(chatHistoryType, chatHistoryMapping, append(wl, chatHistoryPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update chat_history row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for chat_history")
	}

	if !cached {
		chatHistoryUpdateCacheMut.Lock()
		chatHistoryUpdateCache[key] = cache
		chatHistoryUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q chatHistoryQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for chat_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for chat_history")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ChatHistorySlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), chatHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"chat_history\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, chatHistoryPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in chatHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all chatHistory")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *ChatHistory) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no chat_history provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(chatHistoryColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	chatHistoryUpsertCacheMut.RLock()
	cache, cached := chatHistoryUpsertCache[key]
	chatHistoryUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			chatHistoryAllColumns,
			chatHistoryColumnsWithDefault,
			chatHistoryColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			chatHistoryAllColumns,
			chatHistoryPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert chat_history, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(chatHistoryPrimaryKeyColumns))
			copy(conflict, chatHistoryPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"chat_history\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(chatHistoryType, chatHistoryMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(chatHistoryType, chatHistoryMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert chat_history")
	}

	if !cached {
		chatHistoryUpsertCacheMut.Lock()
		chatHistoryUpsertCache[key] = cache
		chatHistoryUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single ChatHistory record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *ChatHistory) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no ChatHistory provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), chatHistoryPrimaryKeyMapping)
	sql := "DELETE FROM \"chat_history\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from chat_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for chat_history")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q chatHistoryQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no chatHistoryQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from chat_history")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for chat_history")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ChatHistorySlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(chatHistoryBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), chatHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"chat_history\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, chatHistoryPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from chatHistory slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for chat_history")
	}

	if len(chatHistoryAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *ChatHistory) Reload(exec boil.Executor) error {
	ret, err := FindChatHistory(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ChatHistorySlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ChatHistorySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), chatHistoryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"chat_history\".* FROM \"chat_history\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, chatHistoryPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in ChatHistorySlice")
	}

	*o = slice

	return nil
}

// ChatHistoryExists checks if the ChatHistory row exists.
func ChatHistoryExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"chat_history\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if chat_history exists")
	}

	return exists, nil
}
