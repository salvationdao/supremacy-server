// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// GameAbility is an object representing the database table.
type GameAbility struct {
	ID                           string      `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	GameClientAbilityID          int         `boiler:"game_client_ability_id" boil:"game_client_ability_id" json:"game_client_ability_id" toml:"game_client_ability_id" yaml:"game_client_ability_id"`
	FactionID                    string      `boiler:"faction_id" boil:"faction_id" json:"faction_id" toml:"faction_id" yaml:"faction_id"`
	BattleAbilityID              null.String `boiler:"battle_ability_id" boil:"battle_ability_id" json:"battle_ability_id,omitempty" toml:"battle_ability_id" yaml:"battle_ability_id,omitempty"`
	Label                        string      `boiler:"label" boil:"label" json:"label" toml:"label" yaml:"label"`
	Colour                       string      `boiler:"colour" boil:"colour" json:"colour" toml:"colour" yaml:"colour"`
	ImageURL                     string      `boiler:"image_url" boil:"image_url" json:"image_url" toml:"image_url" yaml:"image_url"`
	Description                  string      `boiler:"description" boil:"description" json:"description" toml:"description" yaml:"description"`
	TextColour                   string      `boiler:"text_colour" boil:"text_colour" json:"text_colour" toml:"text_colour" yaml:"text_colour"`
	Level                        string      `boiler:"level" boil:"level" json:"level" toml:"level" yaml:"level"`
	LocationSelectType           string      `boiler:"location_select_type" boil:"location_select_type" json:"location_select_type" toml:"location_select_type" yaml:"location_select_type"`
	DeletedAt                    null.Time   `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	LaunchingDelaySeconds        int         `boiler:"launching_delay_seconds" boil:"launching_delay_seconds" json:"launching_delay_seconds" toml:"launching_delay_seconds" yaml:"launching_delay_seconds"`
	DisplayOnMiniMap             bool        `boiler:"display_on_mini_map" boil:"display_on_mini_map" json:"display_on_mini_map" toml:"display_on_mini_map" yaml:"display_on_mini_map"`
	MiniMapDisplayEffectType     string      `boiler:"mini_map_display_effect_type" boil:"mini_map_display_effect_type" json:"mini_map_display_effect_type" toml:"mini_map_display_effect_type" yaml:"mini_map_display_effect_type"`
	MechDisplayEffectType        string      `boiler:"mech_display_effect_type" boil:"mech_display_effect_type" json:"mech_display_effect_type" toml:"mech_display_effect_type" yaml:"mech_display_effect_type"`
	AnimationDurationSeconds     int         `boiler:"animation_duration_seconds" boil:"animation_duration_seconds" json:"animation_duration_seconds" toml:"animation_duration_seconds" yaml:"animation_duration_seconds"`
	ShouldCheckTeamKill          bool        `boiler:"should_check_team_kill" boil:"should_check_team_kill" json:"should_check_team_kill" toml:"should_check_team_kill" yaml:"should_check_team_kill"`
	MaximumTeamKillTolerantCount int         `boiler:"maximum_team_kill_tolerant_count" boil:"maximum_team_kill_tolerant_count" json:"maximum_team_kill_tolerant_count" toml:"maximum_team_kill_tolerant_count" yaml:"maximum_team_kill_tolerant_count"`
	IgnoreSelfKill               bool        `boiler:"ignore_self_kill" boil:"ignore_self_kill" json:"ignore_self_kill" toml:"ignore_self_kill" yaml:"ignore_self_kill"`
	CountPerBattle               int         `boiler:"count_per_battle" boil:"count_per_battle" json:"count_per_battle" toml:"count_per_battle" yaml:"count_per_battle"`

	R *gameAbilityR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L gameAbilityL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var GameAbilityColumns = struct {
	ID                           string
	GameClientAbilityID          string
	FactionID                    string
	BattleAbilityID              string
	Label                        string
	Colour                       string
	ImageURL                     string
	Description                  string
	TextColour                   string
	Level                        string
	LocationSelectType           string
	DeletedAt                    string
	LaunchingDelaySeconds        string
	DisplayOnMiniMap             string
	MiniMapDisplayEffectType     string
	MechDisplayEffectType        string
	AnimationDurationSeconds     string
	ShouldCheckTeamKill          string
	MaximumTeamKillTolerantCount string
	IgnoreSelfKill               string
	CountPerBattle               string
}{
	ID:                           "id",
	GameClientAbilityID:          "game_client_ability_id",
	FactionID:                    "faction_id",
	BattleAbilityID:              "battle_ability_id",
	Label:                        "label",
	Colour:                       "colour",
	ImageURL:                     "image_url",
	Description:                  "description",
	TextColour:                   "text_colour",
	Level:                        "level",
	LocationSelectType:           "location_select_type",
	DeletedAt:                    "deleted_at",
	LaunchingDelaySeconds:        "launching_delay_seconds",
	DisplayOnMiniMap:             "display_on_mini_map",
	MiniMapDisplayEffectType:     "mini_map_display_effect_type",
	MechDisplayEffectType:        "mech_display_effect_type",
	AnimationDurationSeconds:     "animation_duration_seconds",
	ShouldCheckTeamKill:          "should_check_team_kill",
	MaximumTeamKillTolerantCount: "maximum_team_kill_tolerant_count",
	IgnoreSelfKill:               "ignore_self_kill",
	CountPerBattle:               "count_per_battle",
}

var GameAbilityTableColumns = struct {
	ID                           string
	GameClientAbilityID          string
	FactionID                    string
	BattleAbilityID              string
	Label                        string
	Colour                       string
	ImageURL                     string
	Description                  string
	TextColour                   string
	Level                        string
	LocationSelectType           string
	DeletedAt                    string
	LaunchingDelaySeconds        string
	DisplayOnMiniMap             string
	MiniMapDisplayEffectType     string
	MechDisplayEffectType        string
	AnimationDurationSeconds     string
	ShouldCheckTeamKill          string
	MaximumTeamKillTolerantCount string
	IgnoreSelfKill               string
	CountPerBattle               string
}{
	ID:                           "game_abilities.id",
	GameClientAbilityID:          "game_abilities.game_client_ability_id",
	FactionID:                    "game_abilities.faction_id",
	BattleAbilityID:              "game_abilities.battle_ability_id",
	Label:                        "game_abilities.label",
	Colour:                       "game_abilities.colour",
	ImageURL:                     "game_abilities.image_url",
	Description:                  "game_abilities.description",
	TextColour:                   "game_abilities.text_colour",
	Level:                        "game_abilities.level",
	LocationSelectType:           "game_abilities.location_select_type",
	DeletedAt:                    "game_abilities.deleted_at",
	LaunchingDelaySeconds:        "game_abilities.launching_delay_seconds",
	DisplayOnMiniMap:             "game_abilities.display_on_mini_map",
	MiniMapDisplayEffectType:     "game_abilities.mini_map_display_effect_type",
	MechDisplayEffectType:        "game_abilities.mech_display_effect_type",
	AnimationDurationSeconds:     "game_abilities.animation_duration_seconds",
	ShouldCheckTeamKill:          "game_abilities.should_check_team_kill",
	MaximumTeamKillTolerantCount: "game_abilities.maximum_team_kill_tolerant_count",
	IgnoreSelfKill:               "game_abilities.ignore_self_kill",
	CountPerBattle:               "game_abilities.count_per_battle",
}

// Generated where

var GameAbilityWhere = struct {
	ID                           whereHelperstring
	GameClientAbilityID          whereHelperint
	FactionID                    whereHelperstring
	BattleAbilityID              whereHelpernull_String
	Label                        whereHelperstring
	Colour                       whereHelperstring
	ImageURL                     whereHelperstring
	Description                  whereHelperstring
	TextColour                   whereHelperstring
	Level                        whereHelperstring
	LocationSelectType           whereHelperstring
	DeletedAt                    whereHelpernull_Time
	LaunchingDelaySeconds        whereHelperint
	DisplayOnMiniMap             whereHelperbool
	MiniMapDisplayEffectType     whereHelperstring
	MechDisplayEffectType        whereHelperstring
	AnimationDurationSeconds     whereHelperint
	ShouldCheckTeamKill          whereHelperbool
	MaximumTeamKillTolerantCount whereHelperint
	IgnoreSelfKill               whereHelperbool
	CountPerBattle               whereHelperint
}{
	ID:                           whereHelperstring{field: "\"game_abilities\".\"id\""},
	GameClientAbilityID:          whereHelperint{field: "\"game_abilities\".\"game_client_ability_id\""},
	FactionID:                    whereHelperstring{field: "\"game_abilities\".\"faction_id\""},
	BattleAbilityID:              whereHelpernull_String{field: "\"game_abilities\".\"battle_ability_id\""},
	Label:                        whereHelperstring{field: "\"game_abilities\".\"label\""},
	Colour:                       whereHelperstring{field: "\"game_abilities\".\"colour\""},
	ImageURL:                     whereHelperstring{field: "\"game_abilities\".\"image_url\""},
	Description:                  whereHelperstring{field: "\"game_abilities\".\"description\""},
	TextColour:                   whereHelperstring{field: "\"game_abilities\".\"text_colour\""},
	Level:                        whereHelperstring{field: "\"game_abilities\".\"level\""},
	LocationSelectType:           whereHelperstring{field: "\"game_abilities\".\"location_select_type\""},
	DeletedAt:                    whereHelpernull_Time{field: "\"game_abilities\".\"deleted_at\""},
	LaunchingDelaySeconds:        whereHelperint{field: "\"game_abilities\".\"launching_delay_seconds\""},
	DisplayOnMiniMap:             whereHelperbool{field: "\"game_abilities\".\"display_on_mini_map\""},
	MiniMapDisplayEffectType:     whereHelperstring{field: "\"game_abilities\".\"mini_map_display_effect_type\""},
	MechDisplayEffectType:        whereHelperstring{field: "\"game_abilities\".\"mech_display_effect_type\""},
	AnimationDurationSeconds:     whereHelperint{field: "\"game_abilities\".\"animation_duration_seconds\""},
	ShouldCheckTeamKill:          whereHelperbool{field: "\"game_abilities\".\"should_check_team_kill\""},
	MaximumTeamKillTolerantCount: whereHelperint{field: "\"game_abilities\".\"maximum_team_kill_tolerant_count\""},
	IgnoreSelfKill:               whereHelperbool{field: "\"game_abilities\".\"ignore_self_kill\""},
	CountPerBattle:               whereHelperint{field: "\"game_abilities\".\"count_per_battle\""},
}

// GameAbilityRels is where relationship names are stored.
var GameAbilityRels = struct {
	BattleAbility              string
	Faction                    string
	BattleAbilityTriggers      string
	BattleEventsGameAbilities  string
	MechAbilityTriggerLogsOlds string
	PlayerBattleAbilities      string
	PlayerKillLogs             string
}{
	BattleAbility:              "BattleAbility",
	Faction:                    "Faction",
	BattleAbilityTriggers:      "BattleAbilityTriggers",
	BattleEventsGameAbilities:  "BattleEventsGameAbilities",
	MechAbilityTriggerLogsOlds: "MechAbilityTriggerLogsOlds",
	PlayerBattleAbilities:      "PlayerBattleAbilities",
	PlayerKillLogs:             "PlayerKillLogs",
}

// gameAbilityR is where relationships are stored.
type gameAbilityR struct {
	BattleAbility              *BattleAbility                 `boiler:"BattleAbility" boil:"BattleAbility" json:"BattleAbility" toml:"BattleAbility" yaml:"BattleAbility"`
	Faction                    *Faction                       `boiler:"Faction" boil:"Faction" json:"Faction" toml:"Faction" yaml:"Faction"`
	BattleAbilityTriggers      BattleAbilityTriggerSlice      `boiler:"BattleAbilityTriggers" boil:"BattleAbilityTriggers" json:"BattleAbilityTriggers" toml:"BattleAbilityTriggers" yaml:"BattleAbilityTriggers"`
	BattleEventsGameAbilities  BattleEventsGameAbilitySlice   `boiler:"BattleEventsGameAbilities" boil:"BattleEventsGameAbilities" json:"BattleEventsGameAbilities" toml:"BattleEventsGameAbilities" yaml:"BattleEventsGameAbilities"`
	MechAbilityTriggerLogsOlds MechAbilityTriggerLogsOldSlice `boiler:"MechAbilityTriggerLogsOlds" boil:"MechAbilityTriggerLogsOlds" json:"MechAbilityTriggerLogsOlds" toml:"MechAbilityTriggerLogsOlds" yaml:"MechAbilityTriggerLogsOlds"`
	PlayerBattleAbilities      PlayerBattleAbilitySlice       `boiler:"PlayerBattleAbilities" boil:"PlayerBattleAbilities" json:"PlayerBattleAbilities" toml:"PlayerBattleAbilities" yaml:"PlayerBattleAbilities"`
	PlayerKillLogs             PlayerKillLogSlice             `boiler:"PlayerKillLogs" boil:"PlayerKillLogs" json:"PlayerKillLogs" toml:"PlayerKillLogs" yaml:"PlayerKillLogs"`
}

// NewStruct creates a new relationship struct
func (*gameAbilityR) NewStruct() *gameAbilityR {
	return &gameAbilityR{}
}

// gameAbilityL is where Load methods for each relationship are stored.
type gameAbilityL struct{}

var (
	gameAbilityAllColumns            = []string{"id", "game_client_ability_id", "faction_id", "battle_ability_id", "label", "colour", "image_url", "description", "text_colour", "level", "location_select_type", "deleted_at", "launching_delay_seconds", "display_on_mini_map", "mini_map_display_effect_type", "mech_display_effect_type", "animation_duration_seconds", "should_check_team_kill", "maximum_team_kill_tolerant_count", "ignore_self_kill", "count_per_battle"}
	gameAbilityColumnsWithoutDefault = []string{"game_client_ability_id", "faction_id", "label", "colour", "image_url", "description", "text_colour"}
	gameAbilityColumnsWithDefault    = []string{"id", "battle_ability_id", "level", "location_select_type", "deleted_at", "launching_delay_seconds", "display_on_mini_map", "mini_map_display_effect_type", "mech_display_effect_type", "animation_duration_seconds", "should_check_team_kill", "maximum_team_kill_tolerant_count", "ignore_self_kill", "count_per_battle"}
	gameAbilityPrimaryKeyColumns     = []string{"id"}
	gameAbilityGeneratedColumns      = []string{}
)

type (
	// GameAbilitySlice is an alias for a slice of pointers to GameAbility.
	// This should almost always be used instead of []GameAbility.
	GameAbilitySlice []*GameAbility
	// GameAbilityHook is the signature for custom GameAbility hook methods
	GameAbilityHook func(boil.Executor, *GameAbility) error

	gameAbilityQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	gameAbilityType                 = reflect.TypeOf(&GameAbility{})
	gameAbilityMapping              = queries.MakeStructMapping(gameAbilityType)
	gameAbilityPrimaryKeyMapping, _ = queries.BindMapping(gameAbilityType, gameAbilityMapping, gameAbilityPrimaryKeyColumns)
	gameAbilityInsertCacheMut       sync.RWMutex
	gameAbilityInsertCache          = make(map[string]insertCache)
	gameAbilityUpdateCacheMut       sync.RWMutex
	gameAbilityUpdateCache          = make(map[string]updateCache)
	gameAbilityUpsertCacheMut       sync.RWMutex
	gameAbilityUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var gameAbilityAfterSelectHooks []GameAbilityHook

var gameAbilityBeforeInsertHooks []GameAbilityHook
var gameAbilityAfterInsertHooks []GameAbilityHook

var gameAbilityBeforeUpdateHooks []GameAbilityHook
var gameAbilityAfterUpdateHooks []GameAbilityHook

var gameAbilityBeforeDeleteHooks []GameAbilityHook
var gameAbilityAfterDeleteHooks []GameAbilityHook

var gameAbilityBeforeUpsertHooks []GameAbilityHook
var gameAbilityAfterUpsertHooks []GameAbilityHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *GameAbility) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *GameAbility) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *GameAbility) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *GameAbility) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *GameAbility) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *GameAbility) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *GameAbility) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *GameAbility) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *GameAbility) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range gameAbilityAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddGameAbilityHook registers your hook function for all future operations.
func AddGameAbilityHook(hookPoint boil.HookPoint, gameAbilityHook GameAbilityHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		gameAbilityAfterSelectHooks = append(gameAbilityAfterSelectHooks, gameAbilityHook)
	case boil.BeforeInsertHook:
		gameAbilityBeforeInsertHooks = append(gameAbilityBeforeInsertHooks, gameAbilityHook)
	case boil.AfterInsertHook:
		gameAbilityAfterInsertHooks = append(gameAbilityAfterInsertHooks, gameAbilityHook)
	case boil.BeforeUpdateHook:
		gameAbilityBeforeUpdateHooks = append(gameAbilityBeforeUpdateHooks, gameAbilityHook)
	case boil.AfterUpdateHook:
		gameAbilityAfterUpdateHooks = append(gameAbilityAfterUpdateHooks, gameAbilityHook)
	case boil.BeforeDeleteHook:
		gameAbilityBeforeDeleteHooks = append(gameAbilityBeforeDeleteHooks, gameAbilityHook)
	case boil.AfterDeleteHook:
		gameAbilityAfterDeleteHooks = append(gameAbilityAfterDeleteHooks, gameAbilityHook)
	case boil.BeforeUpsertHook:
		gameAbilityBeforeUpsertHooks = append(gameAbilityBeforeUpsertHooks, gameAbilityHook)
	case boil.AfterUpsertHook:
		gameAbilityAfterUpsertHooks = append(gameAbilityAfterUpsertHooks, gameAbilityHook)
	}
}

// One returns a single gameAbility record from the query.
func (q gameAbilityQuery) One(exec boil.Executor) (*GameAbility, error) {
	o := &GameAbility{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for game_abilities")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all GameAbility records from the query.
func (q gameAbilityQuery) All(exec boil.Executor) (GameAbilitySlice, error) {
	var o []*GameAbility

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to GameAbility slice")
	}

	if len(gameAbilityAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all GameAbility records in the query.
func (q gameAbilityQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count game_abilities rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q gameAbilityQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if game_abilities exists")
	}

	return count > 0, nil
}

// BattleAbility pointed to by the foreign key.
func (o *GameAbility) BattleAbility(mods ...qm.QueryMod) battleAbilityQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.BattleAbilityID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := BattleAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"battle_abilities\"")

	return query
}

// Faction pointed to by the foreign key.
func (o *GameAbility) Faction(mods ...qm.QueryMod) factionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FactionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Factions(queryMods...)
	queries.SetFrom(query.Query, "\"factions\"")

	return query
}

// BattleAbilityTriggers retrieves all the battle_ability_trigger's BattleAbilityTriggers with an executor.
func (o *GameAbility) BattleAbilityTriggers(mods ...qm.QueryMod) battleAbilityTriggerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_ability_triggers\".\"game_ability_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_ability_triggers\".\"deleted_at\""),
	)

	query := BattleAbilityTriggers(queryMods...)
	queries.SetFrom(query.Query, "\"battle_ability_triggers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_ability_triggers\".*"})
	}

	return query
}

// BattleEventsGameAbilities retrieves all the battle_events_game_ability's BattleEventsGameAbilities with an executor.
func (o *GameAbility) BattleEventsGameAbilities(mods ...qm.QueryMod) battleEventsGameAbilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_events_game_ability\".\"game_ability_id\"=?", o.ID),
	)

	query := BattleEventsGameAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"battle_events_game_ability\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_events_game_ability\".*"})
	}

	return query
}

// MechAbilityTriggerLogsOlds retrieves all the mech_ability_trigger_logs_old's MechAbilityTriggerLogsOlds with an executor.
func (o *GameAbility) MechAbilityTriggerLogsOlds(mods ...qm.QueryMod) mechAbilityTriggerLogsOldQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mech_ability_trigger_logs_old\".\"game_ability_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"mech_ability_trigger_logs_old\".\"deleted_at\""),
	)

	query := MechAbilityTriggerLogsOlds(queryMods...)
	queries.SetFrom(query.Query, "\"mech_ability_trigger_logs_old\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mech_ability_trigger_logs_old\".*"})
	}

	return query
}

// PlayerBattleAbilities retrieves all the player_battle_ability's PlayerBattleAbilities with an executor.
func (o *GameAbility) PlayerBattleAbilities(mods ...qm.QueryMod) playerBattleAbilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_battle_abilities\".\"game_ability_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_battle_abilities\".\"deleted_at\""),
	)

	query := PlayerBattleAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"player_battle_abilities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_battle_abilities\".*"})
	}

	return query
}

// PlayerKillLogs retrieves all the player_kill_log's PlayerKillLogs with an executor.
func (o *GameAbility) PlayerKillLogs(mods ...qm.QueryMod) playerKillLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_kill_log\".\"game_ability_id\"=?", o.ID),
	)

	query := PlayerKillLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_kill_log\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_kill_log\".*"})
	}

	return query
}

// LoadBattleAbility allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameAbilityL) LoadBattleAbility(e boil.Executor, singular bool, maybeGameAbility interface{}, mods queries.Applicator) error {
	var slice []*GameAbility
	var object *GameAbility

	if singular {
		object = maybeGameAbility.(*GameAbility)
	} else {
		slice = *maybeGameAbility.(*[]*GameAbility)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &gameAbilityR{}
		}
		if !queries.IsNil(object.BattleAbilityID) {
			args = append(args, object.BattleAbilityID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameAbilityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BattleAbilityID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BattleAbilityID) {
				args = append(args, obj.BattleAbilityID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_abilities`),
		qm.WhereIn(`battle_abilities.id in ?`, args...),
		qmhelper.WhereIsNull(`battle_abilities.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BattleAbility")
	}

	var resultSlice []*BattleAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BattleAbility")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for battle_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_abilities")
	}

	if len(gameAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BattleAbility = foreign
		if foreign.R == nil {
			foreign.R = &battleAbilityR{}
		}
		foreign.R.GameAbilities = append(foreign.R.GameAbilities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BattleAbilityID, foreign.ID) {
				local.R.BattleAbility = foreign
				if foreign.R == nil {
					foreign.R = &battleAbilityR{}
				}
				foreign.R.GameAbilities = append(foreign.R.GameAbilities, local)
				break
			}
		}
	}

	return nil
}

// LoadFaction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameAbilityL) LoadFaction(e boil.Executor, singular bool, maybeGameAbility interface{}, mods queries.Applicator) error {
	var slice []*GameAbility
	var object *GameAbility

	if singular {
		object = maybeGameAbility.(*GameAbility)
	} else {
		slice = *maybeGameAbility.(*[]*GameAbility)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &gameAbilityR{}
		}
		args = append(args, object.FactionID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameAbilityR{}
			}

			for _, a := range args {
				if a == obj.FactionID {
					continue Outer
				}
			}

			args = append(args, obj.FactionID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`factions`),
		qm.WhereIn(`factions.id in ?`, args...),
		qmhelper.WhereIsNull(`factions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Faction")
	}

	var resultSlice []*Faction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Faction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factions")
	}

	if len(gameAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Faction = foreign
		if foreign.R == nil {
			foreign.R = &factionR{}
		}
		foreign.R.GameAbilities = append(foreign.R.GameAbilities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FactionID == foreign.ID {
				local.R.Faction = foreign
				if foreign.R == nil {
					foreign.R = &factionR{}
				}
				foreign.R.GameAbilities = append(foreign.R.GameAbilities, local)
				break
			}
		}
	}

	return nil
}

// LoadBattleAbilityTriggers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (gameAbilityL) LoadBattleAbilityTriggers(e boil.Executor, singular bool, maybeGameAbility interface{}, mods queries.Applicator) error {
	var slice []*GameAbility
	var object *GameAbility

	if singular {
		object = maybeGameAbility.(*GameAbility)
	} else {
		slice = *maybeGameAbility.(*[]*GameAbility)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &gameAbilityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameAbilityR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_ability_triggers`),
		qm.WhereIn(`battle_ability_triggers.game_ability_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_ability_triggers.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_ability_triggers")
	}

	var resultSlice []*BattleAbilityTrigger
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_ability_triggers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_ability_triggers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_ability_triggers")
	}

	if len(battleAbilityTriggerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleAbilityTriggers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleAbilityTriggerR{}
			}
			foreign.R.GameAbility = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.GameAbilityID {
				local.R.BattleAbilityTriggers = append(local.R.BattleAbilityTriggers, foreign)
				if foreign.R == nil {
					foreign.R = &battleAbilityTriggerR{}
				}
				foreign.R.GameAbility = local
				break
			}
		}
	}

	return nil
}

// LoadBattleEventsGameAbilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (gameAbilityL) LoadBattleEventsGameAbilities(e boil.Executor, singular bool, maybeGameAbility interface{}, mods queries.Applicator) error {
	var slice []*GameAbility
	var object *GameAbility

	if singular {
		object = maybeGameAbility.(*GameAbility)
	} else {
		slice = *maybeGameAbility.(*[]*GameAbility)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &gameAbilityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameAbilityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_events_game_ability`),
		qm.WhereIn(`battle_events_game_ability.game_ability_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_events_game_ability")
	}

	var resultSlice []*BattleEventsGameAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_events_game_ability")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_events_game_ability")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_events_game_ability")
	}

	if len(battleEventsGameAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleEventsGameAbilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleEventsGameAbilityR{}
			}
			foreign.R.GameAbility = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.GameAbilityID) {
				local.R.BattleEventsGameAbilities = append(local.R.BattleEventsGameAbilities, foreign)
				if foreign.R == nil {
					foreign.R = &battleEventsGameAbilityR{}
				}
				foreign.R.GameAbility = local
				break
			}
		}
	}

	return nil
}

// LoadMechAbilityTriggerLogsOlds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (gameAbilityL) LoadMechAbilityTriggerLogsOlds(e boil.Executor, singular bool, maybeGameAbility interface{}, mods queries.Applicator) error {
	var slice []*GameAbility
	var object *GameAbility

	if singular {
		object = maybeGameAbility.(*GameAbility)
	} else {
		slice = *maybeGameAbility.(*[]*GameAbility)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &gameAbilityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameAbilityR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mech_ability_trigger_logs_old`),
		qm.WhereIn(`mech_ability_trigger_logs_old.game_ability_id in ?`, args...),
		qmhelper.WhereIsNull(`mech_ability_trigger_logs_old.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mech_ability_trigger_logs_old")
	}

	var resultSlice []*MechAbilityTriggerLogsOld
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mech_ability_trigger_logs_old")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mech_ability_trigger_logs_old")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mech_ability_trigger_logs_old")
	}

	if len(mechAbilityTriggerLogsOldAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MechAbilityTriggerLogsOlds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mechAbilityTriggerLogsOldR{}
			}
			foreign.R.GameAbility = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.GameAbilityID {
				local.R.MechAbilityTriggerLogsOlds = append(local.R.MechAbilityTriggerLogsOlds, foreign)
				if foreign.R == nil {
					foreign.R = &mechAbilityTriggerLogsOldR{}
				}
				foreign.R.GameAbility = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerBattleAbilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (gameAbilityL) LoadPlayerBattleAbilities(e boil.Executor, singular bool, maybeGameAbility interface{}, mods queries.Applicator) error {
	var slice []*GameAbility
	var object *GameAbility

	if singular {
		object = maybeGameAbility.(*GameAbility)
	} else {
		slice = *maybeGameAbility.(*[]*GameAbility)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &gameAbilityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameAbilityR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_battle_abilities`),
		qm.WhereIn(`player_battle_abilities.game_ability_id in ?`, args...),
		qmhelper.WhereIsNull(`player_battle_abilities.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_battle_abilities")
	}

	var resultSlice []*PlayerBattleAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_battle_abilities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_battle_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_battle_abilities")
	}

	if len(playerBattleAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerBattleAbilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerBattleAbilityR{}
			}
			foreign.R.GameAbility = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.GameAbilityID {
				local.R.PlayerBattleAbilities = append(local.R.PlayerBattleAbilities, foreign)
				if foreign.R == nil {
					foreign.R = &playerBattleAbilityR{}
				}
				foreign.R.GameAbility = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerKillLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (gameAbilityL) LoadPlayerKillLogs(e boil.Executor, singular bool, maybeGameAbility interface{}, mods queries.Applicator) error {
	var slice []*GameAbility
	var object *GameAbility

	if singular {
		object = maybeGameAbility.(*GameAbility)
	} else {
		slice = *maybeGameAbility.(*[]*GameAbility)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &gameAbilityR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameAbilityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_kill_log`),
		qm.WhereIn(`player_kill_log.game_ability_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_kill_log")
	}

	var resultSlice []*PlayerKillLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_kill_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_kill_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_kill_log")
	}

	if len(playerKillLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerKillLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerKillLogR{}
			}
			foreign.R.GameAbility = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.GameAbilityID) {
				local.R.PlayerKillLogs = append(local.R.PlayerKillLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerKillLogR{}
				}
				foreign.R.GameAbility = local
				break
			}
		}
	}

	return nil
}

// SetBattleAbility of the gameAbility to the related item.
// Sets o.R.BattleAbility to related.
// Adds o to related.R.GameAbilities.
func (o *GameAbility) SetBattleAbility(exec boil.Executor, insert bool, related *BattleAbility) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_abilities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"battle_ability_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameAbilityPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BattleAbilityID, related.ID)
	if o.R == nil {
		o.R = &gameAbilityR{
			BattleAbility: related,
		}
	} else {
		o.R.BattleAbility = related
	}

	if related.R == nil {
		related.R = &battleAbilityR{
			GameAbilities: GameAbilitySlice{o},
		}
	} else {
		related.R.GameAbilities = append(related.R.GameAbilities, o)
	}

	return nil
}

// RemoveBattleAbility relationship.
// Sets o.R.BattleAbility to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *GameAbility) RemoveBattleAbility(exec boil.Executor, related *BattleAbility) error {
	var err error

	queries.SetScanner(&o.BattleAbilityID, nil)
	if _, err = o.Update(exec, boil.Whitelist("battle_ability_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BattleAbility = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.GameAbilities {
		if queries.Equal(o.BattleAbilityID, ri.BattleAbilityID) {
			continue
		}

		ln := len(related.R.GameAbilities)
		if ln > 1 && i < ln-1 {
			related.R.GameAbilities[i] = related.R.GameAbilities[ln-1]
		}
		related.R.GameAbilities = related.R.GameAbilities[:ln-1]
		break
	}
	return nil
}

// SetFaction of the gameAbility to the related item.
// Sets o.R.Faction to related.
// Adds o to related.R.GameAbilities.
func (o *GameAbility) SetFaction(exec boil.Executor, insert bool, related *Faction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_abilities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameAbilityPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FactionID = related.ID
	if o.R == nil {
		o.R = &gameAbilityR{
			Faction: related,
		}
	} else {
		o.R.Faction = related
	}

	if related.R == nil {
		related.R = &factionR{
			GameAbilities: GameAbilitySlice{o},
		}
	} else {
		related.R.GameAbilities = append(related.R.GameAbilities, o)
	}

	return nil
}

// AddBattleAbilityTriggers adds the given related objects to the existing relationships
// of the game_ability, optionally inserting them as new records.
// Appends related to o.R.BattleAbilityTriggers.
// Sets related.R.GameAbility appropriately.
func (o *GameAbility) AddBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.GameAbilityID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_ability_triggers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"game_ability_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleAbilityTriggerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.GameAbilityID = o.ID
		}
	}

	if o.R == nil {
		o.R = &gameAbilityR{
			BattleAbilityTriggers: related,
		}
	} else {
		o.R.BattleAbilityTriggers = append(o.R.BattleAbilityTriggers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleAbilityTriggerR{
				GameAbility: o,
			}
		} else {
			rel.R.GameAbility = o
		}
	}
	return nil
}

// AddBattleEventsGameAbilities adds the given related objects to the existing relationships
// of the game_ability, optionally inserting them as new records.
// Appends related to o.R.BattleEventsGameAbilities.
// Sets related.R.GameAbility appropriately.
func (o *GameAbility) AddBattleEventsGameAbilities(exec boil.Executor, insert bool, related ...*BattleEventsGameAbility) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.GameAbilityID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_events_game_ability\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"game_ability_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleEventsGameAbilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.GameAbilityID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &gameAbilityR{
			BattleEventsGameAbilities: related,
		}
	} else {
		o.R.BattleEventsGameAbilities = append(o.R.BattleEventsGameAbilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleEventsGameAbilityR{
				GameAbility: o,
			}
		} else {
			rel.R.GameAbility = o
		}
	}
	return nil
}

// SetBattleEventsGameAbilities removes all previously related items of the
// game_ability replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.GameAbility's BattleEventsGameAbilities accordingly.
// Replaces o.R.BattleEventsGameAbilities with related.
// Sets related.R.GameAbility's BattleEventsGameAbilities accordingly.
func (o *GameAbility) SetBattleEventsGameAbilities(exec boil.Executor, insert bool, related ...*BattleEventsGameAbility) error {
	query := "update \"battle_events_game_ability\" set \"game_ability_id\" = null where \"game_ability_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BattleEventsGameAbilities {
			queries.SetScanner(&rel.GameAbilityID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.GameAbility = nil
		}

		o.R.BattleEventsGameAbilities = nil
	}
	return o.AddBattleEventsGameAbilities(exec, insert, related...)
}

// RemoveBattleEventsGameAbilities relationships from objects passed in.
// Removes related items from R.BattleEventsGameAbilities (uses pointer comparison, removal does not keep order)
// Sets related.R.GameAbility.
func (o *GameAbility) RemoveBattleEventsGameAbilities(exec boil.Executor, related ...*BattleEventsGameAbility) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.GameAbilityID, nil)
		if rel.R != nil {
			rel.R.GameAbility = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("game_ability_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BattleEventsGameAbilities {
			if rel != ri {
				continue
			}

			ln := len(o.R.BattleEventsGameAbilities)
			if ln > 1 && i < ln-1 {
				o.R.BattleEventsGameAbilities[i] = o.R.BattleEventsGameAbilities[ln-1]
			}
			o.R.BattleEventsGameAbilities = o.R.BattleEventsGameAbilities[:ln-1]
			break
		}
	}

	return nil
}

// AddMechAbilityTriggerLogsOlds adds the given related objects to the existing relationships
// of the game_ability, optionally inserting them as new records.
// Appends related to o.R.MechAbilityTriggerLogsOlds.
// Sets related.R.GameAbility appropriately.
func (o *GameAbility) AddMechAbilityTriggerLogsOlds(exec boil.Executor, insert bool, related ...*MechAbilityTriggerLogsOld) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.GameAbilityID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mech_ability_trigger_logs_old\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"game_ability_id"}),
				strmangle.WhereClause("\"", "\"", 2, mechAbilityTriggerLogsOldPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.GameAbilityID = o.ID
		}
	}

	if o.R == nil {
		o.R = &gameAbilityR{
			MechAbilityTriggerLogsOlds: related,
		}
	} else {
		o.R.MechAbilityTriggerLogsOlds = append(o.R.MechAbilityTriggerLogsOlds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mechAbilityTriggerLogsOldR{
				GameAbility: o,
			}
		} else {
			rel.R.GameAbility = o
		}
	}
	return nil
}

// AddPlayerBattleAbilities adds the given related objects to the existing relationships
// of the game_ability, optionally inserting them as new records.
// Appends related to o.R.PlayerBattleAbilities.
// Sets related.R.GameAbility appropriately.
func (o *GameAbility) AddPlayerBattleAbilities(exec boil.Executor, insert bool, related ...*PlayerBattleAbility) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.GameAbilityID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_battle_abilities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"game_ability_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerBattleAbilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.GameAbilityID = o.ID
		}
	}

	if o.R == nil {
		o.R = &gameAbilityR{
			PlayerBattleAbilities: related,
		}
	} else {
		o.R.PlayerBattleAbilities = append(o.R.PlayerBattleAbilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerBattleAbilityR{
				GameAbility: o,
			}
		} else {
			rel.R.GameAbility = o
		}
	}
	return nil
}

// AddPlayerKillLogs adds the given related objects to the existing relationships
// of the game_ability, optionally inserting them as new records.
// Appends related to o.R.PlayerKillLogs.
// Sets related.R.GameAbility appropriately.
func (o *GameAbility) AddPlayerKillLogs(exec boil.Executor, insert bool, related ...*PlayerKillLog) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.GameAbilityID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_kill_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"game_ability_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerKillLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.GameAbilityID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &gameAbilityR{
			PlayerKillLogs: related,
		}
	} else {
		o.R.PlayerKillLogs = append(o.R.PlayerKillLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerKillLogR{
				GameAbility: o,
			}
		} else {
			rel.R.GameAbility = o
		}
	}
	return nil
}

// SetPlayerKillLogs removes all previously related items of the
// game_ability replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.GameAbility's PlayerKillLogs accordingly.
// Replaces o.R.PlayerKillLogs with related.
// Sets related.R.GameAbility's PlayerKillLogs accordingly.
func (o *GameAbility) SetPlayerKillLogs(exec boil.Executor, insert bool, related ...*PlayerKillLog) error {
	query := "update \"player_kill_log\" set \"game_ability_id\" = null where \"game_ability_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PlayerKillLogs {
			queries.SetScanner(&rel.GameAbilityID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.GameAbility = nil
		}

		o.R.PlayerKillLogs = nil
	}
	return o.AddPlayerKillLogs(exec, insert, related...)
}

// RemovePlayerKillLogs relationships from objects passed in.
// Removes related items from R.PlayerKillLogs (uses pointer comparison, removal does not keep order)
// Sets related.R.GameAbility.
func (o *GameAbility) RemovePlayerKillLogs(exec boil.Executor, related ...*PlayerKillLog) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.GameAbilityID, nil)
		if rel.R != nil {
			rel.R.GameAbility = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("game_ability_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PlayerKillLogs {
			if rel != ri {
				continue
			}

			ln := len(o.R.PlayerKillLogs)
			if ln > 1 && i < ln-1 {
				o.R.PlayerKillLogs[i] = o.R.PlayerKillLogs[ln-1]
			}
			o.R.PlayerKillLogs = o.R.PlayerKillLogs[:ln-1]
			break
		}
	}

	return nil
}

// GameAbilities retrieves all the records using an executor.
func GameAbilities(mods ...qm.QueryMod) gameAbilityQuery {
	mods = append(mods, qm.From("\"game_abilities\""), qmhelper.WhereIsNull("\"game_abilities\".\"deleted_at\""))
	return gameAbilityQuery{NewQuery(mods...)}
}

// FindGameAbility retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindGameAbility(exec boil.Executor, iD string, selectCols ...string) (*GameAbility, error) {
	gameAbilityObj := &GameAbility{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"game_abilities\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, gameAbilityObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from game_abilities")
	}

	if err = gameAbilityObj.doAfterSelectHooks(exec); err != nil {
		return gameAbilityObj, err
	}

	return gameAbilityObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *GameAbility) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no game_abilities provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(gameAbilityColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	gameAbilityInsertCacheMut.RLock()
	cache, cached := gameAbilityInsertCache[key]
	gameAbilityInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			gameAbilityAllColumns,
			gameAbilityColumnsWithDefault,
			gameAbilityColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(gameAbilityType, gameAbilityMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(gameAbilityType, gameAbilityMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"game_abilities\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"game_abilities\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into game_abilities")
	}

	if !cached {
		gameAbilityInsertCacheMut.Lock()
		gameAbilityInsertCache[key] = cache
		gameAbilityInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the GameAbility.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *GameAbility) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	gameAbilityUpdateCacheMut.RLock()
	cache, cached := gameAbilityUpdateCache[key]
	gameAbilityUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			gameAbilityAllColumns,
			gameAbilityPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update game_abilities, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"game_abilities\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, gameAbilityPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(gameAbilityType, gameAbilityMapping, append(wl, gameAbilityPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update game_abilities row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for game_abilities")
	}

	if !cached {
		gameAbilityUpdateCacheMut.Lock()
		gameAbilityUpdateCache[key] = cache
		gameAbilityUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q gameAbilityQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for game_abilities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for game_abilities")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o GameAbilitySlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gameAbilityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"game_abilities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, gameAbilityPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in gameAbility slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all gameAbility")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *GameAbility) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no game_abilities provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(gameAbilityColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	gameAbilityUpsertCacheMut.RLock()
	cache, cached := gameAbilityUpsertCache[key]
	gameAbilityUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			gameAbilityAllColumns,
			gameAbilityColumnsWithDefault,
			gameAbilityColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			gameAbilityAllColumns,
			gameAbilityPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert game_abilities, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(gameAbilityPrimaryKeyColumns))
			copy(conflict, gameAbilityPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"game_abilities\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(gameAbilityType, gameAbilityMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(gameAbilityType, gameAbilityMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert game_abilities")
	}

	if !cached {
		gameAbilityUpsertCacheMut.Lock()
		gameAbilityUpsertCache[key] = cache
		gameAbilityUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single GameAbility record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *GameAbility) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no GameAbility provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), gameAbilityPrimaryKeyMapping)
		sql = "DELETE FROM \"game_abilities\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_abilities\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(gameAbilityType, gameAbilityMapping, append(wl, gameAbilityPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from game_abilities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for game_abilities")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q gameAbilityQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no gameAbilityQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from game_abilities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for game_abilities")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o GameAbilitySlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(gameAbilityBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gameAbilityPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"game_abilities\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, gameAbilityPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gameAbilityPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"game_abilities\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, gameAbilityPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from gameAbility slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for game_abilities")
	}

	if len(gameAbilityAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *GameAbility) Reload(exec boil.Executor) error {
	ret, err := FindGameAbility(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *GameAbilitySlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := GameAbilitySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gameAbilityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"game_abilities\".* FROM \"game_abilities\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, gameAbilityPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in GameAbilitySlice")
	}

	*o = slice

	return nil
}

// GameAbilityExists checks if the GameAbility row exists.
func GameAbilityExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"game_abilities\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if game_abilities exists")
	}

	return exists, nil
}
