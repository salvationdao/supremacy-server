// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/shopspring/decimal"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// ItemSale is an object representing the database table.
type ItemSale struct {
	ID                   string              `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	FactionID            string              `boiler:"faction_id" boil:"faction_id" json:"faction_id" toml:"faction_id" yaml:"faction_id"`
	CollectionItemID     string              `boiler:"collection_item_id" boil:"collection_item_id" json:"collection_item_id" toml:"collection_item_id" yaml:"collection_item_id"`
	ListingFeeTXID       string              `boiler:"listing_fee_tx_id" boil:"listing_fee_tx_id" json:"listing_fee_tx_id" toml:"listing_fee_tx_id" yaml:"listing_fee_tx_id"`
	OwnerID              string              `boiler:"owner_id" boil:"owner_id" json:"owner_id" toml:"owner_id" yaml:"owner_id"`
	Auction              bool                `boiler:"auction" boil:"auction" json:"auction" toml:"auction" yaml:"auction"`
	AuctionCurrentPrice  decimal.NullDecimal `boiler:"auction_current_price" boil:"auction_current_price" json:"auction_current_price,omitempty" toml:"auction_current_price" yaml:"auction_current_price,omitempty"`
	AuctionReservedPrice decimal.NullDecimal `boiler:"auction_reserved_price" boil:"auction_reserved_price" json:"auction_reserved_price,omitempty" toml:"auction_reserved_price" yaml:"auction_reserved_price,omitempty"`
	Buyout               bool                `boiler:"buyout" boil:"buyout" json:"buyout" toml:"buyout" yaml:"buyout"`
	BuyoutPrice          decimal.NullDecimal `boiler:"buyout_price" boil:"buyout_price" json:"buyout_price,omitempty" toml:"buyout_price" yaml:"buyout_price,omitempty"`
	DutchAuction         bool                `boiler:"dutch_auction" boil:"dutch_auction" json:"dutch_auction" toml:"dutch_auction" yaml:"dutch_auction"`
	DutchAuctionDropRate decimal.NullDecimal `boiler:"dutch_auction_drop_rate" boil:"dutch_auction_drop_rate" json:"dutch_auction_drop_rate,omitempty" toml:"dutch_auction_drop_rate" yaml:"dutch_auction_drop_rate,omitempty"`
	EndAt                time.Time           `boiler:"end_at" boil:"end_at" json:"end_at" toml:"end_at" yaml:"end_at"`
	SoldAt               null.Time           `boiler:"sold_at" boil:"sold_at" json:"sold_at,omitempty" toml:"sold_at" yaml:"sold_at,omitempty"`
	SoldFor              decimal.NullDecimal `boiler:"sold_for" boil:"sold_for" json:"sold_for,omitempty" toml:"sold_for" yaml:"sold_for,omitempty"`
	SoldBy               null.String         `boiler:"sold_by" boil:"sold_by" json:"sold_by,omitempty" toml:"sold_by" yaml:"sold_by,omitempty"`
	SoldTXID             null.String         `boiler:"sold_tx_id" boil:"sold_tx_id" json:"sold_tx_id,omitempty" toml:"sold_tx_id" yaml:"sold_tx_id,omitempty"`
	SoldFeeTXID          null.String         `boiler:"sold_fee_tx_id" boil:"sold_fee_tx_id" json:"sold_fee_tx_id,omitempty" toml:"sold_fee_tx_id" yaml:"sold_fee_tx_id,omitempty"`
	DeletedAt            null.Time           `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	UpdatedAt            time.Time           `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt            time.Time           `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`

	R *itemSaleR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L itemSaleL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ItemSaleColumns = struct {
	ID                   string
	FactionID            string
	CollectionItemID     string
	ListingFeeTXID       string
	OwnerID              string
	Auction              string
	AuctionCurrentPrice  string
	AuctionReservedPrice string
	Buyout               string
	BuyoutPrice          string
	DutchAuction         string
	DutchAuctionDropRate string
	EndAt                string
	SoldAt               string
	SoldFor              string
	SoldBy               string
	SoldTXID             string
	SoldFeeTXID          string
	DeletedAt            string
	UpdatedAt            string
	CreatedAt            string
}{
	ID:                   "id",
	FactionID:            "faction_id",
	CollectionItemID:     "collection_item_id",
	ListingFeeTXID:       "listing_fee_tx_id",
	OwnerID:              "owner_id",
	Auction:              "auction",
	AuctionCurrentPrice:  "auction_current_price",
	AuctionReservedPrice: "auction_reserved_price",
	Buyout:               "buyout",
	BuyoutPrice:          "buyout_price",
	DutchAuction:         "dutch_auction",
	DutchAuctionDropRate: "dutch_auction_drop_rate",
	EndAt:                "end_at",
	SoldAt:               "sold_at",
	SoldFor:              "sold_for",
	SoldBy:               "sold_by",
	SoldTXID:             "sold_tx_id",
	SoldFeeTXID:          "sold_fee_tx_id",
	DeletedAt:            "deleted_at",
	UpdatedAt:            "updated_at",
	CreatedAt:            "created_at",
}

var ItemSaleTableColumns = struct {
	ID                   string
	FactionID            string
	CollectionItemID     string
	ListingFeeTXID       string
	OwnerID              string
	Auction              string
	AuctionCurrentPrice  string
	AuctionReservedPrice string
	Buyout               string
	BuyoutPrice          string
	DutchAuction         string
	DutchAuctionDropRate string
	EndAt                string
	SoldAt               string
	SoldFor              string
	SoldBy               string
	SoldTXID             string
	SoldFeeTXID          string
	DeletedAt            string
	UpdatedAt            string
	CreatedAt            string
}{
	ID:                   "item_sales.id",
	FactionID:            "item_sales.faction_id",
	CollectionItemID:     "item_sales.collection_item_id",
	ListingFeeTXID:       "item_sales.listing_fee_tx_id",
	OwnerID:              "item_sales.owner_id",
	Auction:              "item_sales.auction",
	AuctionCurrentPrice:  "item_sales.auction_current_price",
	AuctionReservedPrice: "item_sales.auction_reserved_price",
	Buyout:               "item_sales.buyout",
	BuyoutPrice:          "item_sales.buyout_price",
	DutchAuction:         "item_sales.dutch_auction",
	DutchAuctionDropRate: "item_sales.dutch_auction_drop_rate",
	EndAt:                "item_sales.end_at",
	SoldAt:               "item_sales.sold_at",
	SoldFor:              "item_sales.sold_for",
	SoldBy:               "item_sales.sold_by",
	SoldTXID:             "item_sales.sold_tx_id",
	SoldFeeTXID:          "item_sales.sold_fee_tx_id",
	DeletedAt:            "item_sales.deleted_at",
	UpdatedAt:            "item_sales.updated_at",
	CreatedAt:            "item_sales.created_at",
}

// Generated where

var ItemSaleWhere = struct {
	ID                   whereHelperstring
	FactionID            whereHelperstring
	CollectionItemID     whereHelperstring
	ListingFeeTXID       whereHelperstring
	OwnerID              whereHelperstring
	Auction              whereHelperbool
	AuctionCurrentPrice  whereHelperdecimal_NullDecimal
	AuctionReservedPrice whereHelperdecimal_NullDecimal
	Buyout               whereHelperbool
	BuyoutPrice          whereHelperdecimal_NullDecimal
	DutchAuction         whereHelperbool
	DutchAuctionDropRate whereHelperdecimal_NullDecimal
	EndAt                whereHelpertime_Time
	SoldAt               whereHelpernull_Time
	SoldFor              whereHelperdecimal_NullDecimal
	SoldBy               whereHelpernull_String
	SoldTXID             whereHelpernull_String
	SoldFeeTXID          whereHelpernull_String
	DeletedAt            whereHelpernull_Time
	UpdatedAt            whereHelpertime_Time
	CreatedAt            whereHelpertime_Time
}{
	ID:                   whereHelperstring{field: "\"item_sales\".\"id\""},
	FactionID:            whereHelperstring{field: "\"item_sales\".\"faction_id\""},
	CollectionItemID:     whereHelperstring{field: "\"item_sales\".\"collection_item_id\""},
	ListingFeeTXID:       whereHelperstring{field: "\"item_sales\".\"listing_fee_tx_id\""},
	OwnerID:              whereHelperstring{field: "\"item_sales\".\"owner_id\""},
	Auction:              whereHelperbool{field: "\"item_sales\".\"auction\""},
	AuctionCurrentPrice:  whereHelperdecimal_NullDecimal{field: "\"item_sales\".\"auction_current_price\""},
	AuctionReservedPrice: whereHelperdecimal_NullDecimal{field: "\"item_sales\".\"auction_reserved_price\""},
	Buyout:               whereHelperbool{field: "\"item_sales\".\"buyout\""},
	BuyoutPrice:          whereHelperdecimal_NullDecimal{field: "\"item_sales\".\"buyout_price\""},
	DutchAuction:         whereHelperbool{field: "\"item_sales\".\"dutch_auction\""},
	DutchAuctionDropRate: whereHelperdecimal_NullDecimal{field: "\"item_sales\".\"dutch_auction_drop_rate\""},
	EndAt:                whereHelpertime_Time{field: "\"item_sales\".\"end_at\""},
	SoldAt:               whereHelpernull_Time{field: "\"item_sales\".\"sold_at\""},
	SoldFor:              whereHelperdecimal_NullDecimal{field: "\"item_sales\".\"sold_for\""},
	SoldBy:               whereHelpernull_String{field: "\"item_sales\".\"sold_by\""},
	SoldTXID:             whereHelpernull_String{field: "\"item_sales\".\"sold_tx_id\""},
	SoldFeeTXID:          whereHelpernull_String{field: "\"item_sales\".\"sold_fee_tx_id\""},
	DeletedAt:            whereHelpernull_Time{field: "\"item_sales\".\"deleted_at\""},
	UpdatedAt:            whereHelpertime_Time{field: "\"item_sales\".\"updated_at\""},
	CreatedAt:            whereHelpertime_Time{field: "\"item_sales\".\"created_at\""},
}

// ItemSaleRels is where relationship names are stored.
var ItemSaleRels = struct {
	CollectionItem        string
	Faction               string
	Owner                 string
	SoldByPlayer          string
	ItemSalesBidHistories string
}{
	CollectionItem:        "CollectionItem",
	Faction:               "Faction",
	Owner:                 "Owner",
	SoldByPlayer:          "SoldByPlayer",
	ItemSalesBidHistories: "ItemSalesBidHistories",
}

// itemSaleR is where relationships are stored.
type itemSaleR struct {
	CollectionItem        *CollectionItem          `boiler:"CollectionItem" boil:"CollectionItem" json:"CollectionItem" toml:"CollectionItem" yaml:"CollectionItem"`
	Faction               *Faction                 `boiler:"Faction" boil:"Faction" json:"Faction" toml:"Faction" yaml:"Faction"`
	Owner                 *Player                  `boiler:"Owner" boil:"Owner" json:"Owner" toml:"Owner" yaml:"Owner"`
	SoldByPlayer          *Player                  `boiler:"SoldByPlayer" boil:"SoldByPlayer" json:"SoldByPlayer" toml:"SoldByPlayer" yaml:"SoldByPlayer"`
	ItemSalesBidHistories ItemSalesBidHistorySlice `boiler:"ItemSalesBidHistories" boil:"ItemSalesBidHistories" json:"ItemSalesBidHistories" toml:"ItemSalesBidHistories" yaml:"ItemSalesBidHistories"`
}

// NewStruct creates a new relationship struct
func (*itemSaleR) NewStruct() *itemSaleR {
	return &itemSaleR{}
}

// itemSaleL is where Load methods for each relationship are stored.
type itemSaleL struct{}

var (
	itemSaleAllColumns            = []string{"id", "faction_id", "collection_item_id", "listing_fee_tx_id", "owner_id", "auction", "auction_current_price", "auction_reserved_price", "buyout", "buyout_price", "dutch_auction", "dutch_auction_drop_rate", "end_at", "sold_at", "sold_for", "sold_by", "sold_tx_id", "sold_fee_tx_id", "deleted_at", "updated_at", "created_at"}
	itemSaleColumnsWithoutDefault = []string{"faction_id", "collection_item_id", "listing_fee_tx_id", "owner_id", "end_at"}
	itemSaleColumnsWithDefault    = []string{"id", "auction", "auction_current_price", "auction_reserved_price", "buyout", "buyout_price", "dutch_auction", "dutch_auction_drop_rate", "sold_at", "sold_for", "sold_by", "sold_tx_id", "sold_fee_tx_id", "deleted_at", "updated_at", "created_at"}
	itemSalePrimaryKeyColumns     = []string{"id"}
	itemSaleGeneratedColumns      = []string{}
)

type (
	// ItemSaleSlice is an alias for a slice of pointers to ItemSale.
	// This should almost always be used instead of []ItemSale.
	ItemSaleSlice []*ItemSale
	// ItemSaleHook is the signature for custom ItemSale hook methods
	ItemSaleHook func(boil.Executor, *ItemSale) error

	itemSaleQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	itemSaleType                 = reflect.TypeOf(&ItemSale{})
	itemSaleMapping              = queries.MakeStructMapping(itemSaleType)
	itemSalePrimaryKeyMapping, _ = queries.BindMapping(itemSaleType, itemSaleMapping, itemSalePrimaryKeyColumns)
	itemSaleInsertCacheMut       sync.RWMutex
	itemSaleInsertCache          = make(map[string]insertCache)
	itemSaleUpdateCacheMut       sync.RWMutex
	itemSaleUpdateCache          = make(map[string]updateCache)
	itemSaleUpsertCacheMut       sync.RWMutex
	itemSaleUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var itemSaleAfterSelectHooks []ItemSaleHook

var itemSaleBeforeInsertHooks []ItemSaleHook
var itemSaleAfterInsertHooks []ItemSaleHook

var itemSaleBeforeUpdateHooks []ItemSaleHook
var itemSaleAfterUpdateHooks []ItemSaleHook

var itemSaleBeforeDeleteHooks []ItemSaleHook
var itemSaleAfterDeleteHooks []ItemSaleHook

var itemSaleBeforeUpsertHooks []ItemSaleHook
var itemSaleAfterUpsertHooks []ItemSaleHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *ItemSale) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *ItemSale) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *ItemSale) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *ItemSale) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *ItemSale) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *ItemSale) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *ItemSale) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *ItemSale) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *ItemSale) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range itemSaleAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddItemSaleHook registers your hook function for all future operations.
func AddItemSaleHook(hookPoint boil.HookPoint, itemSaleHook ItemSaleHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		itemSaleAfterSelectHooks = append(itemSaleAfterSelectHooks, itemSaleHook)
	case boil.BeforeInsertHook:
		itemSaleBeforeInsertHooks = append(itemSaleBeforeInsertHooks, itemSaleHook)
	case boil.AfterInsertHook:
		itemSaleAfterInsertHooks = append(itemSaleAfterInsertHooks, itemSaleHook)
	case boil.BeforeUpdateHook:
		itemSaleBeforeUpdateHooks = append(itemSaleBeforeUpdateHooks, itemSaleHook)
	case boil.AfterUpdateHook:
		itemSaleAfterUpdateHooks = append(itemSaleAfterUpdateHooks, itemSaleHook)
	case boil.BeforeDeleteHook:
		itemSaleBeforeDeleteHooks = append(itemSaleBeforeDeleteHooks, itemSaleHook)
	case boil.AfterDeleteHook:
		itemSaleAfterDeleteHooks = append(itemSaleAfterDeleteHooks, itemSaleHook)
	case boil.BeforeUpsertHook:
		itemSaleBeforeUpsertHooks = append(itemSaleBeforeUpsertHooks, itemSaleHook)
	case boil.AfterUpsertHook:
		itemSaleAfterUpsertHooks = append(itemSaleAfterUpsertHooks, itemSaleHook)
	}
}

// One returns a single itemSale record from the query.
func (q itemSaleQuery) One(exec boil.Executor) (*ItemSale, error) {
	o := &ItemSale{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for item_sales")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all ItemSale records from the query.
func (q itemSaleQuery) All(exec boil.Executor) (ItemSaleSlice, error) {
	var o []*ItemSale

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to ItemSale slice")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all ItemSale records in the query.
func (q itemSaleQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count item_sales rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q itemSaleQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if item_sales exists")
	}

	return count > 0, nil
}

// CollectionItem pointed to by the foreign key.
func (o *ItemSale) CollectionItem(mods ...qm.QueryMod) collectionItemQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CollectionItemID),
	}

	queryMods = append(queryMods, mods...)

	query := CollectionItems(queryMods...)
	queries.SetFrom(query.Query, "\"collection_items\"")

	return query
}

// Faction pointed to by the foreign key.
func (o *ItemSale) Faction(mods ...qm.QueryMod) factionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FactionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Factions(queryMods...)
	queries.SetFrom(query.Query, "\"factions\"")

	return query
}

// Owner pointed to by the foreign key.
func (o *ItemSale) Owner(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OwnerID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Players(queryMods...)
	queries.SetFrom(query.Query, "\"players\"")

	return query
}

// SoldByPlayer pointed to by the foreign key.
func (o *ItemSale) SoldByPlayer(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SoldBy),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Players(queryMods...)
	queries.SetFrom(query.Query, "\"players\"")

	return query
}

// ItemSalesBidHistories retrieves all the item_sales_bid_history's ItemSalesBidHistories with an executor.
func (o *ItemSale) ItemSalesBidHistories(mods ...qm.QueryMod) itemSalesBidHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_sales_bid_history\".\"item_sale_id\"=?", o.ID),
	)

	query := ItemSalesBidHistories(queryMods...)
	queries.SetFrom(query.Query, "\"item_sales_bid_history\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_sales_bid_history\".*"})
	}

	return query
}

// LoadCollectionItem allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (itemSaleL) LoadCollectionItem(e boil.Executor, singular bool, maybeItemSale interface{}, mods queries.Applicator) error {
	var slice []*ItemSale
	var object *ItemSale

	if singular {
		object = maybeItemSale.(*ItemSale)
	} else {
		slice = *maybeItemSale.(*[]*ItemSale)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &itemSaleR{}
		}
		args = append(args, object.CollectionItemID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemSaleR{}
			}

			for _, a := range args {
				if a == obj.CollectionItemID {
					continue Outer
				}
			}

			args = append(args, obj.CollectionItemID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`collection_items`),
		qm.WhereIn(`collection_items.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CollectionItem")
	}

	var resultSlice []*CollectionItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CollectionItem")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for collection_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for collection_items")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CollectionItem = foreign
		if foreign.R == nil {
			foreign.R = &collectionItemR{}
		}
		foreign.R.ItemSales = append(foreign.R.ItemSales, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CollectionItemID == foreign.ID {
				local.R.CollectionItem = foreign
				if foreign.R == nil {
					foreign.R = &collectionItemR{}
				}
				foreign.R.ItemSales = append(foreign.R.ItemSales, local)
				break
			}
		}
	}

	return nil
}

// LoadFaction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (itemSaleL) LoadFaction(e boil.Executor, singular bool, maybeItemSale interface{}, mods queries.Applicator) error {
	var slice []*ItemSale
	var object *ItemSale

	if singular {
		object = maybeItemSale.(*ItemSale)
	} else {
		slice = *maybeItemSale.(*[]*ItemSale)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &itemSaleR{}
		}
		args = append(args, object.FactionID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemSaleR{}
			}

			for _, a := range args {
				if a == obj.FactionID {
					continue Outer
				}
			}

			args = append(args, obj.FactionID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`factions`),
		qm.WhereIn(`factions.id in ?`, args...),
		qmhelper.WhereIsNull(`factions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Faction")
	}

	var resultSlice []*Faction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Faction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factions")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Faction = foreign
		if foreign.R == nil {
			foreign.R = &factionR{}
		}
		foreign.R.ItemSales = append(foreign.R.ItemSales, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FactionID == foreign.ID {
				local.R.Faction = foreign
				if foreign.R == nil {
					foreign.R = &factionR{}
				}
				foreign.R.ItemSales = append(foreign.R.ItemSales, local)
				break
			}
		}
	}

	return nil
}

// LoadOwner allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (itemSaleL) LoadOwner(e boil.Executor, singular bool, maybeItemSale interface{}, mods queries.Applicator) error {
	var slice []*ItemSale
	var object *ItemSale

	if singular {
		object = maybeItemSale.(*ItemSale)
	} else {
		slice = *maybeItemSale.(*[]*ItemSale)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &itemSaleR{}
		}
		args = append(args, object.OwnerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemSaleR{}
			}

			for _, a := range args {
				if a == obj.OwnerID {
					continue Outer
				}
			}

			args = append(args, obj.OwnerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.id in ?`, args...),
		qmhelper.WhereIsNull(`players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Owner = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.OwnerItemSales = append(foreign.R.OwnerItemSales, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OwnerID == foreign.ID {
				local.R.Owner = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.OwnerItemSales = append(foreign.R.OwnerItemSales, local)
				break
			}
		}
	}

	return nil
}

// LoadSoldByPlayer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (itemSaleL) LoadSoldByPlayer(e boil.Executor, singular bool, maybeItemSale interface{}, mods queries.Applicator) error {
	var slice []*ItemSale
	var object *ItemSale

	if singular {
		object = maybeItemSale.(*ItemSale)
	} else {
		slice = *maybeItemSale.(*[]*ItemSale)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &itemSaleR{}
		}
		if !queries.IsNil(object.SoldBy) {
			args = append(args, object.SoldBy)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemSaleR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SoldBy) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SoldBy) {
				args = append(args, obj.SoldBy)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.id in ?`, args...),
		qmhelper.WhereIsNull(`players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SoldByPlayer = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.SoldByItemSales = append(foreign.R.SoldByItemSales, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SoldBy, foreign.ID) {
				local.R.SoldByPlayer = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.SoldByItemSales = append(foreign.R.SoldByItemSales, local)
				break
			}
		}
	}

	return nil
}

// LoadItemSalesBidHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (itemSaleL) LoadItemSalesBidHistories(e boil.Executor, singular bool, maybeItemSale interface{}, mods queries.Applicator) error {
	var slice []*ItemSale
	var object *ItemSale

	if singular {
		object = maybeItemSale.(*ItemSale)
	} else {
		slice = *maybeItemSale.(*[]*ItemSale)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &itemSaleR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &itemSaleR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_sales_bid_history`),
		qm.WhereIn(`item_sales_bid_history.item_sale_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_sales_bid_history")
	}

	var resultSlice []*ItemSalesBidHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_sales_bid_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_sales_bid_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_sales_bid_history")
	}

	if len(itemSalesBidHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ItemSalesBidHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemSalesBidHistoryR{}
			}
			foreign.R.ItemSale = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ItemSaleID {
				local.R.ItemSalesBidHistories = append(local.R.ItemSalesBidHistories, foreign)
				if foreign.R == nil {
					foreign.R = &itemSalesBidHistoryR{}
				}
				foreign.R.ItemSale = local
				break
			}
		}
	}

	return nil
}

// SetCollectionItem of the itemSale to the related item.
// Sets o.R.CollectionItem to related.
// Adds o to related.R.ItemSales.
func (o *ItemSale) SetCollectionItem(exec boil.Executor, insert bool, related *CollectionItem) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"item_sales\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"collection_item_id"}),
		strmangle.WhereClause("\"", "\"", 2, itemSalePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CollectionItemID = related.ID
	if o.R == nil {
		o.R = &itemSaleR{
			CollectionItem: related,
		}
	} else {
		o.R.CollectionItem = related
	}

	if related.R == nil {
		related.R = &collectionItemR{
			ItemSales: ItemSaleSlice{o},
		}
	} else {
		related.R.ItemSales = append(related.R.ItemSales, o)
	}

	return nil
}

// SetFaction of the itemSale to the related item.
// Sets o.R.Faction to related.
// Adds o to related.R.ItemSales.
func (o *ItemSale) SetFaction(exec boil.Executor, insert bool, related *Faction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"item_sales\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
		strmangle.WhereClause("\"", "\"", 2, itemSalePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FactionID = related.ID
	if o.R == nil {
		o.R = &itemSaleR{
			Faction: related,
		}
	} else {
		o.R.Faction = related
	}

	if related.R == nil {
		related.R = &factionR{
			ItemSales: ItemSaleSlice{o},
		}
	} else {
		related.R.ItemSales = append(related.R.ItemSales, o)
	}

	return nil
}

// SetOwner of the itemSale to the related item.
// Sets o.R.Owner to related.
// Adds o to related.R.OwnerItemSales.
func (o *ItemSale) SetOwner(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"item_sales\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
		strmangle.WhereClause("\"", "\"", 2, itemSalePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OwnerID = related.ID
	if o.R == nil {
		o.R = &itemSaleR{
			Owner: related,
		}
	} else {
		o.R.Owner = related
	}

	if related.R == nil {
		related.R = &playerR{
			OwnerItemSales: ItemSaleSlice{o},
		}
	} else {
		related.R.OwnerItemSales = append(related.R.OwnerItemSales, o)
	}

	return nil
}

// SetSoldByPlayer of the itemSale to the related item.
// Sets o.R.SoldByPlayer to related.
// Adds o to related.R.SoldByItemSales.
func (o *ItemSale) SetSoldByPlayer(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"item_sales\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"sold_by"}),
		strmangle.WhereClause("\"", "\"", 2, itemSalePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SoldBy, related.ID)
	if o.R == nil {
		o.R = &itemSaleR{
			SoldByPlayer: related,
		}
	} else {
		o.R.SoldByPlayer = related
	}

	if related.R == nil {
		related.R = &playerR{
			SoldByItemSales: ItemSaleSlice{o},
		}
	} else {
		related.R.SoldByItemSales = append(related.R.SoldByItemSales, o)
	}

	return nil
}

// RemoveSoldByPlayer relationship.
// Sets o.R.SoldByPlayer to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ItemSale) RemoveSoldByPlayer(exec boil.Executor, related *Player) error {
	var err error

	queries.SetScanner(&o.SoldBy, nil)
	if _, err = o.Update(exec, boil.Whitelist("sold_by")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SoldByPlayer = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SoldByItemSales {
		if queries.Equal(o.SoldBy, ri.SoldBy) {
			continue
		}

		ln := len(related.R.SoldByItemSales)
		if ln > 1 && i < ln-1 {
			related.R.SoldByItemSales[i] = related.R.SoldByItemSales[ln-1]
		}
		related.R.SoldByItemSales = related.R.SoldByItemSales[:ln-1]
		break
	}
	return nil
}

// AddItemSalesBidHistories adds the given related objects to the existing relationships
// of the item_sale, optionally inserting them as new records.
// Appends related to o.R.ItemSalesBidHistories.
// Sets related.R.ItemSale appropriately.
func (o *ItemSale) AddItemSalesBidHistories(exec boil.Executor, insert bool, related ...*ItemSalesBidHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ItemSaleID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_sales_bid_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"item_sale_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemSalesBidHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ItemSaleID, rel.BidderID, rel.BidAt}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ItemSaleID = o.ID
		}
	}

	if o.R == nil {
		o.R = &itemSaleR{
			ItemSalesBidHistories: related,
		}
	} else {
		o.R.ItemSalesBidHistories = append(o.R.ItemSalesBidHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemSalesBidHistoryR{
				ItemSale: o,
			}
		} else {
			rel.R.ItemSale = o
		}
	}
	return nil
}

// ItemSales retrieves all the records using an executor.
func ItemSales(mods ...qm.QueryMod) itemSaleQuery {
	mods = append(mods, qm.From("\"item_sales\""), qmhelper.WhereIsNull("\"item_sales\".\"deleted_at\""))
	return itemSaleQuery{NewQuery(mods...)}
}

// FindItemSale retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindItemSale(exec boil.Executor, iD string, selectCols ...string) (*ItemSale, error) {
	itemSaleObj := &ItemSale{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"item_sales\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, itemSaleObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from item_sales")
	}

	if err = itemSaleObj.doAfterSelectHooks(exec); err != nil {
		return itemSaleObj, err
	}

	return itemSaleObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *ItemSale) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no item_sales provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(itemSaleColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	itemSaleInsertCacheMut.RLock()
	cache, cached := itemSaleInsertCache[key]
	itemSaleInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			itemSaleAllColumns,
			itemSaleColumnsWithDefault,
			itemSaleColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(itemSaleType, itemSaleMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(itemSaleType, itemSaleMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"item_sales\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"item_sales\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into item_sales")
	}

	if !cached {
		itemSaleInsertCacheMut.Lock()
		itemSaleInsertCache[key] = cache
		itemSaleInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the ItemSale.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *ItemSale) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	itemSaleUpdateCacheMut.RLock()
	cache, cached := itemSaleUpdateCache[key]
	itemSaleUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			itemSaleAllColumns,
			itemSalePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update item_sales, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"item_sales\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, itemSalePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(itemSaleType, itemSaleMapping, append(wl, itemSalePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update item_sales row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for item_sales")
	}

	if !cached {
		itemSaleUpdateCacheMut.Lock()
		itemSaleUpdateCache[key] = cache
		itemSaleUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q itemSaleQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for item_sales")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for item_sales")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ItemSaleSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemSalePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"item_sales\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, itemSalePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in itemSale slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all itemSale")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *ItemSale) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no item_sales provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(itemSaleColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	itemSaleUpsertCacheMut.RLock()
	cache, cached := itemSaleUpsertCache[key]
	itemSaleUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			itemSaleAllColumns,
			itemSaleColumnsWithDefault,
			itemSaleColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			itemSaleAllColumns,
			itemSalePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert item_sales, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(itemSalePrimaryKeyColumns))
			copy(conflict, itemSalePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"item_sales\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(itemSaleType, itemSaleMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(itemSaleType, itemSaleMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert item_sales")
	}

	if !cached {
		itemSaleUpsertCacheMut.Lock()
		itemSaleUpsertCache[key] = cache
		itemSaleUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single ItemSale record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *ItemSale) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no ItemSale provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), itemSalePrimaryKeyMapping)
		sql = "DELETE FROM \"item_sales\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"item_sales\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(itemSaleType, itemSaleMapping, append(wl, itemSalePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from item_sales")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for item_sales")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q itemSaleQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no itemSaleQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from item_sales")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for item_sales")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ItemSaleSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(itemSaleBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemSalePrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"item_sales\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, itemSalePrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemSalePrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"item_sales\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, itemSalePrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from itemSale slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for item_sales")
	}

	if len(itemSaleAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *ItemSale) Reload(exec boil.Executor) error {
	ret, err := FindItemSale(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ItemSaleSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ItemSaleSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), itemSalePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"item_sales\".* FROM \"item_sales\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, itemSalePrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in ItemSaleSlice")
	}

	*o = slice

	return nil
}

// ItemSaleExists checks if the ItemSale row exists.
func ItemSaleExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"item_sales\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if item_sales exists")
	}

	return exists, nil
}
