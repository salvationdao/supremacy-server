// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// FiatProductItemBlueprint is an object representing the database table.
type FiatProductItemBlueprint struct {
	ID                       string      `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	ProductItemID            null.String `boiler:"product_item_id" boil:"product_item_id" json:"product_item_id,omitempty" toml:"product_item_id" yaml:"product_item_id,omitempty"`
	MechBlueprintID          null.String `boiler:"mech_blueprint_id" boil:"mech_blueprint_id" json:"mech_blueprint_id,omitempty" toml:"mech_blueprint_id" yaml:"mech_blueprint_id,omitempty"`
	MechAnimationBlueprintID null.String `boiler:"mech_animation_blueprint_id" boil:"mech_animation_blueprint_id" json:"mech_animation_blueprint_id,omitempty" toml:"mech_animation_blueprint_id" yaml:"mech_animation_blueprint_id,omitempty"`
	MechSkinBlueprintID      null.String `boiler:"mech_skin_blueprint_id" boil:"mech_skin_blueprint_id" json:"mech_skin_blueprint_id,omitempty" toml:"mech_skin_blueprint_id" yaml:"mech_skin_blueprint_id,omitempty"`
	UtilityBlueprintID       null.String `boiler:"utility_blueprint_id" boil:"utility_blueprint_id" json:"utility_blueprint_id,omitempty" toml:"utility_blueprint_id" yaml:"utility_blueprint_id,omitempty"`
	WeaponBlueprintID        null.String `boiler:"weapon_blueprint_id" boil:"weapon_blueprint_id" json:"weapon_blueprint_id,omitempty" toml:"weapon_blueprint_id" yaml:"weapon_blueprint_id,omitempty"`
	WeaponSkinBlueprintID    null.String `boiler:"weapon_skin_blueprint_id" boil:"weapon_skin_blueprint_id" json:"weapon_skin_blueprint_id,omitempty" toml:"weapon_skin_blueprint_id" yaml:"weapon_skin_blueprint_id,omitempty"`
	AmmoBlueprintID          null.String `boiler:"ammo_blueprint_id" boil:"ammo_blueprint_id" json:"ammo_blueprint_id,omitempty" toml:"ammo_blueprint_id" yaml:"ammo_blueprint_id,omitempty"`
	PowerCoreBlueprintID     null.String `boiler:"power_core_blueprint_id" boil:"power_core_blueprint_id" json:"power_core_blueprint_id,omitempty" toml:"power_core_blueprint_id" yaml:"power_core_blueprint_id,omitempty"`
	PlayerAbilityBlueprintID null.String `boiler:"player_ability_blueprint_id" boil:"player_ability_blueprint_id" json:"player_ability_blueprint_id,omitempty" toml:"player_ability_blueprint_id" yaml:"player_ability_blueprint_id,omitempty"`

	R *fiatProductItemBlueprintR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L fiatProductItemBlueprintL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var FiatProductItemBlueprintColumns = struct {
	ID                       string
	ProductItemID            string
	MechBlueprintID          string
	MechAnimationBlueprintID string
	MechSkinBlueprintID      string
	UtilityBlueprintID       string
	WeaponBlueprintID        string
	WeaponSkinBlueprintID    string
	AmmoBlueprintID          string
	PowerCoreBlueprintID     string
	PlayerAbilityBlueprintID string
}{
	ID:                       "id",
	ProductItemID:            "product_item_id",
	MechBlueprintID:          "mech_blueprint_id",
	MechAnimationBlueprintID: "mech_animation_blueprint_id",
	MechSkinBlueprintID:      "mech_skin_blueprint_id",
	UtilityBlueprintID:       "utility_blueprint_id",
	WeaponBlueprintID:        "weapon_blueprint_id",
	WeaponSkinBlueprintID:    "weapon_skin_blueprint_id",
	AmmoBlueprintID:          "ammo_blueprint_id",
	PowerCoreBlueprintID:     "power_core_blueprint_id",
	PlayerAbilityBlueprintID: "player_ability_blueprint_id",
}

var FiatProductItemBlueprintTableColumns = struct {
	ID                       string
	ProductItemID            string
	MechBlueprintID          string
	MechAnimationBlueprintID string
	MechSkinBlueprintID      string
	UtilityBlueprintID       string
	WeaponBlueprintID        string
	WeaponSkinBlueprintID    string
	AmmoBlueprintID          string
	PowerCoreBlueprintID     string
	PlayerAbilityBlueprintID string
}{
	ID:                       "fiat_product_item_blueprints.id",
	ProductItemID:            "fiat_product_item_blueprints.product_item_id",
	MechBlueprintID:          "fiat_product_item_blueprints.mech_blueprint_id",
	MechAnimationBlueprintID: "fiat_product_item_blueprints.mech_animation_blueprint_id",
	MechSkinBlueprintID:      "fiat_product_item_blueprints.mech_skin_blueprint_id",
	UtilityBlueprintID:       "fiat_product_item_blueprints.utility_blueprint_id",
	WeaponBlueprintID:        "fiat_product_item_blueprints.weapon_blueprint_id",
	WeaponSkinBlueprintID:    "fiat_product_item_blueprints.weapon_skin_blueprint_id",
	AmmoBlueprintID:          "fiat_product_item_blueprints.ammo_blueprint_id",
	PowerCoreBlueprintID:     "fiat_product_item_blueprints.power_core_blueprint_id",
	PlayerAbilityBlueprintID: "fiat_product_item_blueprints.player_ability_blueprint_id",
}

// Generated where

var FiatProductItemBlueprintWhere = struct {
	ID                       whereHelperstring
	ProductItemID            whereHelpernull_String
	MechBlueprintID          whereHelpernull_String
	MechAnimationBlueprintID whereHelpernull_String
	MechSkinBlueprintID      whereHelpernull_String
	UtilityBlueprintID       whereHelpernull_String
	WeaponBlueprintID        whereHelpernull_String
	WeaponSkinBlueprintID    whereHelpernull_String
	AmmoBlueprintID          whereHelpernull_String
	PowerCoreBlueprintID     whereHelpernull_String
	PlayerAbilityBlueprintID whereHelpernull_String
}{
	ID:                       whereHelperstring{field: "\"fiat_product_item_blueprints\".\"id\""},
	ProductItemID:            whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"product_item_id\""},
	MechBlueprintID:          whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"mech_blueprint_id\""},
	MechAnimationBlueprintID: whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"mech_animation_blueprint_id\""},
	MechSkinBlueprintID:      whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"mech_skin_blueprint_id\""},
	UtilityBlueprintID:       whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"utility_blueprint_id\""},
	WeaponBlueprintID:        whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"weapon_blueprint_id\""},
	WeaponSkinBlueprintID:    whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"weapon_skin_blueprint_id\""},
	AmmoBlueprintID:          whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"ammo_blueprint_id\""},
	PowerCoreBlueprintID:     whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"power_core_blueprint_id\""},
	PlayerAbilityBlueprintID: whereHelpernull_String{field: "\"fiat_product_item_blueprints\".\"player_ability_blueprint_id\""},
}

// FiatProductItemBlueprintRels is where relationship names are stored.
var FiatProductItemBlueprintRels = struct {
	AmmoBlueprint          string
	MechAnimationBlueprint string
	MechBlueprint          string
	MechSkinBlueprint      string
	PlayerAbilityBlueprint string
	PowerCoreBlueprint     string
	ProductItem            string
	UtilityBlueprint       string
	WeaponBlueprint        string
	WeaponSkinBlueprint    string
}{
	AmmoBlueprint:          "AmmoBlueprint",
	MechAnimationBlueprint: "MechAnimationBlueprint",
	MechBlueprint:          "MechBlueprint",
	MechSkinBlueprint:      "MechSkinBlueprint",
	PlayerAbilityBlueprint: "PlayerAbilityBlueprint",
	PowerCoreBlueprint:     "PowerCoreBlueprint",
	ProductItem:            "ProductItem",
	UtilityBlueprint:       "UtilityBlueprint",
	WeaponBlueprint:        "WeaponBlueprint",
	WeaponSkinBlueprint:    "WeaponSkinBlueprint",
}

// fiatProductItemBlueprintR is where relationships are stored.
type fiatProductItemBlueprintR struct {
	AmmoBlueprint          *BlueprintAmmo          `boiler:"AmmoBlueprint" boil:"AmmoBlueprint" json:"AmmoBlueprint" toml:"AmmoBlueprint" yaml:"AmmoBlueprint"`
	MechAnimationBlueprint *BlueprintMechAnimation `boiler:"MechAnimationBlueprint" boil:"MechAnimationBlueprint" json:"MechAnimationBlueprint" toml:"MechAnimationBlueprint" yaml:"MechAnimationBlueprint"`
	MechBlueprint          *BlueprintMech          `boiler:"MechBlueprint" boil:"MechBlueprint" json:"MechBlueprint" toml:"MechBlueprint" yaml:"MechBlueprint"`
	MechSkinBlueprint      *BlueprintMechSkin      `boiler:"MechSkinBlueprint" boil:"MechSkinBlueprint" json:"MechSkinBlueprint" toml:"MechSkinBlueprint" yaml:"MechSkinBlueprint"`
	PlayerAbilityBlueprint *BlueprintPlayerAbility `boiler:"PlayerAbilityBlueprint" boil:"PlayerAbilityBlueprint" json:"PlayerAbilityBlueprint" toml:"PlayerAbilityBlueprint" yaml:"PlayerAbilityBlueprint"`
	PowerCoreBlueprint     *BlueprintPowerCore     `boiler:"PowerCoreBlueprint" boil:"PowerCoreBlueprint" json:"PowerCoreBlueprint" toml:"PowerCoreBlueprint" yaml:"PowerCoreBlueprint"`
	ProductItem            *FiatProductItem        `boiler:"ProductItem" boil:"ProductItem" json:"ProductItem" toml:"ProductItem" yaml:"ProductItem"`
	UtilityBlueprint       *BlueprintUtility       `boiler:"UtilityBlueprint" boil:"UtilityBlueprint" json:"UtilityBlueprint" toml:"UtilityBlueprint" yaml:"UtilityBlueprint"`
	WeaponBlueprint        *BlueprintWeapon        `boiler:"WeaponBlueprint" boil:"WeaponBlueprint" json:"WeaponBlueprint" toml:"WeaponBlueprint" yaml:"WeaponBlueprint"`
	WeaponSkinBlueprint    *BlueprintWeaponSkin    `boiler:"WeaponSkinBlueprint" boil:"WeaponSkinBlueprint" json:"WeaponSkinBlueprint" toml:"WeaponSkinBlueprint" yaml:"WeaponSkinBlueprint"`
}

// NewStruct creates a new relationship struct
func (*fiatProductItemBlueprintR) NewStruct() *fiatProductItemBlueprintR {
	return &fiatProductItemBlueprintR{}
}

// fiatProductItemBlueprintL is where Load methods for each relationship are stored.
type fiatProductItemBlueprintL struct{}

var (
	fiatProductItemBlueprintAllColumns            = []string{"id", "product_item_id", "mech_blueprint_id", "mech_animation_blueprint_id", "mech_skin_blueprint_id", "utility_blueprint_id", "weapon_blueprint_id", "weapon_skin_blueprint_id", "ammo_blueprint_id", "power_core_blueprint_id", "player_ability_blueprint_id"}
	fiatProductItemBlueprintColumnsWithoutDefault = []string{}
	fiatProductItemBlueprintColumnsWithDefault    = []string{"id", "product_item_id", "mech_blueprint_id", "mech_animation_blueprint_id", "mech_skin_blueprint_id", "utility_blueprint_id", "weapon_blueprint_id", "weapon_skin_blueprint_id", "ammo_blueprint_id", "power_core_blueprint_id", "player_ability_blueprint_id"}
	fiatProductItemBlueprintPrimaryKeyColumns     = []string{"id"}
	fiatProductItemBlueprintGeneratedColumns      = []string{}
)

type (
	// FiatProductItemBlueprintSlice is an alias for a slice of pointers to FiatProductItemBlueprint.
	// This should almost always be used instead of []FiatProductItemBlueprint.
	FiatProductItemBlueprintSlice []*FiatProductItemBlueprint
	// FiatProductItemBlueprintHook is the signature for custom FiatProductItemBlueprint hook methods
	FiatProductItemBlueprintHook func(boil.Executor, *FiatProductItemBlueprint) error

	fiatProductItemBlueprintQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	fiatProductItemBlueprintType                 = reflect.TypeOf(&FiatProductItemBlueprint{})
	fiatProductItemBlueprintMapping              = queries.MakeStructMapping(fiatProductItemBlueprintType)
	fiatProductItemBlueprintPrimaryKeyMapping, _ = queries.BindMapping(fiatProductItemBlueprintType, fiatProductItemBlueprintMapping, fiatProductItemBlueprintPrimaryKeyColumns)
	fiatProductItemBlueprintInsertCacheMut       sync.RWMutex
	fiatProductItemBlueprintInsertCache          = make(map[string]insertCache)
	fiatProductItemBlueprintUpdateCacheMut       sync.RWMutex
	fiatProductItemBlueprintUpdateCache          = make(map[string]updateCache)
	fiatProductItemBlueprintUpsertCacheMut       sync.RWMutex
	fiatProductItemBlueprintUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var fiatProductItemBlueprintAfterSelectHooks []FiatProductItemBlueprintHook

var fiatProductItemBlueprintBeforeInsertHooks []FiatProductItemBlueprintHook
var fiatProductItemBlueprintAfterInsertHooks []FiatProductItemBlueprintHook

var fiatProductItemBlueprintBeforeUpdateHooks []FiatProductItemBlueprintHook
var fiatProductItemBlueprintAfterUpdateHooks []FiatProductItemBlueprintHook

var fiatProductItemBlueprintBeforeDeleteHooks []FiatProductItemBlueprintHook
var fiatProductItemBlueprintAfterDeleteHooks []FiatProductItemBlueprintHook

var fiatProductItemBlueprintBeforeUpsertHooks []FiatProductItemBlueprintHook
var fiatProductItemBlueprintAfterUpsertHooks []FiatProductItemBlueprintHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *FiatProductItemBlueprint) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *FiatProductItemBlueprint) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *FiatProductItemBlueprint) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *FiatProductItemBlueprint) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *FiatProductItemBlueprint) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *FiatProductItemBlueprint) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *FiatProductItemBlueprint) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *FiatProductItemBlueprint) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *FiatProductItemBlueprint) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range fiatProductItemBlueprintAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddFiatProductItemBlueprintHook registers your hook function for all future operations.
func AddFiatProductItemBlueprintHook(hookPoint boil.HookPoint, fiatProductItemBlueprintHook FiatProductItemBlueprintHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		fiatProductItemBlueprintAfterSelectHooks = append(fiatProductItemBlueprintAfterSelectHooks, fiatProductItemBlueprintHook)
	case boil.BeforeInsertHook:
		fiatProductItemBlueprintBeforeInsertHooks = append(fiatProductItemBlueprintBeforeInsertHooks, fiatProductItemBlueprintHook)
	case boil.AfterInsertHook:
		fiatProductItemBlueprintAfterInsertHooks = append(fiatProductItemBlueprintAfterInsertHooks, fiatProductItemBlueprintHook)
	case boil.BeforeUpdateHook:
		fiatProductItemBlueprintBeforeUpdateHooks = append(fiatProductItemBlueprintBeforeUpdateHooks, fiatProductItemBlueprintHook)
	case boil.AfterUpdateHook:
		fiatProductItemBlueprintAfterUpdateHooks = append(fiatProductItemBlueprintAfterUpdateHooks, fiatProductItemBlueprintHook)
	case boil.BeforeDeleteHook:
		fiatProductItemBlueprintBeforeDeleteHooks = append(fiatProductItemBlueprintBeforeDeleteHooks, fiatProductItemBlueprintHook)
	case boil.AfterDeleteHook:
		fiatProductItemBlueprintAfterDeleteHooks = append(fiatProductItemBlueprintAfterDeleteHooks, fiatProductItemBlueprintHook)
	case boil.BeforeUpsertHook:
		fiatProductItemBlueprintBeforeUpsertHooks = append(fiatProductItemBlueprintBeforeUpsertHooks, fiatProductItemBlueprintHook)
	case boil.AfterUpsertHook:
		fiatProductItemBlueprintAfterUpsertHooks = append(fiatProductItemBlueprintAfterUpsertHooks, fiatProductItemBlueprintHook)
	}
}

// One returns a single fiatProductItemBlueprint record from the query.
func (q fiatProductItemBlueprintQuery) One(exec boil.Executor) (*FiatProductItemBlueprint, error) {
	o := &FiatProductItemBlueprint{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for fiat_product_item_blueprints")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all FiatProductItemBlueprint records from the query.
func (q fiatProductItemBlueprintQuery) All(exec boil.Executor) (FiatProductItemBlueprintSlice, error) {
	var o []*FiatProductItemBlueprint

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to FiatProductItemBlueprint slice")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all FiatProductItemBlueprint records in the query.
func (q fiatProductItemBlueprintQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count fiat_product_item_blueprints rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q fiatProductItemBlueprintQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if fiat_product_item_blueprints exists")
	}

	return count > 0, nil
}

// AmmoBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) AmmoBlueprint(mods ...qm.QueryMod) blueprintAmmoQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AmmoBlueprintID),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintAmmos(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_ammo\"")

	return query
}

// MechAnimationBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) MechAnimationBlueprint(mods ...qm.QueryMod) blueprintMechAnimationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MechAnimationBlueprintID),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintMechAnimations(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_mech_animation\"")

	return query
}

// MechBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) MechBlueprint(mods ...qm.QueryMod) blueprintMechQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MechBlueprintID),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintMechs(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_mechs\"")

	return query
}

// MechSkinBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) MechSkinBlueprint(mods ...qm.QueryMod) blueprintMechSkinQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MechSkinBlueprintID),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintMechSkins(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_mech_skin\"")

	return query
}

// PlayerAbilityBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) PlayerAbilityBlueprint(mods ...qm.QueryMod) blueprintPlayerAbilityQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PlayerAbilityBlueprintID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintPlayerAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_player_abilities\"")

	return query
}

// PowerCoreBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) PowerCoreBlueprint(mods ...qm.QueryMod) blueprintPowerCoreQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PowerCoreBlueprintID),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintPowerCores(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_power_cores\"")

	return query
}

// ProductItem pointed to by the foreign key.
func (o *FiatProductItemBlueprint) ProductItem(mods ...qm.QueryMod) fiatProductItemQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ProductItemID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := FiatProductItems(queryMods...)
	queries.SetFrom(query.Query, "\"fiat_product_items\"")

	return query
}

// UtilityBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) UtilityBlueprint(mods ...qm.QueryMod) blueprintUtilityQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UtilityBlueprintID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintUtilities(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_utility\"")

	return query
}

// WeaponBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) WeaponBlueprint(mods ...qm.QueryMod) blueprintWeaponQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.WeaponBlueprintID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintWeapons(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_weapons\"")

	return query
}

// WeaponSkinBlueprint pointed to by the foreign key.
func (o *FiatProductItemBlueprint) WeaponSkinBlueprint(mods ...qm.QueryMod) blueprintWeaponSkinQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.WeaponSkinBlueprintID),
	}

	queryMods = append(queryMods, mods...)

	query := BlueprintWeaponSkins(queryMods...)
	queries.SetFrom(query.Query, "\"blueprint_weapon_skin\"")

	return query
}

// LoadAmmoBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadAmmoBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.AmmoBlueprintID) {
			args = append(args, object.AmmoBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AmmoBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AmmoBlueprintID) {
				args = append(args, obj.AmmoBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_ammo`),
		qm.WhereIn(`blueprint_ammo.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintAmmo")
	}

	var resultSlice []*BlueprintAmmo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintAmmo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_ammo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_ammo")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AmmoBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintAmmoR{}
		}
		foreign.R.AmmoBlueprintFiatProductItemBlueprints = append(foreign.R.AmmoBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AmmoBlueprintID, foreign.ID) {
				local.R.AmmoBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintAmmoR{}
				}
				foreign.R.AmmoBlueprintFiatProductItemBlueprints = append(foreign.R.AmmoBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadMechAnimationBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadMechAnimationBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.MechAnimationBlueprintID) {
			args = append(args, object.MechAnimationBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.MechAnimationBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.MechAnimationBlueprintID) {
				args = append(args, obj.MechAnimationBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_mech_animation`),
		qm.WhereIn(`blueprint_mech_animation.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintMechAnimation")
	}

	var resultSlice []*BlueprintMechAnimation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintMechAnimation")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_mech_animation")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_mech_animation")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MechAnimationBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintMechAnimationR{}
		}
		foreign.R.MechAnimationBlueprintFiatProductItemBlueprints = append(foreign.R.MechAnimationBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MechAnimationBlueprintID, foreign.ID) {
				local.R.MechAnimationBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintMechAnimationR{}
				}
				foreign.R.MechAnimationBlueprintFiatProductItemBlueprints = append(foreign.R.MechAnimationBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadMechBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadMechBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.MechBlueprintID) {
			args = append(args, object.MechBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.MechBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.MechBlueprintID) {
				args = append(args, obj.MechBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_mechs`),
		qm.WhereIn(`blueprint_mechs.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintMech")
	}

	var resultSlice []*BlueprintMech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintMech")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_mechs")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MechBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintMechR{}
		}
		foreign.R.MechBlueprintFiatProductItemBlueprints = append(foreign.R.MechBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MechBlueprintID, foreign.ID) {
				local.R.MechBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintMechR{}
				}
				foreign.R.MechBlueprintFiatProductItemBlueprints = append(foreign.R.MechBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadMechSkinBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadMechSkinBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.MechSkinBlueprintID) {
			args = append(args, object.MechSkinBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.MechSkinBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.MechSkinBlueprintID) {
				args = append(args, obj.MechSkinBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_mech_skin`),
		qm.WhereIn(`blueprint_mech_skin.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintMechSkin")
	}

	var resultSlice []*BlueprintMechSkin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintMechSkin")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_mech_skin")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_mech_skin")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MechSkinBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintMechSkinR{}
		}
		foreign.R.MechSkinBlueprintFiatProductItemBlueprints = append(foreign.R.MechSkinBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MechSkinBlueprintID, foreign.ID) {
				local.R.MechSkinBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintMechSkinR{}
				}
				foreign.R.MechSkinBlueprintFiatProductItemBlueprints = append(foreign.R.MechSkinBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadPlayerAbilityBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadPlayerAbilityBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.PlayerAbilityBlueprintID) {
			args = append(args, object.PlayerAbilityBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PlayerAbilityBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PlayerAbilityBlueprintID) {
				args = append(args, obj.PlayerAbilityBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_player_abilities`),
		qm.WhereIn(`blueprint_player_abilities.id in ?`, args...),
		qmhelper.WhereIsNull(`blueprint_player_abilities.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintPlayerAbility")
	}

	var resultSlice []*BlueprintPlayerAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintPlayerAbility")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_player_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_player_abilities")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PlayerAbilityBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintPlayerAbilityR{}
		}
		foreign.R.PlayerAbilityBlueprintFiatProductItemBlueprints = append(foreign.R.PlayerAbilityBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PlayerAbilityBlueprintID, foreign.ID) {
				local.R.PlayerAbilityBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintPlayerAbilityR{}
				}
				foreign.R.PlayerAbilityBlueprintFiatProductItemBlueprints = append(foreign.R.PlayerAbilityBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadPowerCoreBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadPowerCoreBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.PowerCoreBlueprintID) {
			args = append(args, object.PowerCoreBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PowerCoreBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PowerCoreBlueprintID) {
				args = append(args, obj.PowerCoreBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_power_cores`),
		qm.WhereIn(`blueprint_power_cores.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintPowerCore")
	}

	var resultSlice []*BlueprintPowerCore
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintPowerCore")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_power_cores")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_power_cores")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PowerCoreBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintPowerCoreR{}
		}
		foreign.R.PowerCoreBlueprintFiatProductItemBlueprints = append(foreign.R.PowerCoreBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PowerCoreBlueprintID, foreign.ID) {
				local.R.PowerCoreBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintPowerCoreR{}
				}
				foreign.R.PowerCoreBlueprintFiatProductItemBlueprints = append(foreign.R.PowerCoreBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadProductItem allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadProductItem(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.ProductItemID) {
			args = append(args, object.ProductItemID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductItemID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductItemID) {
				args = append(args, obj.ProductItemID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`fiat_product_items`),
		qm.WhereIn(`fiat_product_items.id in ?`, args...),
		qmhelper.WhereIsNull(`fiat_product_items.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load FiatProductItem")
	}

	var resultSlice []*FiatProductItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice FiatProductItem")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for fiat_product_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for fiat_product_items")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductItem = foreign
		if foreign.R == nil {
			foreign.R = &fiatProductItemR{}
		}
		foreign.R.ProductItemFiatProductItemBlueprints = append(foreign.R.ProductItemFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductItemID, foreign.ID) {
				local.R.ProductItem = foreign
				if foreign.R == nil {
					foreign.R = &fiatProductItemR{}
				}
				foreign.R.ProductItemFiatProductItemBlueprints = append(foreign.R.ProductItemFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadUtilityBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadUtilityBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.UtilityBlueprintID) {
			args = append(args, object.UtilityBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.UtilityBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.UtilityBlueprintID) {
				args = append(args, obj.UtilityBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_utility`),
		qm.WhereIn(`blueprint_utility.id in ?`, args...),
		qmhelper.WhereIsNull(`blueprint_utility.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintUtility")
	}

	var resultSlice []*BlueprintUtility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintUtility")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_utility")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_utility")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UtilityBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintUtilityR{}
		}
		foreign.R.UtilityBlueprintFiatProductItemBlueprints = append(foreign.R.UtilityBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.UtilityBlueprintID, foreign.ID) {
				local.R.UtilityBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintUtilityR{}
				}
				foreign.R.UtilityBlueprintFiatProductItemBlueprints = append(foreign.R.UtilityBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadWeaponBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadWeaponBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.WeaponBlueprintID) {
			args = append(args, object.WeaponBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.WeaponBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.WeaponBlueprintID) {
				args = append(args, obj.WeaponBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_weapons`),
		qm.WhereIn(`blueprint_weapons.id in ?`, args...),
		qmhelper.WhereIsNull(`blueprint_weapons.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintWeapon")
	}

	var resultSlice []*BlueprintWeapon
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintWeapon")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_weapons")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_weapons")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.WeaponBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintWeaponR{}
		}
		foreign.R.WeaponBlueprintFiatProductItemBlueprints = append(foreign.R.WeaponBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.WeaponBlueprintID, foreign.ID) {
				local.R.WeaponBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintWeaponR{}
				}
				foreign.R.WeaponBlueprintFiatProductItemBlueprints = append(foreign.R.WeaponBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// LoadWeaponSkinBlueprint allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (fiatProductItemBlueprintL) LoadWeaponSkinBlueprint(e boil.Executor, singular bool, maybeFiatProductItemBlueprint interface{}, mods queries.Applicator) error {
	var slice []*FiatProductItemBlueprint
	var object *FiatProductItemBlueprint

	if singular {
		object = maybeFiatProductItemBlueprint.(*FiatProductItemBlueprint)
	} else {
		slice = *maybeFiatProductItemBlueprint.(*[]*FiatProductItemBlueprint)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &fiatProductItemBlueprintR{}
		}
		if !queries.IsNil(object.WeaponSkinBlueprintID) {
			args = append(args, object.WeaponSkinBlueprintID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &fiatProductItemBlueprintR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.WeaponSkinBlueprintID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.WeaponSkinBlueprintID) {
				args = append(args, obj.WeaponSkinBlueprintID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blueprint_weapon_skin`),
		qm.WhereIn(`blueprint_weapon_skin.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BlueprintWeaponSkin")
	}

	var resultSlice []*BlueprintWeaponSkin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BlueprintWeaponSkin")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blueprint_weapon_skin")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blueprint_weapon_skin")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.WeaponSkinBlueprint = foreign
		if foreign.R == nil {
			foreign.R = &blueprintWeaponSkinR{}
		}
		foreign.R.WeaponSkinBlueprintFiatProductItemBlueprints = append(foreign.R.WeaponSkinBlueprintFiatProductItemBlueprints, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.WeaponSkinBlueprintID, foreign.ID) {
				local.R.WeaponSkinBlueprint = foreign
				if foreign.R == nil {
					foreign.R = &blueprintWeaponSkinR{}
				}
				foreign.R.WeaponSkinBlueprintFiatProductItemBlueprints = append(foreign.R.WeaponSkinBlueprintFiatProductItemBlueprints, local)
				break
			}
		}
	}

	return nil
}

// SetAmmoBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.AmmoBlueprint to related.
// Adds o to related.R.AmmoBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetAmmoBlueprint(exec boil.Executor, insert bool, related *BlueprintAmmo) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"ammo_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AmmoBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			AmmoBlueprint: related,
		}
	} else {
		o.R.AmmoBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintAmmoR{
			AmmoBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.AmmoBlueprintFiatProductItemBlueprints = append(related.R.AmmoBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveAmmoBlueprint relationship.
// Sets o.R.AmmoBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveAmmoBlueprint(exec boil.Executor, related *BlueprintAmmo) error {
	var err error

	queries.SetScanner(&o.AmmoBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("ammo_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.AmmoBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AmmoBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.AmmoBlueprintID, ri.AmmoBlueprintID) {
			continue
		}

		ln := len(related.R.AmmoBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.AmmoBlueprintFiatProductItemBlueprints[i] = related.R.AmmoBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.AmmoBlueprintFiatProductItemBlueprints = related.R.AmmoBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetMechAnimationBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.MechAnimationBlueprint to related.
// Adds o to related.R.MechAnimationBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetMechAnimationBlueprint(exec boil.Executor, insert bool, related *BlueprintMechAnimation) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"mech_animation_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MechAnimationBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			MechAnimationBlueprint: related,
		}
	} else {
		o.R.MechAnimationBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintMechAnimationR{
			MechAnimationBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.MechAnimationBlueprintFiatProductItemBlueprints = append(related.R.MechAnimationBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveMechAnimationBlueprint relationship.
// Sets o.R.MechAnimationBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveMechAnimationBlueprint(exec boil.Executor, related *BlueprintMechAnimation) error {
	var err error

	queries.SetScanner(&o.MechAnimationBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("mech_animation_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MechAnimationBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.MechAnimationBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.MechAnimationBlueprintID, ri.MechAnimationBlueprintID) {
			continue
		}

		ln := len(related.R.MechAnimationBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.MechAnimationBlueprintFiatProductItemBlueprints[i] = related.R.MechAnimationBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.MechAnimationBlueprintFiatProductItemBlueprints = related.R.MechAnimationBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetMechBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.MechBlueprint to related.
// Adds o to related.R.MechBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetMechBlueprint(exec boil.Executor, insert bool, related *BlueprintMech) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"mech_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MechBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			MechBlueprint: related,
		}
	} else {
		o.R.MechBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintMechR{
			MechBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.MechBlueprintFiatProductItemBlueprints = append(related.R.MechBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveMechBlueprint relationship.
// Sets o.R.MechBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveMechBlueprint(exec boil.Executor, related *BlueprintMech) error {
	var err error

	queries.SetScanner(&o.MechBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("mech_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MechBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.MechBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.MechBlueprintID, ri.MechBlueprintID) {
			continue
		}

		ln := len(related.R.MechBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.MechBlueprintFiatProductItemBlueprints[i] = related.R.MechBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.MechBlueprintFiatProductItemBlueprints = related.R.MechBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetMechSkinBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.MechSkinBlueprint to related.
// Adds o to related.R.MechSkinBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetMechSkinBlueprint(exec boil.Executor, insert bool, related *BlueprintMechSkin) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"mech_skin_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MechSkinBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			MechSkinBlueprint: related,
		}
	} else {
		o.R.MechSkinBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintMechSkinR{
			MechSkinBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.MechSkinBlueprintFiatProductItemBlueprints = append(related.R.MechSkinBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveMechSkinBlueprint relationship.
// Sets o.R.MechSkinBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveMechSkinBlueprint(exec boil.Executor, related *BlueprintMechSkin) error {
	var err error

	queries.SetScanner(&o.MechSkinBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("mech_skin_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MechSkinBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.MechSkinBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.MechSkinBlueprintID, ri.MechSkinBlueprintID) {
			continue
		}

		ln := len(related.R.MechSkinBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.MechSkinBlueprintFiatProductItemBlueprints[i] = related.R.MechSkinBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.MechSkinBlueprintFiatProductItemBlueprints = related.R.MechSkinBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetPlayerAbilityBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.PlayerAbilityBlueprint to related.
// Adds o to related.R.PlayerAbilityBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetPlayerAbilityBlueprint(exec boil.Executor, insert bool, related *BlueprintPlayerAbility) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"player_ability_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PlayerAbilityBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			PlayerAbilityBlueprint: related,
		}
	} else {
		o.R.PlayerAbilityBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintPlayerAbilityR{
			PlayerAbilityBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.PlayerAbilityBlueprintFiatProductItemBlueprints = append(related.R.PlayerAbilityBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemovePlayerAbilityBlueprint relationship.
// Sets o.R.PlayerAbilityBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemovePlayerAbilityBlueprint(exec boil.Executor, related *BlueprintPlayerAbility) error {
	var err error

	queries.SetScanner(&o.PlayerAbilityBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("player_ability_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.PlayerAbilityBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PlayerAbilityBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.PlayerAbilityBlueprintID, ri.PlayerAbilityBlueprintID) {
			continue
		}

		ln := len(related.R.PlayerAbilityBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.PlayerAbilityBlueprintFiatProductItemBlueprints[i] = related.R.PlayerAbilityBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.PlayerAbilityBlueprintFiatProductItemBlueprints = related.R.PlayerAbilityBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetPowerCoreBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.PowerCoreBlueprint to related.
// Adds o to related.R.PowerCoreBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetPowerCoreBlueprint(exec boil.Executor, insert bool, related *BlueprintPowerCore) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"power_core_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PowerCoreBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			PowerCoreBlueprint: related,
		}
	} else {
		o.R.PowerCoreBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintPowerCoreR{
			PowerCoreBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.PowerCoreBlueprintFiatProductItemBlueprints = append(related.R.PowerCoreBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemovePowerCoreBlueprint relationship.
// Sets o.R.PowerCoreBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemovePowerCoreBlueprint(exec boil.Executor, related *BlueprintPowerCore) error {
	var err error

	queries.SetScanner(&o.PowerCoreBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("power_core_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.PowerCoreBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PowerCoreBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.PowerCoreBlueprintID, ri.PowerCoreBlueprintID) {
			continue
		}

		ln := len(related.R.PowerCoreBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.PowerCoreBlueprintFiatProductItemBlueprints[i] = related.R.PowerCoreBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.PowerCoreBlueprintFiatProductItemBlueprints = related.R.PowerCoreBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetProductItem of the fiatProductItemBlueprint to the related item.
// Sets o.R.ProductItem to related.
// Adds o to related.R.ProductItemFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetProductItem(exec boil.Executor, insert bool, related *FiatProductItem) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"product_item_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductItemID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			ProductItem: related,
		}
	} else {
		o.R.ProductItem = related
	}

	if related.R == nil {
		related.R = &fiatProductItemR{
			ProductItemFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.ProductItemFiatProductItemBlueprints = append(related.R.ProductItemFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveProductItem relationship.
// Sets o.R.ProductItem to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveProductItem(exec boil.Executor, related *FiatProductItem) error {
	var err error

	queries.SetScanner(&o.ProductItemID, nil)
	if _, err = o.Update(exec, boil.Whitelist("product_item_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductItem = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ProductItemFiatProductItemBlueprints {
		if queries.Equal(o.ProductItemID, ri.ProductItemID) {
			continue
		}

		ln := len(related.R.ProductItemFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.ProductItemFiatProductItemBlueprints[i] = related.R.ProductItemFiatProductItemBlueprints[ln-1]
		}
		related.R.ProductItemFiatProductItemBlueprints = related.R.ProductItemFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetUtilityBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.UtilityBlueprint to related.
// Adds o to related.R.UtilityBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetUtilityBlueprint(exec boil.Executor, insert bool, related *BlueprintUtility) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"utility_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.UtilityBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			UtilityBlueprint: related,
		}
	} else {
		o.R.UtilityBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintUtilityR{
			UtilityBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.UtilityBlueprintFiatProductItemBlueprints = append(related.R.UtilityBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveUtilityBlueprint relationship.
// Sets o.R.UtilityBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveUtilityBlueprint(exec boil.Executor, related *BlueprintUtility) error {
	var err error

	queries.SetScanner(&o.UtilityBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("utility_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.UtilityBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.UtilityBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.UtilityBlueprintID, ri.UtilityBlueprintID) {
			continue
		}

		ln := len(related.R.UtilityBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.UtilityBlueprintFiatProductItemBlueprints[i] = related.R.UtilityBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.UtilityBlueprintFiatProductItemBlueprints = related.R.UtilityBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetWeaponBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.WeaponBlueprint to related.
// Adds o to related.R.WeaponBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetWeaponBlueprint(exec boil.Executor, insert bool, related *BlueprintWeapon) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"weapon_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.WeaponBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			WeaponBlueprint: related,
		}
	} else {
		o.R.WeaponBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintWeaponR{
			WeaponBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.WeaponBlueprintFiatProductItemBlueprints = append(related.R.WeaponBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveWeaponBlueprint relationship.
// Sets o.R.WeaponBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveWeaponBlueprint(exec boil.Executor, related *BlueprintWeapon) error {
	var err error

	queries.SetScanner(&o.WeaponBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("weapon_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.WeaponBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.WeaponBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.WeaponBlueprintID, ri.WeaponBlueprintID) {
			continue
		}

		ln := len(related.R.WeaponBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.WeaponBlueprintFiatProductItemBlueprints[i] = related.R.WeaponBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.WeaponBlueprintFiatProductItemBlueprints = related.R.WeaponBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// SetWeaponSkinBlueprint of the fiatProductItemBlueprint to the related item.
// Sets o.R.WeaponSkinBlueprint to related.
// Adds o to related.R.WeaponSkinBlueprintFiatProductItemBlueprints.
func (o *FiatProductItemBlueprint) SetWeaponSkinBlueprint(exec boil.Executor, insert bool, related *BlueprintWeaponSkin) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"weapon_skin_blueprint_id"}),
		strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.WeaponSkinBlueprintID, related.ID)
	if o.R == nil {
		o.R = &fiatProductItemBlueprintR{
			WeaponSkinBlueprint: related,
		}
	} else {
		o.R.WeaponSkinBlueprint = related
	}

	if related.R == nil {
		related.R = &blueprintWeaponSkinR{
			WeaponSkinBlueprintFiatProductItemBlueprints: FiatProductItemBlueprintSlice{o},
		}
	} else {
		related.R.WeaponSkinBlueprintFiatProductItemBlueprints = append(related.R.WeaponSkinBlueprintFiatProductItemBlueprints, o)
	}

	return nil
}

// RemoveWeaponSkinBlueprint relationship.
// Sets o.R.WeaponSkinBlueprint to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *FiatProductItemBlueprint) RemoveWeaponSkinBlueprint(exec boil.Executor, related *BlueprintWeaponSkin) error {
	var err error

	queries.SetScanner(&o.WeaponSkinBlueprintID, nil)
	if _, err = o.Update(exec, boil.Whitelist("weapon_skin_blueprint_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.WeaponSkinBlueprint = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.WeaponSkinBlueprintFiatProductItemBlueprints {
		if queries.Equal(o.WeaponSkinBlueprintID, ri.WeaponSkinBlueprintID) {
			continue
		}

		ln := len(related.R.WeaponSkinBlueprintFiatProductItemBlueprints)
		if ln > 1 && i < ln-1 {
			related.R.WeaponSkinBlueprintFiatProductItemBlueprints[i] = related.R.WeaponSkinBlueprintFiatProductItemBlueprints[ln-1]
		}
		related.R.WeaponSkinBlueprintFiatProductItemBlueprints = related.R.WeaponSkinBlueprintFiatProductItemBlueprints[:ln-1]
		break
	}
	return nil
}

// FiatProductItemBlueprints retrieves all the records using an executor.
func FiatProductItemBlueprints(mods ...qm.QueryMod) fiatProductItemBlueprintQuery {
	mods = append(mods, qm.From("\"fiat_product_item_blueprints\""))
	return fiatProductItemBlueprintQuery{NewQuery(mods...)}
}

// FindFiatProductItemBlueprint retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindFiatProductItemBlueprint(exec boil.Executor, iD string, selectCols ...string) (*FiatProductItemBlueprint, error) {
	fiatProductItemBlueprintObj := &FiatProductItemBlueprint{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"fiat_product_item_blueprints\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, fiatProductItemBlueprintObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from fiat_product_item_blueprints")
	}

	if err = fiatProductItemBlueprintObj.doAfterSelectHooks(exec); err != nil {
		return fiatProductItemBlueprintObj, err
	}

	return fiatProductItemBlueprintObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *FiatProductItemBlueprint) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no fiat_product_item_blueprints provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(fiatProductItemBlueprintColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	fiatProductItemBlueprintInsertCacheMut.RLock()
	cache, cached := fiatProductItemBlueprintInsertCache[key]
	fiatProductItemBlueprintInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			fiatProductItemBlueprintAllColumns,
			fiatProductItemBlueprintColumnsWithDefault,
			fiatProductItemBlueprintColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(fiatProductItemBlueprintType, fiatProductItemBlueprintMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(fiatProductItemBlueprintType, fiatProductItemBlueprintMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"fiat_product_item_blueprints\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"fiat_product_item_blueprints\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into fiat_product_item_blueprints")
	}

	if !cached {
		fiatProductItemBlueprintInsertCacheMut.Lock()
		fiatProductItemBlueprintInsertCache[key] = cache
		fiatProductItemBlueprintInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the FiatProductItemBlueprint.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *FiatProductItemBlueprint) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	fiatProductItemBlueprintUpdateCacheMut.RLock()
	cache, cached := fiatProductItemBlueprintUpdateCache[key]
	fiatProductItemBlueprintUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			fiatProductItemBlueprintAllColumns,
			fiatProductItemBlueprintPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update fiat_product_item_blueprints, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, fiatProductItemBlueprintPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(fiatProductItemBlueprintType, fiatProductItemBlueprintMapping, append(wl, fiatProductItemBlueprintPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update fiat_product_item_blueprints row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for fiat_product_item_blueprints")
	}

	if !cached {
		fiatProductItemBlueprintUpdateCacheMut.Lock()
		fiatProductItemBlueprintUpdateCache[key] = cache
		fiatProductItemBlueprintUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q fiatProductItemBlueprintQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for fiat_product_item_blueprints")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for fiat_product_item_blueprints")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o FiatProductItemBlueprintSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), fiatProductItemBlueprintPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, fiatProductItemBlueprintPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in fiatProductItemBlueprint slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all fiatProductItemBlueprint")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *FiatProductItemBlueprint) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no fiat_product_item_blueprints provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(fiatProductItemBlueprintColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	fiatProductItemBlueprintUpsertCacheMut.RLock()
	cache, cached := fiatProductItemBlueprintUpsertCache[key]
	fiatProductItemBlueprintUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			fiatProductItemBlueprintAllColumns,
			fiatProductItemBlueprintColumnsWithDefault,
			fiatProductItemBlueprintColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			fiatProductItemBlueprintAllColumns,
			fiatProductItemBlueprintPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert fiat_product_item_blueprints, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(fiatProductItemBlueprintPrimaryKeyColumns))
			copy(conflict, fiatProductItemBlueprintPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"fiat_product_item_blueprints\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(fiatProductItemBlueprintType, fiatProductItemBlueprintMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(fiatProductItemBlueprintType, fiatProductItemBlueprintMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert fiat_product_item_blueprints")
	}

	if !cached {
		fiatProductItemBlueprintUpsertCacheMut.Lock()
		fiatProductItemBlueprintUpsertCache[key] = cache
		fiatProductItemBlueprintUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single FiatProductItemBlueprint record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *FiatProductItemBlueprint) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no FiatProductItemBlueprint provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), fiatProductItemBlueprintPrimaryKeyMapping)
	sql := "DELETE FROM \"fiat_product_item_blueprints\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from fiat_product_item_blueprints")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for fiat_product_item_blueprints")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q fiatProductItemBlueprintQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no fiatProductItemBlueprintQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from fiat_product_item_blueprints")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for fiat_product_item_blueprints")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o FiatProductItemBlueprintSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(fiatProductItemBlueprintBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), fiatProductItemBlueprintPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"fiat_product_item_blueprints\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, fiatProductItemBlueprintPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from fiatProductItemBlueprint slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for fiat_product_item_blueprints")
	}

	if len(fiatProductItemBlueprintAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *FiatProductItemBlueprint) Reload(exec boil.Executor) error {
	ret, err := FindFiatProductItemBlueprint(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *FiatProductItemBlueprintSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := FiatProductItemBlueprintSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), fiatProductItemBlueprintPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"fiat_product_item_blueprints\".* FROM \"fiat_product_item_blueprints\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, fiatProductItemBlueprintPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in FiatProductItemBlueprintSlice")
	}

	*o = slice

	return nil
}

// FiatProductItemBlueprintExists checks if the FiatProductItemBlueprint row exists.
func FiatProductItemBlueprintExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"fiat_product_item_blueprints\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if fiat_product_item_blueprints exists")
	}

	return exists, nil
}
