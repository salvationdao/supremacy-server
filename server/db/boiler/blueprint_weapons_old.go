// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/shopspring/decimal"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// BlueprintWeaponsOld is an object representing the database table.
type BlueprintWeaponsOld struct {
	ID                  string              `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	Label               string              `boiler:"label" boil:"label" json:"label" toml:"label" yaml:"label"`
	Slug                string              `boiler:"slug" boil:"slug" json:"slug" toml:"slug" yaml:"slug"`
	Damage              int                 `boiler:"damage" boil:"damage" json:"damage" toml:"damage" yaml:"damage"`
	DeletedAt           null.Time           `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	UpdatedAt           time.Time           `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt           time.Time           `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	GameClientWeaponID  null.String         `boiler:"game_client_weapon_id" boil:"game_client_weapon_id" json:"game_client_weapon_id,omitempty" toml:"game_client_weapon_id" yaml:"game_client_weapon_id,omitempty"`
	WeaponType          string              `boiler:"weapon_type" boil:"weapon_type" json:"weapon_type" toml:"weapon_type" yaml:"weapon_type"`
	Collection          string              `boiler:"collection" boil:"collection" json:"collection" toml:"collection" yaml:"collection"`
	DamageFalloff       null.Int            `boiler:"damage_falloff" boil:"damage_falloff" json:"damage_falloff,omitempty" toml:"damage_falloff" yaml:"damage_falloff,omitempty"`
	DamageFalloffRate   null.Int            `boiler:"damage_falloff_rate" boil:"damage_falloff_rate" json:"damage_falloff_rate,omitempty" toml:"damage_falloff_rate" yaml:"damage_falloff_rate,omitempty"`
	Radius              null.Int            `boiler:"radius" boil:"radius" json:"radius,omitempty" toml:"radius" yaml:"radius,omitempty"`
	RadiusDamageFalloff null.Int            `boiler:"radius_damage_falloff" boil:"radius_damage_falloff" json:"radius_damage_falloff,omitempty" toml:"radius_damage_falloff" yaml:"radius_damage_falloff,omitempty"`
	Spread              decimal.NullDecimal `boiler:"spread" boil:"spread" json:"spread,omitempty" toml:"spread" yaml:"spread,omitempty"`
	RateOfFire          decimal.NullDecimal `boiler:"rate_of_fire" boil:"rate_of_fire" json:"rate_of_fire,omitempty" toml:"rate_of_fire" yaml:"rate_of_fire,omitempty"`
	ProjectileSpeed     decimal.NullDecimal `boiler:"projectile_speed" boil:"projectile_speed" json:"projectile_speed,omitempty" toml:"projectile_speed" yaml:"projectile_speed,omitempty"`
	MaxAmmo             null.Int            `boiler:"max_ammo" boil:"max_ammo" json:"max_ammo,omitempty" toml:"max_ammo" yaml:"max_ammo,omitempty"`
	IsMelee             bool                `boiler:"is_melee" boil:"is_melee" json:"is_melee" toml:"is_melee" yaml:"is_melee"`
	Tier                string              `boiler:"tier" boil:"tier" json:"tier" toml:"tier" yaml:"tier"`
	EnergyCost          decimal.NullDecimal `boiler:"energy_cost" boil:"energy_cost" json:"energy_cost,omitempty" toml:"energy_cost" yaml:"energy_cost,omitempty"`
	WeaponModelID       string              `boiler:"weapon_model_id" boil:"weapon_model_id" json:"weapon_model_id" toml:"weapon_model_id" yaml:"weapon_model_id"`

	R *blueprintWeaponsOldR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L blueprintWeaponsOldL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var BlueprintWeaponsOldColumns = struct {
	ID                  string
	Label               string
	Slug                string
	Damage              string
	DeletedAt           string
	UpdatedAt           string
	CreatedAt           string
	GameClientWeaponID  string
	WeaponType          string
	Collection          string
	DamageFalloff       string
	DamageFalloffRate   string
	Radius              string
	RadiusDamageFalloff string
	Spread              string
	RateOfFire          string
	ProjectileSpeed     string
	MaxAmmo             string
	IsMelee             string
	Tier                string
	EnergyCost          string
	WeaponModelID       string
}{
	ID:                  "id",
	Label:               "label",
	Slug:                "slug",
	Damage:              "damage",
	DeletedAt:           "deleted_at",
	UpdatedAt:           "updated_at",
	CreatedAt:           "created_at",
	GameClientWeaponID:  "game_client_weapon_id",
	WeaponType:          "weapon_type",
	Collection:          "collection",
	DamageFalloff:       "damage_falloff",
	DamageFalloffRate:   "damage_falloff_rate",
	Radius:              "radius",
	RadiusDamageFalloff: "radius_damage_falloff",
	Spread:              "spread",
	RateOfFire:          "rate_of_fire",
	ProjectileSpeed:     "projectile_speed",
	MaxAmmo:             "max_ammo",
	IsMelee:             "is_melee",
	Tier:                "tier",
	EnergyCost:          "energy_cost",
	WeaponModelID:       "weapon_model_id",
}

var BlueprintWeaponsOldTableColumns = struct {
	ID                  string
	Label               string
	Slug                string
	Damage              string
	DeletedAt           string
	UpdatedAt           string
	CreatedAt           string
	GameClientWeaponID  string
	WeaponType          string
	Collection          string
	DamageFalloff       string
	DamageFalloffRate   string
	Radius              string
	RadiusDamageFalloff string
	Spread              string
	RateOfFire          string
	ProjectileSpeed     string
	MaxAmmo             string
	IsMelee             string
	Tier                string
	EnergyCost          string
	WeaponModelID       string
}{
	ID:                  "blueprint_weapons_old.id",
	Label:               "blueprint_weapons_old.label",
	Slug:                "blueprint_weapons_old.slug",
	Damage:              "blueprint_weapons_old.damage",
	DeletedAt:           "blueprint_weapons_old.deleted_at",
	UpdatedAt:           "blueprint_weapons_old.updated_at",
	CreatedAt:           "blueprint_weapons_old.created_at",
	GameClientWeaponID:  "blueprint_weapons_old.game_client_weapon_id",
	WeaponType:          "blueprint_weapons_old.weapon_type",
	Collection:          "blueprint_weapons_old.collection",
	DamageFalloff:       "blueprint_weapons_old.damage_falloff",
	DamageFalloffRate:   "blueprint_weapons_old.damage_falloff_rate",
	Radius:              "blueprint_weapons_old.radius",
	RadiusDamageFalloff: "blueprint_weapons_old.radius_damage_falloff",
	Spread:              "blueprint_weapons_old.spread",
	RateOfFire:          "blueprint_weapons_old.rate_of_fire",
	ProjectileSpeed:     "blueprint_weapons_old.projectile_speed",
	MaxAmmo:             "blueprint_weapons_old.max_ammo",
	IsMelee:             "blueprint_weapons_old.is_melee",
	Tier:                "blueprint_weapons_old.tier",
	EnergyCost:          "blueprint_weapons_old.energy_cost",
	WeaponModelID:       "blueprint_weapons_old.weapon_model_id",
}

// Generated where

var BlueprintWeaponsOldWhere = struct {
	ID                  whereHelperstring
	Label               whereHelperstring
	Slug                whereHelperstring
	Damage              whereHelperint
	DeletedAt           whereHelpernull_Time
	UpdatedAt           whereHelpertime_Time
	CreatedAt           whereHelpertime_Time
	GameClientWeaponID  whereHelpernull_String
	WeaponType          whereHelperstring
	Collection          whereHelperstring
	DamageFalloff       whereHelpernull_Int
	DamageFalloffRate   whereHelpernull_Int
	Radius              whereHelpernull_Int
	RadiusDamageFalloff whereHelpernull_Int
	Spread              whereHelperdecimal_NullDecimal
	RateOfFire          whereHelperdecimal_NullDecimal
	ProjectileSpeed     whereHelperdecimal_NullDecimal
	MaxAmmo             whereHelpernull_Int
	IsMelee             whereHelperbool
	Tier                whereHelperstring
	EnergyCost          whereHelperdecimal_NullDecimal
	WeaponModelID       whereHelperstring
}{
	ID:                  whereHelperstring{field: "\"blueprint_weapons_old\".\"id\""},
	Label:               whereHelperstring{field: "\"blueprint_weapons_old\".\"label\""},
	Slug:                whereHelperstring{field: "\"blueprint_weapons_old\".\"slug\""},
	Damage:              whereHelperint{field: "\"blueprint_weapons_old\".\"damage\""},
	DeletedAt:           whereHelpernull_Time{field: "\"blueprint_weapons_old\".\"deleted_at\""},
	UpdatedAt:           whereHelpertime_Time{field: "\"blueprint_weapons_old\".\"updated_at\""},
	CreatedAt:           whereHelpertime_Time{field: "\"blueprint_weapons_old\".\"created_at\""},
	GameClientWeaponID:  whereHelpernull_String{field: "\"blueprint_weapons_old\".\"game_client_weapon_id\""},
	WeaponType:          whereHelperstring{field: "\"blueprint_weapons_old\".\"weapon_type\""},
	Collection:          whereHelperstring{field: "\"blueprint_weapons_old\".\"collection\""},
	DamageFalloff:       whereHelpernull_Int{field: "\"blueprint_weapons_old\".\"damage_falloff\""},
	DamageFalloffRate:   whereHelpernull_Int{field: "\"blueprint_weapons_old\".\"damage_falloff_rate\""},
	Radius:              whereHelpernull_Int{field: "\"blueprint_weapons_old\".\"radius\""},
	RadiusDamageFalloff: whereHelpernull_Int{field: "\"blueprint_weapons_old\".\"radius_damage_falloff\""},
	Spread:              whereHelperdecimal_NullDecimal{field: "\"blueprint_weapons_old\".\"spread\""},
	RateOfFire:          whereHelperdecimal_NullDecimal{field: "\"blueprint_weapons_old\".\"rate_of_fire\""},
	ProjectileSpeed:     whereHelperdecimal_NullDecimal{field: "\"blueprint_weapons_old\".\"projectile_speed\""},
	MaxAmmo:             whereHelpernull_Int{field: "\"blueprint_weapons_old\".\"max_ammo\""},
	IsMelee:             whereHelperbool{field: "\"blueprint_weapons_old\".\"is_melee\""},
	Tier:                whereHelperstring{field: "\"blueprint_weapons_old\".\"tier\""},
	EnergyCost:          whereHelperdecimal_NullDecimal{field: "\"blueprint_weapons_old\".\"energy_cost\""},
	WeaponModelID:       whereHelperstring{field: "\"blueprint_weapons_old\".\"weapon_model_id\""},
}

// BlueprintWeaponsOldRels is where relationship names are stored.
var BlueprintWeaponsOldRels = struct {
}{}

// blueprintWeaponsOldR is where relationships are stored.
type blueprintWeaponsOldR struct {
}

// NewStruct creates a new relationship struct
func (*blueprintWeaponsOldR) NewStruct() *blueprintWeaponsOldR {
	return &blueprintWeaponsOldR{}
}

// blueprintWeaponsOldL is where Load methods for each relationship are stored.
type blueprintWeaponsOldL struct{}

var (
	blueprintWeaponsOldAllColumns            = []string{"id", "label", "slug", "damage", "deleted_at", "updated_at", "created_at", "game_client_weapon_id", "weapon_type", "collection", "damage_falloff", "damage_falloff_rate", "radius", "radius_damage_falloff", "spread", "rate_of_fire", "projectile_speed", "max_ammo", "is_melee", "tier", "energy_cost", "weapon_model_id"}
	blueprintWeaponsOldColumnsWithoutDefault = []string{"label", "slug", "damage", "weapon_type", "weapon_model_id"}
	blueprintWeaponsOldColumnsWithDefault    = []string{"id", "deleted_at", "updated_at", "created_at", "game_client_weapon_id", "collection", "damage_falloff", "damage_falloff_rate", "radius", "radius_damage_falloff", "spread", "rate_of_fire", "projectile_speed", "max_ammo", "is_melee", "tier", "energy_cost"}
	blueprintWeaponsOldPrimaryKeyColumns     = []string{"id"}
	blueprintWeaponsOldGeneratedColumns      = []string{}
)

type (
	// BlueprintWeaponsOldSlice is an alias for a slice of pointers to BlueprintWeaponsOld.
	// This should almost always be used instead of []BlueprintWeaponsOld.
	BlueprintWeaponsOldSlice []*BlueprintWeaponsOld
	// BlueprintWeaponsOldHook is the signature for custom BlueprintWeaponsOld hook methods
	BlueprintWeaponsOldHook func(boil.Executor, *BlueprintWeaponsOld) error

	blueprintWeaponsOldQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	blueprintWeaponsOldType                 = reflect.TypeOf(&BlueprintWeaponsOld{})
	blueprintWeaponsOldMapping              = queries.MakeStructMapping(blueprintWeaponsOldType)
	blueprintWeaponsOldPrimaryKeyMapping, _ = queries.BindMapping(blueprintWeaponsOldType, blueprintWeaponsOldMapping, blueprintWeaponsOldPrimaryKeyColumns)
	blueprintWeaponsOldInsertCacheMut       sync.RWMutex
	blueprintWeaponsOldInsertCache          = make(map[string]insertCache)
	blueprintWeaponsOldUpdateCacheMut       sync.RWMutex
	blueprintWeaponsOldUpdateCache          = make(map[string]updateCache)
	blueprintWeaponsOldUpsertCacheMut       sync.RWMutex
	blueprintWeaponsOldUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var blueprintWeaponsOldAfterSelectHooks []BlueprintWeaponsOldHook

var blueprintWeaponsOldBeforeInsertHooks []BlueprintWeaponsOldHook
var blueprintWeaponsOldAfterInsertHooks []BlueprintWeaponsOldHook

var blueprintWeaponsOldBeforeUpdateHooks []BlueprintWeaponsOldHook
var blueprintWeaponsOldAfterUpdateHooks []BlueprintWeaponsOldHook

var blueprintWeaponsOldBeforeDeleteHooks []BlueprintWeaponsOldHook
var blueprintWeaponsOldAfterDeleteHooks []BlueprintWeaponsOldHook

var blueprintWeaponsOldBeforeUpsertHooks []BlueprintWeaponsOldHook
var blueprintWeaponsOldAfterUpsertHooks []BlueprintWeaponsOldHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *BlueprintWeaponsOld) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *BlueprintWeaponsOld) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *BlueprintWeaponsOld) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *BlueprintWeaponsOld) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *BlueprintWeaponsOld) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *BlueprintWeaponsOld) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *BlueprintWeaponsOld) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *BlueprintWeaponsOld) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *BlueprintWeaponsOld) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintWeaponsOldAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddBlueprintWeaponsOldHook registers your hook function for all future operations.
func AddBlueprintWeaponsOldHook(hookPoint boil.HookPoint, blueprintWeaponsOldHook BlueprintWeaponsOldHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		blueprintWeaponsOldAfterSelectHooks = append(blueprintWeaponsOldAfterSelectHooks, blueprintWeaponsOldHook)
	case boil.BeforeInsertHook:
		blueprintWeaponsOldBeforeInsertHooks = append(blueprintWeaponsOldBeforeInsertHooks, blueprintWeaponsOldHook)
	case boil.AfterInsertHook:
		blueprintWeaponsOldAfterInsertHooks = append(blueprintWeaponsOldAfterInsertHooks, blueprintWeaponsOldHook)
	case boil.BeforeUpdateHook:
		blueprintWeaponsOldBeforeUpdateHooks = append(blueprintWeaponsOldBeforeUpdateHooks, blueprintWeaponsOldHook)
	case boil.AfterUpdateHook:
		blueprintWeaponsOldAfterUpdateHooks = append(blueprintWeaponsOldAfterUpdateHooks, blueprintWeaponsOldHook)
	case boil.BeforeDeleteHook:
		blueprintWeaponsOldBeforeDeleteHooks = append(blueprintWeaponsOldBeforeDeleteHooks, blueprintWeaponsOldHook)
	case boil.AfterDeleteHook:
		blueprintWeaponsOldAfterDeleteHooks = append(blueprintWeaponsOldAfterDeleteHooks, blueprintWeaponsOldHook)
	case boil.BeforeUpsertHook:
		blueprintWeaponsOldBeforeUpsertHooks = append(blueprintWeaponsOldBeforeUpsertHooks, blueprintWeaponsOldHook)
	case boil.AfterUpsertHook:
		blueprintWeaponsOldAfterUpsertHooks = append(blueprintWeaponsOldAfterUpsertHooks, blueprintWeaponsOldHook)
	}
}

// One returns a single blueprintWeaponsOld record from the query.
func (q blueprintWeaponsOldQuery) One(exec boil.Executor) (*BlueprintWeaponsOld, error) {
	o := &BlueprintWeaponsOld{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for blueprint_weapons_old")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all BlueprintWeaponsOld records from the query.
func (q blueprintWeaponsOldQuery) All(exec boil.Executor) (BlueprintWeaponsOldSlice, error) {
	var o []*BlueprintWeaponsOld

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to BlueprintWeaponsOld slice")
	}

	if len(blueprintWeaponsOldAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all BlueprintWeaponsOld records in the query.
func (q blueprintWeaponsOldQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count blueprint_weapons_old rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q blueprintWeaponsOldQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if blueprint_weapons_old exists")
	}

	return count > 0, nil
}

// BlueprintWeaponsOlds retrieves all the records using an executor.
func BlueprintWeaponsOlds(mods ...qm.QueryMod) blueprintWeaponsOldQuery {
	mods = append(mods, qm.From("\"blueprint_weapons_old\""), qmhelper.WhereIsNull("\"blueprint_weapons_old\".\"deleted_at\""))
	return blueprintWeaponsOldQuery{NewQuery(mods...)}
}

// FindBlueprintWeaponsOld retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindBlueprintWeaponsOld(exec boil.Executor, iD string, selectCols ...string) (*BlueprintWeaponsOld, error) {
	blueprintWeaponsOldObj := &BlueprintWeaponsOld{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"blueprint_weapons_old\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, blueprintWeaponsOldObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from blueprint_weapons_old")
	}

	if err = blueprintWeaponsOldObj.doAfterSelectHooks(exec); err != nil {
		return blueprintWeaponsOldObj, err
	}

	return blueprintWeaponsOldObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *BlueprintWeaponsOld) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no blueprint_weapons_old provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(blueprintWeaponsOldColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	blueprintWeaponsOldInsertCacheMut.RLock()
	cache, cached := blueprintWeaponsOldInsertCache[key]
	blueprintWeaponsOldInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			blueprintWeaponsOldAllColumns,
			blueprintWeaponsOldColumnsWithDefault,
			blueprintWeaponsOldColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(blueprintWeaponsOldType, blueprintWeaponsOldMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(blueprintWeaponsOldType, blueprintWeaponsOldMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"blueprint_weapons_old\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"blueprint_weapons_old\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into blueprint_weapons_old")
	}

	if !cached {
		blueprintWeaponsOldInsertCacheMut.Lock()
		blueprintWeaponsOldInsertCache[key] = cache
		blueprintWeaponsOldInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the BlueprintWeaponsOld.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *BlueprintWeaponsOld) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	blueprintWeaponsOldUpdateCacheMut.RLock()
	cache, cached := blueprintWeaponsOldUpdateCache[key]
	blueprintWeaponsOldUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			blueprintWeaponsOldAllColumns,
			blueprintWeaponsOldPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update blueprint_weapons_old, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"blueprint_weapons_old\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, blueprintWeaponsOldPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(blueprintWeaponsOldType, blueprintWeaponsOldMapping, append(wl, blueprintWeaponsOldPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update blueprint_weapons_old row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for blueprint_weapons_old")
	}

	if !cached {
		blueprintWeaponsOldUpdateCacheMut.Lock()
		blueprintWeaponsOldUpdateCache[key] = cache
		blueprintWeaponsOldUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q blueprintWeaponsOldQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for blueprint_weapons_old")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for blueprint_weapons_old")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o BlueprintWeaponsOldSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), blueprintWeaponsOldPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"blueprint_weapons_old\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, blueprintWeaponsOldPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in blueprintWeaponsOld slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all blueprintWeaponsOld")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *BlueprintWeaponsOld) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no blueprint_weapons_old provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(blueprintWeaponsOldColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	blueprintWeaponsOldUpsertCacheMut.RLock()
	cache, cached := blueprintWeaponsOldUpsertCache[key]
	blueprintWeaponsOldUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			blueprintWeaponsOldAllColumns,
			blueprintWeaponsOldColumnsWithDefault,
			blueprintWeaponsOldColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			blueprintWeaponsOldAllColumns,
			blueprintWeaponsOldPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert blueprint_weapons_old, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(blueprintWeaponsOldPrimaryKeyColumns))
			copy(conflict, blueprintWeaponsOldPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"blueprint_weapons_old\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(blueprintWeaponsOldType, blueprintWeaponsOldMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(blueprintWeaponsOldType, blueprintWeaponsOldMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert blueprint_weapons_old")
	}

	if !cached {
		blueprintWeaponsOldUpsertCacheMut.Lock()
		blueprintWeaponsOldUpsertCache[key] = cache
		blueprintWeaponsOldUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single BlueprintWeaponsOld record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *BlueprintWeaponsOld) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no BlueprintWeaponsOld provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), blueprintWeaponsOldPrimaryKeyMapping)
		sql = "DELETE FROM \"blueprint_weapons_old\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"blueprint_weapons_old\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(blueprintWeaponsOldType, blueprintWeaponsOldMapping, append(wl, blueprintWeaponsOldPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from blueprint_weapons_old")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for blueprint_weapons_old")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q blueprintWeaponsOldQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no blueprintWeaponsOldQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from blueprint_weapons_old")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for blueprint_weapons_old")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o BlueprintWeaponsOldSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(blueprintWeaponsOldBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), blueprintWeaponsOldPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"blueprint_weapons_old\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, blueprintWeaponsOldPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), blueprintWeaponsOldPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"blueprint_weapons_old\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, blueprintWeaponsOldPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from blueprintWeaponsOld slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for blueprint_weapons_old")
	}

	if len(blueprintWeaponsOldAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *BlueprintWeaponsOld) Reload(exec boil.Executor) error {
	ret, err := FindBlueprintWeaponsOld(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *BlueprintWeaponsOldSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := BlueprintWeaponsOldSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), blueprintWeaponsOldPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"blueprint_weapons_old\".* FROM \"blueprint_weapons_old\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, blueprintWeaponsOldPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in BlueprintWeaponsOldSlice")
	}

	*o = slice

	return nil
}

// BlueprintWeaponsOldExists checks if the BlueprintWeaponsOld row exists.
func BlueprintWeaponsOldExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"blueprint_weapons_old\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if blueprint_weapons_old exists")
	}

	return exists, nil
}
