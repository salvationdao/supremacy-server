// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/shopspring/decimal"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Player is an object representing the database table.
type Player struct {
	ID               string          `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	FactionID        null.String     `boiler:"faction_id" boil:"faction_id" json:"faction_id,omitempty" toml:"faction_id" yaml:"faction_id,omitempty"`
	Username         null.String     `boiler:"username" boil:"username" json:"username,omitempty" toml:"username" yaml:"username,omitempty"`
	PublicAddress    null.String     `boiler:"public_address" boil:"public_address" json:"public_address,omitempty" toml:"public_address" yaml:"public_address,omitempty"`
	IsAi             bool            `boiler:"is_ai" boil:"is_ai" json:"is_ai" toml:"is_ai" yaml:"is_ai"`
	DeletedAt        null.Time       `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	UpdatedAt        time.Time       `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt        time.Time       `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	MobileNumber     null.String     `boiler:"mobile_number" boil:"mobile_number" json:"mobile_number,omitempty" toml:"mobile_number" yaml:"mobile_number,omitempty"`
	IssuePunishFee   decimal.Decimal `boiler:"issue_punish_fee" boil:"issue_punish_fee" json:"issue_punish_fee" toml:"issue_punish_fee" yaml:"issue_punish_fee"`
	ReportedCost     decimal.Decimal `boiler:"reported_cost" boil:"reported_cost" json:"reported_cost" toml:"reported_cost" yaml:"reported_cost"`
	Gid              int             `boiler:"gid" boil:"gid" json:"gid" toml:"gid" yaml:"gid"`
	Rank             string          `boiler:"rank" boil:"rank" json:"rank" toml:"rank" yaml:"rank"`
	SentMessageCount int             `boiler:"sent_message_count" boil:"sent_message_count" json:"sent_message_count" toml:"sent_message_count" yaml:"sent_message_count"`
	AboutMe          null.String     `boiler:"about_me" boil:"about_me" json:"about_me,omitempty" toml:"about_me" yaml:"about_me,omitempty"`
	ProfileAvatarID  null.String     `boiler:"profile_avatar_id" boil:"profile_avatar_id" json:"profile_avatar_id,omitempty" toml:"profile_avatar_id" yaml:"profile_avatar_id,omitempty"`
	SyndicateID      null.String     `boiler:"syndicate_id" boil:"syndicate_id" json:"syndicate_id,omitempty" toml:"syndicate_id" yaml:"syndicate_id,omitempty"`
	CustomAvatarID   null.String     `boiler:"custom_avatar_id" boil:"custom_avatar_id" json:"custom_avatar_id,omitempty" toml:"custom_avatar_id" yaml:"custom_avatar_id,omitempty"`
	RoleID           string          `boiler:"role_id" boil:"role_id" json:"role_id" toml:"role_id" yaml:"role_id"`

	R *playerR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L playerL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PlayerColumns = struct {
	ID               string
	FactionID        string
	Username         string
	PublicAddress    string
	IsAi             string
	DeletedAt        string
	UpdatedAt        string
	CreatedAt        string
	MobileNumber     string
	IssuePunishFee   string
	ReportedCost     string
	Gid              string
	Rank             string
	SentMessageCount string
	AboutMe          string
	ProfileAvatarID  string
	SyndicateID      string
	CustomAvatarID   string
	RoleID           string
}{
	ID:               "id",
	FactionID:        "faction_id",
	Username:         "username",
	PublicAddress:    "public_address",
	IsAi:             "is_ai",
	DeletedAt:        "deleted_at",
	UpdatedAt:        "updated_at",
	CreatedAt:        "created_at",
	MobileNumber:     "mobile_number",
	IssuePunishFee:   "issue_punish_fee",
	ReportedCost:     "reported_cost",
	Gid:              "gid",
	Rank:             "rank",
	SentMessageCount: "sent_message_count",
	AboutMe:          "about_me",
	ProfileAvatarID:  "profile_avatar_id",
	SyndicateID:      "syndicate_id",
	CustomAvatarID:   "custom_avatar_id",
	RoleID:           "role_id",
}

var PlayerTableColumns = struct {
	ID               string
	FactionID        string
	Username         string
	PublicAddress    string
	IsAi             string
	DeletedAt        string
	UpdatedAt        string
	CreatedAt        string
	MobileNumber     string
	IssuePunishFee   string
	ReportedCost     string
	Gid              string
	Rank             string
	SentMessageCount string
	AboutMe          string
	ProfileAvatarID  string
	SyndicateID      string
	CustomAvatarID   string
	RoleID           string
}{
	ID:               "players.id",
	FactionID:        "players.faction_id",
	Username:         "players.username",
	PublicAddress:    "players.public_address",
	IsAi:             "players.is_ai",
	DeletedAt:        "players.deleted_at",
	UpdatedAt:        "players.updated_at",
	CreatedAt:        "players.created_at",
	MobileNumber:     "players.mobile_number",
	IssuePunishFee:   "players.issue_punish_fee",
	ReportedCost:     "players.reported_cost",
	Gid:              "players.gid",
	Rank:             "players.rank",
	SentMessageCount: "players.sent_message_count",
	AboutMe:          "players.about_me",
	ProfileAvatarID:  "players.profile_avatar_id",
	SyndicateID:      "players.syndicate_id",
	CustomAvatarID:   "players.custom_avatar_id",
	RoleID:           "players.role_id",
}

// Generated where

var PlayerWhere = struct {
	ID               whereHelperstring
	FactionID        whereHelpernull_String
	Username         whereHelpernull_String
	PublicAddress    whereHelpernull_String
	IsAi             whereHelperbool
	DeletedAt        whereHelpernull_Time
	UpdatedAt        whereHelpertime_Time
	CreatedAt        whereHelpertime_Time
	MobileNumber     whereHelpernull_String
	IssuePunishFee   whereHelperdecimal_Decimal
	ReportedCost     whereHelperdecimal_Decimal
	Gid              whereHelperint
	Rank             whereHelperstring
	SentMessageCount whereHelperint
	AboutMe          whereHelpernull_String
	ProfileAvatarID  whereHelpernull_String
	SyndicateID      whereHelpernull_String
	CustomAvatarID   whereHelpernull_String
	RoleID           whereHelperstring
}{
	ID:               whereHelperstring{field: "\"players\".\"id\""},
	FactionID:        whereHelpernull_String{field: "\"players\".\"faction_id\""},
	Username:         whereHelpernull_String{field: "\"players\".\"username\""},
	PublicAddress:    whereHelpernull_String{field: "\"players\".\"public_address\""},
	IsAi:             whereHelperbool{field: "\"players\".\"is_ai\""},
	DeletedAt:        whereHelpernull_Time{field: "\"players\".\"deleted_at\""},
	UpdatedAt:        whereHelpertime_Time{field: "\"players\".\"updated_at\""},
	CreatedAt:        whereHelpertime_Time{field: "\"players\".\"created_at\""},
	MobileNumber:     whereHelpernull_String{field: "\"players\".\"mobile_number\""},
	IssuePunishFee:   whereHelperdecimal_Decimal{field: "\"players\".\"issue_punish_fee\""},
	ReportedCost:     whereHelperdecimal_Decimal{field: "\"players\".\"reported_cost\""},
	Gid:              whereHelperint{field: "\"players\".\"gid\""},
	Rank:             whereHelperstring{field: "\"players\".\"rank\""},
	SentMessageCount: whereHelperint{field: "\"players\".\"sent_message_count\""},
	AboutMe:          whereHelpernull_String{field: "\"players\".\"about_me\""},
	ProfileAvatarID:  whereHelpernull_String{field: "\"players\".\"profile_avatar_id\""},
	SyndicateID:      whereHelpernull_String{field: "\"players\".\"syndicate_id\""},
	CustomAvatarID:   whereHelpernull_String{field: "\"players\".\"custom_avatar_id\""},
	RoleID:           whereHelperstring{field: "\"players\".\"role_id\""},
}

// PlayerRels is where relationship names are stored.
var PlayerRels = struct {
	CustomAvatar                             string
	Faction                                  string
	ProfileAvatar                            string
	Role                                     string
	Syndicate                                string
	PlayerSettingsPreference                 string
	IDPlayerStat                             string
	OwnerAmmos                               string
	VotedByApplicationVotes                  string
	BattleAbilityOptInLogs                   string
	BattleAbilityTriggers                    string
	BattleContracts                          string
	BattleContributions                      string
	OwnerBattleMechs                         string
	OwnerBattleQueues                        string
	PaidByBattleQueueFees                    string
	Battles                                  string
	OwnerBattleWins                          string
	ChatHistories                            string
	OwnerCollectionItems                     string
	ConsumedByConsumedAbilities              string
	Devices                                  string
	MVPPlayerFactionStats                    string
	OwnerItemKeycardSales                    string
	SoldToItemKeycardSales                   string
	OwnerItemSales                           string
	SoldToItemSales                          string
	BidderItemSalesBidHistories              string
	UserMarketplaceEvents                    string
	TriggeredByMechAbilityTriggerLogsOlds    string
	TriggeredByMechMoveCommandLogs           string
	OwnerMechsOlds                           string
	LookupPlayerModActionAudits              string
	ModModActionAudits                       string
	OwnerPlayerAbilities                     string
	PlayerActiveLogs                         string
	BannedByPlayerBans                       string
	BannedPlayerPlayerBans                   string
	PlayerFingerprints                       string
	PlayerIps                                string
	PlayerKeycards                           string
	PlayerKillLogs                           string
	PlayerLanguages                          string
	PlayerMechRepairSlots                    string
	PlayerMultipliers                        string
	PlayerPreferences                        string
	PlayerSpoilsOfWars                       string
	PlayersFeatures                          string
	PlayersObtainedQuests                    string
	PlayersProfileAvatars                    string
	PlayersPunishVotes                       string
	ProfileCustomAvatars                     string
	VoteByPlayerPunishVoteInstantPassRecords string
	InstantPassByPunishVotes                 string
	IssuedByPunishVotes                      string
	ReportedPlayerPunishVotes                string
	RepairAgents                             string
	OfferedByRepairOffers                    string
	SyndicateCommittees                      string
	SyndicateDirectors                       string
	CandidateSyndicateElectionCandidates     string
	VotedBySyndicateElectionVotes            string
	VotedForCandidateSyndicateElectionVotes  string
	WinnerSyndicateElections                 string
	ApplicantSyndicateJoinApplications       string
	VoteBySyndicateMotionVotes               string
	IssuedBySyndicateMotions                 string
	MemberSyndicateMotions                   string
	AdminSyndicates                          string
	CeoPlayerSyndicates                      string
	FoundedBySyndicates                      string
	SystemMessages                           string
	SenderSystemMessages                     string
}{
	CustomAvatar:                             "CustomAvatar",
	Faction:                                  "Faction",
	ProfileAvatar:                            "ProfileAvatar",
	Role:                                     "Role",
	Syndicate:                                "Syndicate",
	PlayerSettingsPreference:                 "PlayerSettingsPreference",
	IDPlayerStat:                             "IDPlayerStat",
	OwnerAmmos:                               "OwnerAmmos",
	VotedByApplicationVotes:                  "VotedByApplicationVotes",
	BattleAbilityOptInLogs:                   "BattleAbilityOptInLogs",
	BattleAbilityTriggers:                    "BattleAbilityTriggers",
	BattleContracts:                          "BattleContracts",
	BattleContributions:                      "BattleContributions",
	OwnerBattleMechs:                         "OwnerBattleMechs",
	OwnerBattleQueues:                        "OwnerBattleQueues",
	PaidByBattleQueueFees:                    "PaidByBattleQueueFees",
	Battles:                                  "Battles",
	OwnerBattleWins:                          "OwnerBattleWins",
	ChatHistories:                            "ChatHistories",
	OwnerCollectionItems:                     "OwnerCollectionItems",
	ConsumedByConsumedAbilities:              "ConsumedByConsumedAbilities",
	Devices:                                  "Devices",
	MVPPlayerFactionStats:                    "MVPPlayerFactionStats",
	OwnerItemKeycardSales:                    "OwnerItemKeycardSales",
	SoldToItemKeycardSales:                   "SoldToItemKeycardSales",
	OwnerItemSales:                           "OwnerItemSales",
	SoldToItemSales:                          "SoldToItemSales",
	BidderItemSalesBidHistories:              "BidderItemSalesBidHistories",
	UserMarketplaceEvents:                    "UserMarketplaceEvents",
	TriggeredByMechAbilityTriggerLogsOlds:    "TriggeredByMechAbilityTriggerLogsOlds",
	TriggeredByMechMoveCommandLogs:           "TriggeredByMechMoveCommandLogs",
	OwnerMechsOlds:                           "OwnerMechsOlds",
	LookupPlayerModActionAudits:              "LookupPlayerModActionAudits",
	ModModActionAudits:                       "ModModActionAudits",
	OwnerPlayerAbilities:                     "OwnerPlayerAbilities",
	PlayerActiveLogs:                         "PlayerActiveLogs",
	BannedByPlayerBans:                       "BannedByPlayerBans",
	BannedPlayerPlayerBans:                   "BannedPlayerPlayerBans",
	PlayerFingerprints:                       "PlayerFingerprints",
	PlayerIps:                                "PlayerIps",
	PlayerKeycards:                           "PlayerKeycards",
	PlayerKillLogs:                           "PlayerKillLogs",
	PlayerLanguages:                          "PlayerLanguages",
	PlayerMechRepairSlots:                    "PlayerMechRepairSlots",
	PlayerMultipliers:                        "PlayerMultipliers",
	PlayerPreferences:                        "PlayerPreferences",
	PlayerSpoilsOfWars:                       "PlayerSpoilsOfWars",
	PlayersFeatures:                          "PlayersFeatures",
	PlayersObtainedQuests:                    "PlayersObtainedQuests",
	PlayersProfileAvatars:                    "PlayersProfileAvatars",
	PlayersPunishVotes:                       "PlayersPunishVotes",
	ProfileCustomAvatars:                     "ProfileCustomAvatars",
	VoteByPlayerPunishVoteInstantPassRecords: "VoteByPlayerPunishVoteInstantPassRecords",
	InstantPassByPunishVotes:                 "InstantPassByPunishVotes",
	IssuedByPunishVotes:                      "IssuedByPunishVotes",
	ReportedPlayerPunishVotes:                "ReportedPlayerPunishVotes",
	RepairAgents:                             "RepairAgents",
	OfferedByRepairOffers:                    "OfferedByRepairOffers",
	SyndicateCommittees:                      "SyndicateCommittees",
	SyndicateDirectors:                       "SyndicateDirectors",
	CandidateSyndicateElectionCandidates:     "CandidateSyndicateElectionCandidates",
	VotedBySyndicateElectionVotes:            "VotedBySyndicateElectionVotes",
	VotedForCandidateSyndicateElectionVotes:  "VotedForCandidateSyndicateElectionVotes",
	WinnerSyndicateElections:                 "WinnerSyndicateElections",
	ApplicantSyndicateJoinApplications:       "ApplicantSyndicateJoinApplications",
	VoteBySyndicateMotionVotes:               "VoteBySyndicateMotionVotes",
	IssuedBySyndicateMotions:                 "IssuedBySyndicateMotions",
	MemberSyndicateMotions:                   "MemberSyndicateMotions",
	AdminSyndicates:                          "AdminSyndicates",
	CeoPlayerSyndicates:                      "CeoPlayerSyndicates",
	FoundedBySyndicates:                      "FoundedBySyndicates",
	SystemMessages:                           "SystemMessages",
	SenderSystemMessages:                     "SenderSystemMessages",
}

// playerR is where relationships are stored.
type playerR struct {
	CustomAvatar                             *ProfileCustomAvatar             `boiler:"CustomAvatar" boil:"CustomAvatar" json:"CustomAvatar" toml:"CustomAvatar" yaml:"CustomAvatar"`
	Faction                                  *Faction                         `boiler:"Faction" boil:"Faction" json:"Faction" toml:"Faction" yaml:"Faction"`
	ProfileAvatar                            *ProfileAvatar                   `boiler:"ProfileAvatar" boil:"ProfileAvatar" json:"ProfileAvatar" toml:"ProfileAvatar" yaml:"ProfileAvatar"`
	Role                                     *Role                            `boiler:"Role" boil:"Role" json:"Role" toml:"Role" yaml:"Role"`
	Syndicate                                *Syndicate                       `boiler:"Syndicate" boil:"Syndicate" json:"Syndicate" toml:"Syndicate" yaml:"Syndicate"`
	PlayerSettingsPreference                 *PlayerSettingsPreference        `boiler:"PlayerSettingsPreference" boil:"PlayerSettingsPreference" json:"PlayerSettingsPreference" toml:"PlayerSettingsPreference" yaml:"PlayerSettingsPreference"`
	IDPlayerStat                             *PlayerStat                      `boiler:"IDPlayerStat" boil:"IDPlayerStat" json:"IDPlayerStat" toml:"IDPlayerStat" yaml:"IDPlayerStat"`
	OwnerAmmos                               AmmoSlice                        `boiler:"OwnerAmmos" boil:"OwnerAmmos" json:"OwnerAmmos" toml:"OwnerAmmos" yaml:"OwnerAmmos"`
	VotedByApplicationVotes                  ApplicationVoteSlice             `boiler:"VotedByApplicationVotes" boil:"VotedByApplicationVotes" json:"VotedByApplicationVotes" toml:"VotedByApplicationVotes" yaml:"VotedByApplicationVotes"`
	BattleAbilityOptInLogs                   BattleAbilityOptInLogSlice       `boiler:"BattleAbilityOptInLogs" boil:"BattleAbilityOptInLogs" json:"BattleAbilityOptInLogs" toml:"BattleAbilityOptInLogs" yaml:"BattleAbilityOptInLogs"`
	BattleAbilityTriggers                    BattleAbilityTriggerSlice        `boiler:"BattleAbilityTriggers" boil:"BattleAbilityTriggers" json:"BattleAbilityTriggers" toml:"BattleAbilityTriggers" yaml:"BattleAbilityTriggers"`
	BattleContracts                          BattleContractSlice              `boiler:"BattleContracts" boil:"BattleContracts" json:"BattleContracts" toml:"BattleContracts" yaml:"BattleContracts"`
	BattleContributions                      BattleContributionSlice          `boiler:"BattleContributions" boil:"BattleContributions" json:"BattleContributions" toml:"BattleContributions" yaml:"BattleContributions"`
	OwnerBattleMechs                         BattleMechSlice                  `boiler:"OwnerBattleMechs" boil:"OwnerBattleMechs" json:"OwnerBattleMechs" toml:"OwnerBattleMechs" yaml:"OwnerBattleMechs"`
	OwnerBattleQueues                        BattleQueueSlice                 `boiler:"OwnerBattleQueues" boil:"OwnerBattleQueues" json:"OwnerBattleQueues" toml:"OwnerBattleQueues" yaml:"OwnerBattleQueues"`
	PaidByBattleQueueFees                    BattleQueueFeeSlice              `boiler:"PaidByBattleQueueFees" boil:"PaidByBattleQueueFees" json:"PaidByBattleQueueFees" toml:"PaidByBattleQueueFees" yaml:"PaidByBattleQueueFees"`
	Battles                                  BattleSlice                      `boiler:"Battles" boil:"Battles" json:"Battles" toml:"Battles" yaml:"Battles"`
	OwnerBattleWins                          BattleWinSlice                   `boiler:"OwnerBattleWins" boil:"OwnerBattleWins" json:"OwnerBattleWins" toml:"OwnerBattleWins" yaml:"OwnerBattleWins"`
	ChatHistories                            ChatHistorySlice                 `boiler:"ChatHistories" boil:"ChatHistories" json:"ChatHistories" toml:"ChatHistories" yaml:"ChatHistories"`
	OwnerCollectionItems                     CollectionItemSlice              `boiler:"OwnerCollectionItems" boil:"OwnerCollectionItems" json:"OwnerCollectionItems" toml:"OwnerCollectionItems" yaml:"OwnerCollectionItems"`
	ConsumedByConsumedAbilities              ConsumedAbilitySlice             `boiler:"ConsumedByConsumedAbilities" boil:"ConsumedByConsumedAbilities" json:"ConsumedByConsumedAbilities" toml:"ConsumedByConsumedAbilities" yaml:"ConsumedByConsumedAbilities"`
	Devices                                  DeviceSlice                      `boiler:"Devices" boil:"Devices" json:"Devices" toml:"Devices" yaml:"Devices"`
	MVPPlayerFactionStats                    FactionStatSlice                 `boiler:"MVPPlayerFactionStats" boil:"MVPPlayerFactionStats" json:"MVPPlayerFactionStats" toml:"MVPPlayerFactionStats" yaml:"MVPPlayerFactionStats"`
	OwnerItemKeycardSales                    ItemKeycardSaleSlice             `boiler:"OwnerItemKeycardSales" boil:"OwnerItemKeycardSales" json:"OwnerItemKeycardSales" toml:"OwnerItemKeycardSales" yaml:"OwnerItemKeycardSales"`
	SoldToItemKeycardSales                   ItemKeycardSaleSlice             `boiler:"SoldToItemKeycardSales" boil:"SoldToItemKeycardSales" json:"SoldToItemKeycardSales" toml:"SoldToItemKeycardSales" yaml:"SoldToItemKeycardSales"`
	OwnerItemSales                           ItemSaleSlice                    `boiler:"OwnerItemSales" boil:"OwnerItemSales" json:"OwnerItemSales" toml:"OwnerItemSales" yaml:"OwnerItemSales"`
	SoldToItemSales                          ItemSaleSlice                    `boiler:"SoldToItemSales" boil:"SoldToItemSales" json:"SoldToItemSales" toml:"SoldToItemSales" yaml:"SoldToItemSales"`
	BidderItemSalesBidHistories              ItemSalesBidHistorySlice         `boiler:"BidderItemSalesBidHistories" boil:"BidderItemSalesBidHistories" json:"BidderItemSalesBidHistories" toml:"BidderItemSalesBidHistories" yaml:"BidderItemSalesBidHistories"`
	UserMarketplaceEvents                    MarketplaceEventSlice            `boiler:"UserMarketplaceEvents" boil:"UserMarketplaceEvents" json:"UserMarketplaceEvents" toml:"UserMarketplaceEvents" yaml:"UserMarketplaceEvents"`
	TriggeredByMechAbilityTriggerLogsOlds    MechAbilityTriggerLogsOldSlice   `boiler:"TriggeredByMechAbilityTriggerLogsOlds" boil:"TriggeredByMechAbilityTriggerLogsOlds" json:"TriggeredByMechAbilityTriggerLogsOlds" toml:"TriggeredByMechAbilityTriggerLogsOlds" yaml:"TriggeredByMechAbilityTriggerLogsOlds"`
	TriggeredByMechMoveCommandLogs           MechMoveCommandLogSlice          `boiler:"TriggeredByMechMoveCommandLogs" boil:"TriggeredByMechMoveCommandLogs" json:"TriggeredByMechMoveCommandLogs" toml:"TriggeredByMechMoveCommandLogs" yaml:"TriggeredByMechMoveCommandLogs"`
	OwnerMechsOlds                           MechsOldSlice                    `boiler:"OwnerMechsOlds" boil:"OwnerMechsOlds" json:"OwnerMechsOlds" toml:"OwnerMechsOlds" yaml:"OwnerMechsOlds"`
	LookupPlayerModActionAudits              ModActionAuditSlice              `boiler:"LookupPlayerModActionAudits" boil:"LookupPlayerModActionAudits" json:"LookupPlayerModActionAudits" toml:"LookupPlayerModActionAudits" yaml:"LookupPlayerModActionAudits"`
	ModModActionAudits                       ModActionAuditSlice              `boiler:"ModModActionAudits" boil:"ModModActionAudits" json:"ModModActionAudits" toml:"ModModActionAudits" yaml:"ModModActionAudits"`
	OwnerPlayerAbilities                     PlayerAbilitySlice               `boiler:"OwnerPlayerAbilities" boil:"OwnerPlayerAbilities" json:"OwnerPlayerAbilities" toml:"OwnerPlayerAbilities" yaml:"OwnerPlayerAbilities"`
	PlayerActiveLogs                         PlayerActiveLogSlice             `boiler:"PlayerActiveLogs" boil:"PlayerActiveLogs" json:"PlayerActiveLogs" toml:"PlayerActiveLogs" yaml:"PlayerActiveLogs"`
	BannedByPlayerBans                       PlayerBanSlice                   `boiler:"BannedByPlayerBans" boil:"BannedByPlayerBans" json:"BannedByPlayerBans" toml:"BannedByPlayerBans" yaml:"BannedByPlayerBans"`
	BannedPlayerPlayerBans                   PlayerBanSlice                   `boiler:"BannedPlayerPlayerBans" boil:"BannedPlayerPlayerBans" json:"BannedPlayerPlayerBans" toml:"BannedPlayerPlayerBans" yaml:"BannedPlayerPlayerBans"`
	PlayerFingerprints                       PlayerFingerprintSlice           `boiler:"PlayerFingerprints" boil:"PlayerFingerprints" json:"PlayerFingerprints" toml:"PlayerFingerprints" yaml:"PlayerFingerprints"`
	PlayerIps                                PlayerIPSlice                    `boiler:"PlayerIps" boil:"PlayerIps" json:"PlayerIps" toml:"PlayerIps" yaml:"PlayerIps"`
	PlayerKeycards                           PlayerKeycardSlice               `boiler:"PlayerKeycards" boil:"PlayerKeycards" json:"PlayerKeycards" toml:"PlayerKeycards" yaml:"PlayerKeycards"`
	PlayerKillLogs                           PlayerKillLogSlice               `boiler:"PlayerKillLogs" boil:"PlayerKillLogs" json:"PlayerKillLogs" toml:"PlayerKillLogs" yaml:"PlayerKillLogs"`
	PlayerLanguages                          PlayerLanguageSlice              `boiler:"PlayerLanguages" boil:"PlayerLanguages" json:"PlayerLanguages" toml:"PlayerLanguages" yaml:"PlayerLanguages"`
	PlayerMechRepairSlots                    PlayerMechRepairSlotSlice        `boiler:"PlayerMechRepairSlots" boil:"PlayerMechRepairSlots" json:"PlayerMechRepairSlots" toml:"PlayerMechRepairSlots" yaml:"PlayerMechRepairSlots"`
	PlayerMultipliers                        PlayerMultiplierSlice            `boiler:"PlayerMultipliers" boil:"PlayerMultipliers" json:"PlayerMultipliers" toml:"PlayerMultipliers" yaml:"PlayerMultipliers"`
	PlayerPreferences                        PlayerPreferenceSlice            `boiler:"PlayerPreferences" boil:"PlayerPreferences" json:"PlayerPreferences" toml:"PlayerPreferences" yaml:"PlayerPreferences"`
	PlayerSpoilsOfWars                       PlayerSpoilsOfWarSlice           `boiler:"PlayerSpoilsOfWars" boil:"PlayerSpoilsOfWars" json:"PlayerSpoilsOfWars" toml:"PlayerSpoilsOfWars" yaml:"PlayerSpoilsOfWars"`
	PlayersFeatures                          PlayersFeatureSlice              `boiler:"PlayersFeatures" boil:"PlayersFeatures" json:"PlayersFeatures" toml:"PlayersFeatures" yaml:"PlayersFeatures"`
	PlayersObtainedQuests                    PlayersObtainedQuestSlice        `boiler:"PlayersObtainedQuests" boil:"PlayersObtainedQuests" json:"PlayersObtainedQuests" toml:"PlayersObtainedQuests" yaml:"PlayersObtainedQuests"`
	PlayersProfileAvatars                    PlayersProfileAvatarSlice        `boiler:"PlayersProfileAvatars" boil:"PlayersProfileAvatars" json:"PlayersProfileAvatars" toml:"PlayersProfileAvatars" yaml:"PlayersProfileAvatars"`
	PlayersPunishVotes                       PlayersPunishVoteSlice           `boiler:"PlayersPunishVotes" boil:"PlayersPunishVotes" json:"PlayersPunishVotes" toml:"PlayersPunishVotes" yaml:"PlayersPunishVotes"`
	ProfileCustomAvatars                     ProfileCustomAvatarSlice         `boiler:"ProfileCustomAvatars" boil:"ProfileCustomAvatars" json:"ProfileCustomAvatars" toml:"ProfileCustomAvatars" yaml:"ProfileCustomAvatars"`
	VoteByPlayerPunishVoteInstantPassRecords PunishVoteInstantPassRecordSlice `boiler:"VoteByPlayerPunishVoteInstantPassRecords" boil:"VoteByPlayerPunishVoteInstantPassRecords" json:"VoteByPlayerPunishVoteInstantPassRecords" toml:"VoteByPlayerPunishVoteInstantPassRecords" yaml:"VoteByPlayerPunishVoteInstantPassRecords"`
	InstantPassByPunishVotes                 PunishVoteSlice                  `boiler:"InstantPassByPunishVotes" boil:"InstantPassByPunishVotes" json:"InstantPassByPunishVotes" toml:"InstantPassByPunishVotes" yaml:"InstantPassByPunishVotes"`
	IssuedByPunishVotes                      PunishVoteSlice                  `boiler:"IssuedByPunishVotes" boil:"IssuedByPunishVotes" json:"IssuedByPunishVotes" toml:"IssuedByPunishVotes" yaml:"IssuedByPunishVotes"`
	ReportedPlayerPunishVotes                PunishVoteSlice                  `boiler:"ReportedPlayerPunishVotes" boil:"ReportedPlayerPunishVotes" json:"ReportedPlayerPunishVotes" toml:"ReportedPlayerPunishVotes" yaml:"ReportedPlayerPunishVotes"`
	RepairAgents                             RepairAgentSlice                 `boiler:"RepairAgents" boil:"RepairAgents" json:"RepairAgents" toml:"RepairAgents" yaml:"RepairAgents"`
	OfferedByRepairOffers                    RepairOfferSlice                 `boiler:"OfferedByRepairOffers" boil:"OfferedByRepairOffers" json:"OfferedByRepairOffers" toml:"OfferedByRepairOffers" yaml:"OfferedByRepairOffers"`
	SyndicateCommittees                      SyndicateCommitteeSlice          `boiler:"SyndicateCommittees" boil:"SyndicateCommittees" json:"SyndicateCommittees" toml:"SyndicateCommittees" yaml:"SyndicateCommittees"`
	SyndicateDirectors                       SyndicateDirectorSlice           `boiler:"SyndicateDirectors" boil:"SyndicateDirectors" json:"SyndicateDirectors" toml:"SyndicateDirectors" yaml:"SyndicateDirectors"`
	CandidateSyndicateElectionCandidates     SyndicateElectionCandidateSlice  `boiler:"CandidateSyndicateElectionCandidates" boil:"CandidateSyndicateElectionCandidates" json:"CandidateSyndicateElectionCandidates" toml:"CandidateSyndicateElectionCandidates" yaml:"CandidateSyndicateElectionCandidates"`
	VotedBySyndicateElectionVotes            SyndicateElectionVoteSlice       `boiler:"VotedBySyndicateElectionVotes" boil:"VotedBySyndicateElectionVotes" json:"VotedBySyndicateElectionVotes" toml:"VotedBySyndicateElectionVotes" yaml:"VotedBySyndicateElectionVotes"`
	VotedForCandidateSyndicateElectionVotes  SyndicateElectionVoteSlice       `boiler:"VotedForCandidateSyndicateElectionVotes" boil:"VotedForCandidateSyndicateElectionVotes" json:"VotedForCandidateSyndicateElectionVotes" toml:"VotedForCandidateSyndicateElectionVotes" yaml:"VotedForCandidateSyndicateElectionVotes"`
	WinnerSyndicateElections                 SyndicateElectionSlice           `boiler:"WinnerSyndicateElections" boil:"WinnerSyndicateElections" json:"WinnerSyndicateElections" toml:"WinnerSyndicateElections" yaml:"WinnerSyndicateElections"`
	ApplicantSyndicateJoinApplications       SyndicateJoinApplicationSlice    `boiler:"ApplicantSyndicateJoinApplications" boil:"ApplicantSyndicateJoinApplications" json:"ApplicantSyndicateJoinApplications" toml:"ApplicantSyndicateJoinApplications" yaml:"ApplicantSyndicateJoinApplications"`
	VoteBySyndicateMotionVotes               SyndicateMotionVoteSlice         `boiler:"VoteBySyndicateMotionVotes" boil:"VoteBySyndicateMotionVotes" json:"VoteBySyndicateMotionVotes" toml:"VoteBySyndicateMotionVotes" yaml:"VoteBySyndicateMotionVotes"`
	IssuedBySyndicateMotions                 SyndicateMotionSlice             `boiler:"IssuedBySyndicateMotions" boil:"IssuedBySyndicateMotions" json:"IssuedBySyndicateMotions" toml:"IssuedBySyndicateMotions" yaml:"IssuedBySyndicateMotions"`
	MemberSyndicateMotions                   SyndicateMotionSlice             `boiler:"MemberSyndicateMotions" boil:"MemberSyndicateMotions" json:"MemberSyndicateMotions" toml:"MemberSyndicateMotions" yaml:"MemberSyndicateMotions"`
	AdminSyndicates                          SyndicateSlice                   `boiler:"AdminSyndicates" boil:"AdminSyndicates" json:"AdminSyndicates" toml:"AdminSyndicates" yaml:"AdminSyndicates"`
	CeoPlayerSyndicates                      SyndicateSlice                   `boiler:"CeoPlayerSyndicates" boil:"CeoPlayerSyndicates" json:"CeoPlayerSyndicates" toml:"CeoPlayerSyndicates" yaml:"CeoPlayerSyndicates"`
	FoundedBySyndicates                      SyndicateSlice                   `boiler:"FoundedBySyndicates" boil:"FoundedBySyndicates" json:"FoundedBySyndicates" toml:"FoundedBySyndicates" yaml:"FoundedBySyndicates"`
	SystemMessages                           SystemMessageSlice               `boiler:"SystemMessages" boil:"SystemMessages" json:"SystemMessages" toml:"SystemMessages" yaml:"SystemMessages"`
	SenderSystemMessages                     SystemMessageSlice               `boiler:"SenderSystemMessages" boil:"SenderSystemMessages" json:"SenderSystemMessages" toml:"SenderSystemMessages" yaml:"SenderSystemMessages"`
}

// NewStruct creates a new relationship struct
func (*playerR) NewStruct() *playerR {
	return &playerR{}
}

// playerL is where Load methods for each relationship are stored.
type playerL struct{}

var (
	playerAllColumns            = []string{"id", "faction_id", "username", "public_address", "is_ai", "deleted_at", "updated_at", "created_at", "mobile_number", "issue_punish_fee", "reported_cost", "gid", "rank", "sent_message_count", "about_me", "profile_avatar_id", "syndicate_id", "custom_avatar_id", "role_id"}
	playerColumnsWithoutDefault = []string{"id"}
	playerColumnsWithDefault    = []string{"faction_id", "username", "public_address", "is_ai", "deleted_at", "updated_at", "created_at", "mobile_number", "issue_punish_fee", "reported_cost", "gid", "rank", "sent_message_count", "about_me", "profile_avatar_id", "syndicate_id", "custom_avatar_id", "role_id"}
	playerPrimaryKeyColumns     = []string{"id"}
	playerGeneratedColumns      = []string{}
)

type (
	// PlayerSlice is an alias for a slice of pointers to Player.
	// This should almost always be used instead of []Player.
	PlayerSlice []*Player
	// PlayerHook is the signature for custom Player hook methods
	PlayerHook func(boil.Executor, *Player) error

	playerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	playerType                 = reflect.TypeOf(&Player{})
	playerMapping              = queries.MakeStructMapping(playerType)
	playerPrimaryKeyMapping, _ = queries.BindMapping(playerType, playerMapping, playerPrimaryKeyColumns)
	playerInsertCacheMut       sync.RWMutex
	playerInsertCache          = make(map[string]insertCache)
	playerUpdateCacheMut       sync.RWMutex
	playerUpdateCache          = make(map[string]updateCache)
	playerUpsertCacheMut       sync.RWMutex
	playerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var playerAfterSelectHooks []PlayerHook

var playerBeforeInsertHooks []PlayerHook
var playerAfterInsertHooks []PlayerHook

var playerBeforeUpdateHooks []PlayerHook
var playerAfterUpdateHooks []PlayerHook

var playerBeforeDeleteHooks []PlayerHook
var playerAfterDeleteHooks []PlayerHook

var playerBeforeUpsertHooks []PlayerHook
var playerAfterUpsertHooks []PlayerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Player) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Player) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Player) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Player) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Player) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Player) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Player) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Player) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Player) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPlayerHook registers your hook function for all future operations.
func AddPlayerHook(hookPoint boil.HookPoint, playerHook PlayerHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		playerAfterSelectHooks = append(playerAfterSelectHooks, playerHook)
	case boil.BeforeInsertHook:
		playerBeforeInsertHooks = append(playerBeforeInsertHooks, playerHook)
	case boil.AfterInsertHook:
		playerAfterInsertHooks = append(playerAfterInsertHooks, playerHook)
	case boil.BeforeUpdateHook:
		playerBeforeUpdateHooks = append(playerBeforeUpdateHooks, playerHook)
	case boil.AfterUpdateHook:
		playerAfterUpdateHooks = append(playerAfterUpdateHooks, playerHook)
	case boil.BeforeDeleteHook:
		playerBeforeDeleteHooks = append(playerBeforeDeleteHooks, playerHook)
	case boil.AfterDeleteHook:
		playerAfterDeleteHooks = append(playerAfterDeleteHooks, playerHook)
	case boil.BeforeUpsertHook:
		playerBeforeUpsertHooks = append(playerBeforeUpsertHooks, playerHook)
	case boil.AfterUpsertHook:
		playerAfterUpsertHooks = append(playerAfterUpsertHooks, playerHook)
	}
}

// One returns a single player record from the query.
func (q playerQuery) One(exec boil.Executor) (*Player, error) {
	o := &Player{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for players")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Player records from the query.
func (q playerQuery) All(exec boil.Executor) (PlayerSlice, error) {
	var o []*Player

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to Player slice")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Player records in the query.
func (q playerQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count players rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q playerQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if players exists")
	}

	return count > 0, nil
}

// CustomAvatar pointed to by the foreign key.
func (o *Player) CustomAvatar(mods ...qm.QueryMod) profileCustomAvatarQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CustomAvatarID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := ProfileCustomAvatars(queryMods...)
	queries.SetFrom(query.Query, "\"profile_custom_avatars\"")

	return query
}

// Faction pointed to by the foreign key.
func (o *Player) Faction(mods ...qm.QueryMod) factionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FactionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Factions(queryMods...)
	queries.SetFrom(query.Query, "\"factions\"")

	return query
}

// ProfileAvatar pointed to by the foreign key.
func (o *Player) ProfileAvatar(mods ...qm.QueryMod) profileAvatarQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ProfileAvatarID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := ProfileAvatars(queryMods...)
	queries.SetFrom(query.Query, "\"profile_avatars\"")

	return query
}

// Role pointed to by the foreign key.
func (o *Player) Role(mods ...qm.QueryMod) roleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.RoleID),
	}

	queryMods = append(queryMods, mods...)

	query := Roles(queryMods...)
	queries.SetFrom(query.Query, "\"roles\"")

	return query
}

// Syndicate pointed to by the foreign key.
func (o *Player) Syndicate(mods ...qm.QueryMod) syndicateQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SyndicateID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Syndicates(queryMods...)
	queries.SetFrom(query.Query, "\"syndicates\"")

	return query
}

// PlayerSettingsPreference pointed to by the foreign key.
func (o *Player) PlayerSettingsPreference(mods ...qm.QueryMod) playerSettingsPreferenceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"player_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := PlayerSettingsPreferences(queryMods...)
	queries.SetFrom(query.Query, "\"player_settings_preferences\"")

	return query
}

// IDPlayerStat pointed to by the foreign key.
func (o *Player) IDPlayerStat(mods ...qm.QueryMod) playerStatQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := PlayerStats(queryMods...)
	queries.SetFrom(query.Query, "\"player_stats\"")

	return query
}

// OwnerAmmos retrieves all the ammo's Ammos with an executor via owner_id column.
func (o *Player) OwnerAmmos(mods ...qm.QueryMod) ammoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"ammo\".\"owner_id\"=?", o.ID),
	)

	query := Ammos(queryMods...)
	queries.SetFrom(query.Query, "\"ammo\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"ammo\".*"})
	}

	return query
}

// VotedByApplicationVotes retrieves all the application_vote's ApplicationVotes with an executor via voted_by_id column.
func (o *Player) VotedByApplicationVotes(mods ...qm.QueryMod) applicationVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"application_votes\".\"voted_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"application_votes\".\"deleted_at\""),
	)

	query := ApplicationVotes(queryMods...)
	queries.SetFrom(query.Query, "\"application_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"application_votes\".*"})
	}

	return query
}

// BattleAbilityOptInLogs retrieves all the battle_ability_opt_in_log's BattleAbilityOptInLogs with an executor.
func (o *Player) BattleAbilityOptInLogs(mods ...qm.QueryMod) battleAbilityOptInLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_ability_opt_in_logs\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_ability_opt_in_logs\".\"deleted_at\""),
	)

	query := BattleAbilityOptInLogs(queryMods...)
	queries.SetFrom(query.Query, "\"battle_ability_opt_in_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_ability_opt_in_logs\".*"})
	}

	return query
}

// BattleAbilityTriggers retrieves all the battle_ability_trigger's BattleAbilityTriggers with an executor.
func (o *Player) BattleAbilityTriggers(mods ...qm.QueryMod) battleAbilityTriggerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_ability_triggers\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_ability_triggers\".\"deleted_at\""),
	)

	query := BattleAbilityTriggers(queryMods...)
	queries.SetFrom(query.Query, "\"battle_ability_triggers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_ability_triggers\".*"})
	}

	return query
}

// BattleContracts retrieves all the battle_contract's BattleContracts with an executor.
func (o *Player) BattleContracts(mods ...qm.QueryMod) battleContractQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contracts\".\"player_id\"=?", o.ID),
	)

	query := BattleContracts(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contracts\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contracts\".*"})
	}

	return query
}

// BattleContributions retrieves all the battle_contribution's BattleContributions with an executor.
func (o *Player) BattleContributions(mods ...qm.QueryMod) battleContributionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contributions\".\"player_id\"=?", o.ID),
	)

	query := BattleContributions(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contributions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contributions\".*"})
	}

	return query
}

// OwnerBattleMechs retrieves all the battle_mech's BattleMechs with an executor via owner_id column.
func (o *Player) OwnerBattleMechs(mods ...qm.QueryMod) battleMechQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_mechs\".\"owner_id\"=?", o.ID),
	)

	query := BattleMechs(queryMods...)
	queries.SetFrom(query.Query, "\"battle_mechs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_mechs\".*"})
	}

	return query
}

// OwnerBattleQueues retrieves all the battle_queue's BattleQueues with an executor via owner_id column.
func (o *Player) OwnerBattleQueues(mods ...qm.QueryMod) battleQueueQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_queue\".\"owner_id\"=?", o.ID),
	)

	query := BattleQueues(queryMods...)
	queries.SetFrom(query.Query, "\"battle_queue\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_queue\".*"})
	}

	return query
}

// PaidByBattleQueueFees retrieves all the battle_queue_fee's BattleQueueFees with an executor via paid_by_id column.
func (o *Player) PaidByBattleQueueFees(mods ...qm.QueryMod) battleQueueFeeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_queue_fees\".\"paid_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"battle_queue_fees\".\"deleted_at\""),
	)

	query := BattleQueueFees(queryMods...)
	queries.SetFrom(query.Query, "\"battle_queue_fees\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_queue_fees\".*"})
	}

	return query
}

// Battles retrieves all the battle's Battles with an executor.
func (o *Player) Battles(mods ...qm.QueryMod) battleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"battle_viewers\" on \"battles\".\"id\" = \"battle_viewers\".\"battle_id\""),
		qm.Where("\"battle_viewers\".\"player_id\"=?", o.ID),
	)

	query := Battles(queryMods...)
	queries.SetFrom(query.Query, "\"battles\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battles\".*"})
	}

	return query
}

// OwnerBattleWins retrieves all the battle_win's BattleWins with an executor via owner_id column.
func (o *Player) OwnerBattleWins(mods ...qm.QueryMod) battleWinQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_wins\".\"owner_id\"=?", o.ID),
	)

	query := BattleWins(queryMods...)
	queries.SetFrom(query.Query, "\"battle_wins\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_wins\".*"})
	}

	return query
}

// ChatHistories retrieves all the chat_history's ChatHistories with an executor.
func (o *Player) ChatHistories(mods ...qm.QueryMod) chatHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"chat_history\".\"player_id\"=?", o.ID),
	)

	query := ChatHistories(queryMods...)
	queries.SetFrom(query.Query, "\"chat_history\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"chat_history\".*"})
	}

	return query
}

// OwnerCollectionItems retrieves all the collection_item's CollectionItems with an executor via owner_id column.
func (o *Player) OwnerCollectionItems(mods ...qm.QueryMod) collectionItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"collection_items\".\"owner_id\"=?", o.ID),
	)

	query := CollectionItems(queryMods...)
	queries.SetFrom(query.Query, "\"collection_items\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"collection_items\".*"})
	}

	return query
}

// ConsumedByConsumedAbilities retrieves all the consumed_ability's ConsumedAbilities with an executor via consumed_by column.
func (o *Player) ConsumedByConsumedAbilities(mods ...qm.QueryMod) consumedAbilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"consumed_abilities\".\"consumed_by\"=?", o.ID),
	)

	query := ConsumedAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"consumed_abilities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"consumed_abilities\".*"})
	}

	return query
}

// Devices retrieves all the device's Devices with an executor.
func (o *Player) Devices(mods ...qm.QueryMod) deviceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"devices\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"devices\".\"deleted_at\""),
	)

	query := Devices(queryMods...)
	queries.SetFrom(query.Query, "\"devices\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"devices\".*"})
	}

	return query
}

// MVPPlayerFactionStats retrieves all the faction_stat's FactionStats with an executor via mvp_player_id column.
func (o *Player) MVPPlayerFactionStats(mods ...qm.QueryMod) factionStatQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"faction_stats\".\"mvp_player_id\"=?", o.ID),
	)

	query := FactionStats(queryMods...)
	queries.SetFrom(query.Query, "\"faction_stats\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"faction_stats\".*"})
	}

	return query
}

// OwnerItemKeycardSales retrieves all the item_keycard_sale's ItemKeycardSales with an executor via owner_id column.
func (o *Player) OwnerItemKeycardSales(mods ...qm.QueryMod) itemKeycardSaleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_keycard_sales\".\"owner_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"item_keycard_sales\".\"deleted_at\""),
	)

	query := ItemKeycardSales(queryMods...)
	queries.SetFrom(query.Query, "\"item_keycard_sales\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_keycard_sales\".*"})
	}

	return query
}

// SoldToItemKeycardSales retrieves all the item_keycard_sale's ItemKeycardSales with an executor via sold_to column.
func (o *Player) SoldToItemKeycardSales(mods ...qm.QueryMod) itemKeycardSaleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_keycard_sales\".\"sold_to\"=?", o.ID),
		qmhelper.WhereIsNull("\"item_keycard_sales\".\"deleted_at\""),
	)

	query := ItemKeycardSales(queryMods...)
	queries.SetFrom(query.Query, "\"item_keycard_sales\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_keycard_sales\".*"})
	}

	return query
}

// OwnerItemSales retrieves all the item_sale's ItemSales with an executor via owner_id column.
func (o *Player) OwnerItemSales(mods ...qm.QueryMod) itemSaleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_sales\".\"owner_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"item_sales\".\"deleted_at\""),
	)

	query := ItemSales(queryMods...)
	queries.SetFrom(query.Query, "\"item_sales\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_sales\".*"})
	}

	return query
}

// SoldToItemSales retrieves all the item_sale's ItemSales with an executor via sold_to column.
func (o *Player) SoldToItemSales(mods ...qm.QueryMod) itemSaleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_sales\".\"sold_to\"=?", o.ID),
		qmhelper.WhereIsNull("\"item_sales\".\"deleted_at\""),
	)

	query := ItemSales(queryMods...)
	queries.SetFrom(query.Query, "\"item_sales\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_sales\".*"})
	}

	return query
}

// BidderItemSalesBidHistories retrieves all the item_sales_bid_history's ItemSalesBidHistories with an executor via bidder_id column.
func (o *Player) BidderItemSalesBidHistories(mods ...qm.QueryMod) itemSalesBidHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_sales_bid_history\".\"bidder_id\"=?", o.ID),
	)

	query := ItemSalesBidHistories(queryMods...)
	queries.SetFrom(query.Query, "\"item_sales_bid_history\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_sales_bid_history\".*"})
	}

	return query
}

// UserMarketplaceEvents retrieves all the marketplace_event's MarketplaceEvents with an executor via user_id column.
func (o *Player) UserMarketplaceEvents(mods ...qm.QueryMod) marketplaceEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"marketplace_events\".\"user_id\"=?", o.ID),
	)

	query := MarketplaceEvents(queryMods...)
	queries.SetFrom(query.Query, "\"marketplace_events\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"marketplace_events\".*"})
	}

	return query
}

// TriggeredByMechAbilityTriggerLogsOlds retrieves all the mech_ability_trigger_logs_old's MechAbilityTriggerLogsOlds with an executor via triggered_by_id column.
func (o *Player) TriggeredByMechAbilityTriggerLogsOlds(mods ...qm.QueryMod) mechAbilityTriggerLogsOldQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mech_ability_trigger_logs_old\".\"triggered_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"mech_ability_trigger_logs_old\".\"deleted_at\""),
	)

	query := MechAbilityTriggerLogsOlds(queryMods...)
	queries.SetFrom(query.Query, "\"mech_ability_trigger_logs_old\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mech_ability_trigger_logs_old\".*"})
	}

	return query
}

// TriggeredByMechMoveCommandLogs retrieves all the mech_move_command_log's MechMoveCommandLogs with an executor via triggered_by_id column.
func (o *Player) TriggeredByMechMoveCommandLogs(mods ...qm.QueryMod) mechMoveCommandLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mech_move_command_logs\".\"triggered_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"mech_move_command_logs\".\"deleted_at\""),
	)

	query := MechMoveCommandLogs(queryMods...)
	queries.SetFrom(query.Query, "\"mech_move_command_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mech_move_command_logs\".*"})
	}

	return query
}

// OwnerMechsOlds retrieves all the mechs_old's MechsOlds with an executor via owner_id column.
func (o *Player) OwnerMechsOlds(mods ...qm.QueryMod) mechsOldQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mechs_old\".\"owner_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"mechs_old\".\"deleted_at\""),
	)

	query := MechsOlds(queryMods...)
	queries.SetFrom(query.Query, "\"mechs_old\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mechs_old\".*"})
	}

	return query
}

// LookupPlayerModActionAudits retrieves all the mod_action_audit's ModActionAudits with an executor via lookup_player_id column.
func (o *Player) LookupPlayerModActionAudits(mods ...qm.QueryMod) modActionAuditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mod_action_audit\".\"lookup_player_id\"=?", o.ID),
	)

	query := ModActionAudits(queryMods...)
	queries.SetFrom(query.Query, "\"mod_action_audit\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mod_action_audit\".*"})
	}

	return query
}

// ModModActionAudits retrieves all the mod_action_audit's ModActionAudits with an executor via mod_id column.
func (o *Player) ModModActionAudits(mods ...qm.QueryMod) modActionAuditQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mod_action_audit\".\"mod_id\"=?", o.ID),
	)

	query := ModActionAudits(queryMods...)
	queries.SetFrom(query.Query, "\"mod_action_audit\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mod_action_audit\".*"})
	}

	return query
}

// OwnerPlayerAbilities retrieves all the player_ability's PlayerAbilities with an executor via owner_id column.
func (o *Player) OwnerPlayerAbilities(mods ...qm.QueryMod) playerAbilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_abilities\".\"owner_id\"=?", o.ID),
	)

	query := PlayerAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"player_abilities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_abilities\".*"})
	}

	return query
}

// PlayerActiveLogs retrieves all the player_active_log's PlayerActiveLogs with an executor.
func (o *Player) PlayerActiveLogs(mods ...qm.QueryMod) playerActiveLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_active_logs\".\"player_id\"=?", o.ID),
	)

	query := PlayerActiveLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_active_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_active_logs\".*"})
	}

	return query
}

// BannedByPlayerBans retrieves all the player_ban's PlayerBans with an executor via banned_by_id column.
func (o *Player) BannedByPlayerBans(mods ...qm.QueryMod) playerBanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_bans\".\"banned_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_bans\".\"deleted_at\""),
	)

	query := PlayerBans(queryMods...)
	queries.SetFrom(query.Query, "\"player_bans\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_bans\".*"})
	}

	return query
}

// BannedPlayerPlayerBans retrieves all the player_ban's PlayerBans with an executor via banned_player_id column.
func (o *Player) BannedPlayerPlayerBans(mods ...qm.QueryMod) playerBanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_bans\".\"banned_player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_bans\".\"deleted_at\""),
	)

	query := PlayerBans(queryMods...)
	queries.SetFrom(query.Query, "\"player_bans\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_bans\".*"})
	}

	return query
}

// PlayerFingerprints retrieves all the player_fingerprint's PlayerFingerprints with an executor.
func (o *Player) PlayerFingerprints(mods ...qm.QueryMod) playerFingerprintQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_fingerprints\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_fingerprints\".\"deleted_at\""),
	)

	query := PlayerFingerprints(queryMods...)
	queries.SetFrom(query.Query, "\"player_fingerprints\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_fingerprints\".*"})
	}

	return query
}

// PlayerIps retrieves all the player_ip's PlayerIps with an executor.
func (o *Player) PlayerIps(mods ...qm.QueryMod) playerIPQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_ips\".\"player_id\"=?", o.ID),
	)

	query := PlayerIps(queryMods...)
	queries.SetFrom(query.Query, "\"player_ips\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_ips\".*"})
	}

	return query
}

// PlayerKeycards retrieves all the player_keycard's PlayerKeycards with an executor.
func (o *Player) PlayerKeycards(mods ...qm.QueryMod) playerKeycardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_keycards\".\"player_id\"=?", o.ID),
	)

	query := PlayerKeycards(queryMods...)
	queries.SetFrom(query.Query, "\"player_keycards\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_keycards\".*"})
	}

	return query
}

// PlayerKillLogs retrieves all the player_kill_log's PlayerKillLogs with an executor.
func (o *Player) PlayerKillLogs(mods ...qm.QueryMod) playerKillLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_kill_log\".\"player_id\"=?", o.ID),
	)

	query := PlayerKillLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_kill_log\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_kill_log\".*"})
	}

	return query
}

// PlayerLanguages retrieves all the player_language's PlayerLanguages with an executor.
func (o *Player) PlayerLanguages(mods ...qm.QueryMod) playerLanguageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_languages\".\"player_id\"=?", o.ID),
	)

	query := PlayerLanguages(queryMods...)
	queries.SetFrom(query.Query, "\"player_languages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_languages\".*"})
	}

	return query
}

// PlayerMechRepairSlots retrieves all the player_mech_repair_slot's PlayerMechRepairSlots with an executor.
func (o *Player) PlayerMechRepairSlots(mods ...qm.QueryMod) playerMechRepairSlotQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_mech_repair_slots\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_mech_repair_slots\".\"deleted_at\""),
	)

	query := PlayerMechRepairSlots(queryMods...)
	queries.SetFrom(query.Query, "\"player_mech_repair_slots\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_mech_repair_slots\".*"})
	}

	return query
}

// PlayerMultipliers retrieves all the player_multiplier's PlayerMultipliers with an executor.
func (o *Player) PlayerMultipliers(mods ...qm.QueryMod) playerMultiplierQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_multipliers\".\"player_id\"=?", o.ID),
	)

	query := PlayerMultipliers(queryMods...)
	queries.SetFrom(query.Query, "\"player_multipliers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_multipliers\".*"})
	}

	return query
}

// PlayerPreferences retrieves all the player_preference's PlayerPreferences with an executor.
func (o *Player) PlayerPreferences(mods ...qm.QueryMod) playerPreferenceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_preferences\".\"player_id\"=?", o.ID),
	)

	query := PlayerPreferences(queryMods...)
	queries.SetFrom(query.Query, "\"player_preferences\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_preferences\".*"})
	}

	return query
}

// PlayerSpoilsOfWars retrieves all the player_spoils_of_war's PlayerSpoilsOfWars with an executor.
func (o *Player) PlayerSpoilsOfWars(mods ...qm.QueryMod) playerSpoilsOfWarQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_spoils_of_war\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_spoils_of_war\".\"deleted_at\""),
	)

	query := PlayerSpoilsOfWars(queryMods...)
	queries.SetFrom(query.Query, "\"player_spoils_of_war\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_spoils_of_war\".*"})
	}

	return query
}

// PlayersFeatures retrieves all the players_feature's PlayersFeatures with an executor.
func (o *Player) PlayersFeatures(mods ...qm.QueryMod) playersFeatureQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players_features\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"players_features\".\"deleted_at\""),
	)

	query := PlayersFeatures(queryMods...)
	queries.SetFrom(query.Query, "\"players_features\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players_features\".*"})
	}

	return query
}

// PlayersObtainedQuests retrieves all the players_obtained_quest's PlayersObtainedQuests with an executor.
func (o *Player) PlayersObtainedQuests(mods ...qm.QueryMod) playersObtainedQuestQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players_obtained_quests\".\"player_id\"=?", o.ID),
	)

	query := PlayersObtainedQuests(queryMods...)
	queries.SetFrom(query.Query, "\"players_obtained_quests\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players_obtained_quests\".*"})
	}

	return query
}

// PlayersProfileAvatars retrieves all the players_profile_avatar's PlayersProfileAvatars with an executor.
func (o *Player) PlayersProfileAvatars(mods ...qm.QueryMod) playersProfileAvatarQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players_profile_avatars\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"players_profile_avatars\".\"deleted_at\""),
	)

	query := PlayersProfileAvatars(queryMods...)
	queries.SetFrom(query.Query, "\"players_profile_avatars\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players_profile_avatars\".*"})
	}

	return query
}

// PlayersPunishVotes retrieves all the players_punish_vote's PlayersPunishVotes with an executor.
func (o *Player) PlayersPunishVotes(mods ...qm.QueryMod) playersPunishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players_punish_votes\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"players_punish_votes\".\"deleted_at\""),
	)

	query := PlayersPunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"players_punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players_punish_votes\".*"})
	}

	return query
}

// ProfileCustomAvatars retrieves all the profile_custom_avatar's ProfileCustomAvatars with an executor.
func (o *Player) ProfileCustomAvatars(mods ...qm.QueryMod) profileCustomAvatarQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"profile_custom_avatars\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"profile_custom_avatars\".\"deleted_at\""),
	)

	query := ProfileCustomAvatars(queryMods...)
	queries.SetFrom(query.Query, "\"profile_custom_avatars\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"profile_custom_avatars\".*"})
	}

	return query
}

// VoteByPlayerPunishVoteInstantPassRecords retrieves all the punish_vote_instant_pass_record's PunishVoteInstantPassRecords with an executor via vote_by_player_id column.
func (o *Player) VoteByPlayerPunishVoteInstantPassRecords(mods ...qm.QueryMod) punishVoteInstantPassRecordQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_vote_instant_pass_records\".\"vote_by_player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_vote_instant_pass_records\".\"deleted_at\""),
	)

	query := PunishVoteInstantPassRecords(queryMods...)
	queries.SetFrom(query.Query, "\"punish_vote_instant_pass_records\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_vote_instant_pass_records\".*"})
	}

	return query
}

// InstantPassByPunishVotes retrieves all the punish_vote's PunishVotes with an executor via instant_pass_by_id column.
func (o *Player) InstantPassByPunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"instant_pass_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// IssuedByPunishVotes retrieves all the punish_vote's PunishVotes with an executor via issued_by_id column.
func (o *Player) IssuedByPunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"issued_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// ReportedPlayerPunishVotes retrieves all the punish_vote's PunishVotes with an executor via reported_player_id column.
func (o *Player) ReportedPlayerPunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"reported_player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// RepairAgents retrieves all the repair_agent's RepairAgents with an executor.
func (o *Player) RepairAgents(mods ...qm.QueryMod) repairAgentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"repair_agents\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"repair_agents\".\"deleted_at\""),
	)

	query := RepairAgents(queryMods...)
	queries.SetFrom(query.Query, "\"repair_agents\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"repair_agents\".*"})
	}

	return query
}

// OfferedByRepairOffers retrieves all the repair_offer's RepairOffers with an executor via offered_by_id column.
func (o *Player) OfferedByRepairOffers(mods ...qm.QueryMod) repairOfferQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"repair_offers\".\"offered_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"repair_offers\".\"deleted_at\""),
	)

	query := RepairOffers(queryMods...)
	queries.SetFrom(query.Query, "\"repair_offers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"repair_offers\".*"})
	}

	return query
}

// SyndicateCommittees retrieves all the syndicate_committee's SyndicateCommittees with an executor.
func (o *Player) SyndicateCommittees(mods ...qm.QueryMod) syndicateCommitteeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_committees\".\"player_id\"=?", o.ID),
	)

	query := SyndicateCommittees(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_committees\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_committees\".*"})
	}

	return query
}

// SyndicateDirectors retrieves all the syndicate_director's SyndicateDirectors with an executor.
func (o *Player) SyndicateDirectors(mods ...qm.QueryMod) syndicateDirectorQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_directors\".\"player_id\"=?", o.ID),
	)

	query := SyndicateDirectors(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_directors\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_directors\".*"})
	}

	return query
}

// CandidateSyndicateElectionCandidates retrieves all the syndicate_election_candidate's SyndicateElectionCandidates with an executor via candidate_id column.
func (o *Player) CandidateSyndicateElectionCandidates(mods ...qm.QueryMod) syndicateElectionCandidateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_election_candidates\".\"candidate_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_election_candidates\".\"deleted_at\""),
	)

	query := SyndicateElectionCandidates(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_election_candidates\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_election_candidates\".*"})
	}

	return query
}

// VotedBySyndicateElectionVotes retrieves all the syndicate_election_vote's SyndicateElectionVotes with an executor via voted_by_id column.
func (o *Player) VotedBySyndicateElectionVotes(mods ...qm.QueryMod) syndicateElectionVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_election_votes\".\"voted_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_election_votes\".\"deleted_at\""),
	)

	query := SyndicateElectionVotes(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_election_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_election_votes\".*"})
	}

	return query
}

// VotedForCandidateSyndicateElectionVotes retrieves all the syndicate_election_vote's SyndicateElectionVotes with an executor via voted_for_candidate_id column.
func (o *Player) VotedForCandidateSyndicateElectionVotes(mods ...qm.QueryMod) syndicateElectionVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_election_votes\".\"voted_for_candidate_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_election_votes\".\"deleted_at\""),
	)

	query := SyndicateElectionVotes(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_election_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_election_votes\".*"})
	}

	return query
}

// WinnerSyndicateElections retrieves all the syndicate_election's SyndicateElections with an executor via winner_id column.
func (o *Player) WinnerSyndicateElections(mods ...qm.QueryMod) syndicateElectionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_elections\".\"winner_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_elections\".\"deleted_at\""),
	)

	query := SyndicateElections(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_elections\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_elections\".*"})
	}

	return query
}

// ApplicantSyndicateJoinApplications retrieves all the syndicate_join_application's SyndicateJoinApplications with an executor via applicant_id column.
func (o *Player) ApplicantSyndicateJoinApplications(mods ...qm.QueryMod) syndicateJoinApplicationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_join_applications\".\"applicant_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_join_applications\".\"deleted_at\""),
	)

	query := SyndicateJoinApplications(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_join_applications\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_join_applications\".*"})
	}

	return query
}

// VoteBySyndicateMotionVotes retrieves all the syndicate_motion_vote's SyndicateMotionVotes with an executor via vote_by_id column.
func (o *Player) VoteBySyndicateMotionVotes(mods ...qm.QueryMod) syndicateMotionVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_motion_votes\".\"vote_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_motion_votes\".\"deleted_at\""),
	)

	query := SyndicateMotionVotes(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_motion_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_motion_votes\".*"})
	}

	return query
}

// IssuedBySyndicateMotions retrieves all the syndicate_motion's SyndicateMotions with an executor via issued_by_id column.
func (o *Player) IssuedBySyndicateMotions(mods ...qm.QueryMod) syndicateMotionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_motions\".\"issued_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_motions\".\"deleted_at\""),
	)

	query := SyndicateMotions(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_motions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_motions\".*"})
	}

	return query
}

// MemberSyndicateMotions retrieves all the syndicate_motion's SyndicateMotions with an executor via member_id column.
func (o *Player) MemberSyndicateMotions(mods ...qm.QueryMod) syndicateMotionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicate_motions\".\"member_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicate_motions\".\"deleted_at\""),
	)

	query := SyndicateMotions(queryMods...)
	queries.SetFrom(query.Query, "\"syndicate_motions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicate_motions\".*"})
	}

	return query
}

// AdminSyndicates retrieves all the syndicate's Syndicates with an executor via admin_id column.
func (o *Player) AdminSyndicates(mods ...qm.QueryMod) syndicateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicates\".\"admin_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicates\".\"deleted_at\""),
	)

	query := Syndicates(queryMods...)
	queries.SetFrom(query.Query, "\"syndicates\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicates\".*"})
	}

	return query
}

// CeoPlayerSyndicates retrieves all the syndicate's Syndicates with an executor via ceo_player_id column.
func (o *Player) CeoPlayerSyndicates(mods ...qm.QueryMod) syndicateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicates\".\"ceo_player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicates\".\"deleted_at\""),
	)

	query := Syndicates(queryMods...)
	queries.SetFrom(query.Query, "\"syndicates\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicates\".*"})
	}

	return query
}

// FoundedBySyndicates retrieves all the syndicate's Syndicates with an executor via founded_by_id column.
func (o *Player) FoundedBySyndicates(mods ...qm.QueryMod) syndicateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"syndicates\".\"founded_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"syndicates\".\"deleted_at\""),
	)

	query := Syndicates(queryMods...)
	queries.SetFrom(query.Query, "\"syndicates\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"syndicates\".*"})
	}

	return query
}

// SystemMessages retrieves all the system_message's SystemMessages with an executor.
func (o *Player) SystemMessages(mods ...qm.QueryMod) systemMessageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"system_messages\".\"player_id\"=?", o.ID),
	)

	query := SystemMessages(queryMods...)
	queries.SetFrom(query.Query, "\"system_messages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"system_messages\".*"})
	}

	return query
}

// SenderSystemMessages retrieves all the system_message's SystemMessages with an executor via sender_id column.
func (o *Player) SenderSystemMessages(mods ...qm.QueryMod) systemMessageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"system_messages\".\"sender_id\"=?", o.ID),
	)

	query := SystemMessages(queryMods...)
	queries.SetFrom(query.Query, "\"system_messages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"system_messages\".*"})
	}

	return query
}

// LoadCustomAvatar allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadCustomAvatar(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		if !queries.IsNil(object.CustomAvatarID) {
			args = append(args, object.CustomAvatarID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CustomAvatarID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CustomAvatarID) {
				args = append(args, obj.CustomAvatarID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`profile_custom_avatars`),
		qm.WhereIn(`profile_custom_avatars.id in ?`, args...),
		qmhelper.WhereIsNull(`profile_custom_avatars.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ProfileCustomAvatar")
	}

	var resultSlice []*ProfileCustomAvatar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ProfileCustomAvatar")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for profile_custom_avatars")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for profile_custom_avatars")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CustomAvatar = foreign
		if foreign.R == nil {
			foreign.R = &profileCustomAvatarR{}
		}
		foreign.R.CustomAvatarPlayers = append(foreign.R.CustomAvatarPlayers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CustomAvatarID, foreign.ID) {
				local.R.CustomAvatar = foreign
				if foreign.R == nil {
					foreign.R = &profileCustomAvatarR{}
				}
				foreign.R.CustomAvatarPlayers = append(foreign.R.CustomAvatarPlayers, local)
				break
			}
		}
	}

	return nil
}

// LoadFaction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadFaction(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		if !queries.IsNil(object.FactionID) {
			args = append(args, object.FactionID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FactionID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.FactionID) {
				args = append(args, obj.FactionID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`factions`),
		qm.WhereIn(`factions.id in ?`, args...),
		qmhelper.WhereIsNull(`factions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Faction")
	}

	var resultSlice []*Faction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Faction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factions")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Faction = foreign
		if foreign.R == nil {
			foreign.R = &factionR{}
		}
		foreign.R.Players = append(foreign.R.Players, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.FactionID, foreign.ID) {
				local.R.Faction = foreign
				if foreign.R == nil {
					foreign.R = &factionR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadProfileAvatar allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadProfileAvatar(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		if !queries.IsNil(object.ProfileAvatarID) {
			args = append(args, object.ProfileAvatarID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProfileAvatarID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProfileAvatarID) {
				args = append(args, obj.ProfileAvatarID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`profile_avatars`),
		qm.WhereIn(`profile_avatars.id in ?`, args...),
		qmhelper.WhereIsNull(`profile_avatars.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ProfileAvatar")
	}

	var resultSlice []*ProfileAvatar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ProfileAvatar")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for profile_avatars")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for profile_avatars")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProfileAvatar = foreign
		if foreign.R == nil {
			foreign.R = &profileAvatarR{}
		}
		foreign.R.Players = append(foreign.R.Players, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProfileAvatarID, foreign.ID) {
				local.R.ProfileAvatar = foreign
				if foreign.R == nil {
					foreign.R = &profileAvatarR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadRole allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadRole(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.RoleID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.RoleID {
					continue Outer
				}
			}

			args = append(args, obj.RoleID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`roles`),
		qm.WhereIn(`roles.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Role")
	}

	var resultSlice []*Role
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Role")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for roles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for roles")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Role = foreign
		if foreign.R == nil {
			foreign.R = &roleR{}
		}
		foreign.R.Players = append(foreign.R.Players, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.RoleID == foreign.ID {
				local.R.Role = foreign
				if foreign.R == nil {
					foreign.R = &roleR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadSyndicate allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadSyndicate(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		if !queries.IsNil(object.SyndicateID) {
			args = append(args, object.SyndicateID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SyndicateID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SyndicateID) {
				args = append(args, obj.SyndicateID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicates`),
		qm.WhereIn(`syndicates.id in ?`, args...),
		qmhelper.WhereIsNull(`syndicates.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Syndicate")
	}

	var resultSlice []*Syndicate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Syndicate")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for syndicates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicates")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Syndicate = foreign
		if foreign.R == nil {
			foreign.R = &syndicateR{}
		}
		foreign.R.Players = append(foreign.R.Players, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SyndicateID, foreign.ID) {
				local.R.Syndicate = foreign
				if foreign.R == nil {
					foreign.R = &syndicateR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadPlayerSettingsPreference allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (playerL) LoadPlayerSettingsPreference(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_settings_preferences`),
		qm.WhereIn(`player_settings_preferences.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PlayerSettingsPreference")
	}

	var resultSlice []*PlayerSettingsPreference
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PlayerSettingsPreference")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for player_settings_preferences")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_settings_preferences")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PlayerSettingsPreference = foreign
		if foreign.R == nil {
			foreign.R = &playerSettingsPreferenceR{}
		}
		foreign.R.Player = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerSettingsPreference = foreign
				if foreign.R == nil {
					foreign.R = &playerSettingsPreferenceR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadIDPlayerStat allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (playerL) LoadIDPlayerStat(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_stats`),
		qm.WhereIn(`player_stats.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PlayerStat")
	}

	var resultSlice []*PlayerStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PlayerStat")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for player_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_stats")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IDPlayerStat = foreign
		if foreign.R == nil {
			foreign.R = &playerStatR{}
		}
		foreign.R.IDPlayer = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.ID {
				local.R.IDPlayerStat = foreign
				if foreign.R == nil {
					foreign.R = &playerStatR{}
				}
				foreign.R.IDPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerAmmos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerAmmos(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`ammo`),
		qm.WhereIn(`ammo.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ammo")
	}

	var resultSlice []*Ammo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ammo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on ammo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for ammo")
	}

	if len(ammoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerAmmos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &ammoR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerAmmos = append(local.R.OwnerAmmos, foreign)
				if foreign.R == nil {
					foreign.R = &ammoR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadVotedByApplicationVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadVotedByApplicationVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`application_votes`),
		qm.WhereIn(`application_votes.voted_by_id in ?`, args...),
		qmhelper.WhereIsNull(`application_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load application_votes")
	}

	var resultSlice []*ApplicationVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice application_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on application_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for application_votes")
	}

	if len(applicationVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VotedByApplicationVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &applicationVoteR{}
			}
			foreign.R.VotedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.VotedByID {
				local.R.VotedByApplicationVotes = append(local.R.VotedByApplicationVotes, foreign)
				if foreign.R == nil {
					foreign.R = &applicationVoteR{}
				}
				foreign.R.VotedBy = local
				break
			}
		}
	}

	return nil
}

// LoadBattleAbilityOptInLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleAbilityOptInLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_ability_opt_in_logs`),
		qm.WhereIn(`battle_ability_opt_in_logs.player_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_ability_opt_in_logs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_ability_opt_in_logs")
	}

	var resultSlice []*BattleAbilityOptInLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_ability_opt_in_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_ability_opt_in_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_ability_opt_in_logs")
	}

	if len(battleAbilityOptInLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleAbilityOptInLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleAbilityOptInLogR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.BattleAbilityOptInLogs = append(local.R.BattleAbilityOptInLogs, foreign)
				if foreign.R == nil {
					foreign.R = &battleAbilityOptInLogR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBattleAbilityTriggers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleAbilityTriggers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_ability_triggers`),
		qm.WhereIn(`battle_ability_triggers.player_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_ability_triggers.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_ability_triggers")
	}

	var resultSlice []*BattleAbilityTrigger
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_ability_triggers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_ability_triggers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_ability_triggers")
	}

	if len(battleAbilityTriggerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleAbilityTriggers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleAbilityTriggerR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PlayerID) {
				local.R.BattleAbilityTriggers = append(local.R.BattleAbilityTriggers, foreign)
				if foreign.R == nil {
					foreign.R = &battleAbilityTriggerR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContracts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleContracts(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contracts`),
		qm.WhereIn(`battle_contracts.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contracts")
	}

	var resultSlice []*BattleContract
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contracts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contracts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contracts")
	}

	if len(battleContractAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContracts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContractR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.BattleContracts = append(local.R.BattleContracts, foreign)
				if foreign.R == nil {
					foreign.R = &battleContractR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContributions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleContributions(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contributions`),
		qm.WhereIn(`battle_contributions.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contributions")
	}

	var resultSlice []*BattleContribution
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contributions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contributions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contributions")
	}

	if len(battleContributionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContributions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContributionR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.BattleContributions = append(local.R.BattleContributions, foreign)
				if foreign.R == nil {
					foreign.R = &battleContributionR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleMechs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleMechs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_mechs`),
		qm.WhereIn(`battle_mechs.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_mechs")
	}

	var resultSlice []*BattleMech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_mechs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_mechs")
	}

	if len(battleMechAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleMechs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleMechR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleMechs = append(local.R.OwnerBattleMechs, foreign)
				if foreign.R == nil {
					foreign.R = &battleMechR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleQueues allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleQueues(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_queue`),
		qm.WhereIn(`battle_queue.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_queue")
	}

	var resultSlice []*BattleQueue
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_queue")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_queue")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_queue")
	}

	if len(battleQueueAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleQueues = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleQueueR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleQueues = append(local.R.OwnerBattleQueues, foreign)
				if foreign.R == nil {
					foreign.R = &battleQueueR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadPaidByBattleQueueFees allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPaidByBattleQueueFees(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_queue_fees`),
		qm.WhereIn(`battle_queue_fees.paid_by_id in ?`, args...),
		qmhelper.WhereIsNull(`battle_queue_fees.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_queue_fees")
	}

	var resultSlice []*BattleQueueFee
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_queue_fees")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_queue_fees")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_queue_fees")
	}

	if len(battleQueueFeeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PaidByBattleQueueFees = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleQueueFeeR{}
			}
			foreign.R.PaidBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PaidByID {
				local.R.PaidByBattleQueueFees = append(local.R.PaidByBattleQueueFees, foreign)
				if foreign.R == nil {
					foreign.R = &battleQueueFeeR{}
				}
				foreign.R.PaidBy = local
				break
			}
		}
	}

	return nil
}

// LoadBattles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattles(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"battles\".id, \"battles\".game_map_id, \"battles\".started_at, \"battles\".ended_at, \"battles\".battle_number, \"battles\".started_battle_seconds, \"battles\".ended_battle_seconds, \"battles\".arena_id, \"a\".\"player_id\""),
		qm.From("\"battles\""),
		qm.InnerJoin("\"battle_viewers\" as \"a\" on \"battles\".\"id\" = \"a\".\"battle_id\""),
		qm.WhereIn("\"a\".\"player_id\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battles")
	}

	var resultSlice []*Battle

	var localJoinCols []string
	for results.Next() {
		one := new(Battle)
		var localJoinCol string

		err = results.Scan(&one.ID, &one.GameMapID, &one.StartedAt, &one.EndedAt, &one.BattleNumber, &one.StartedBattleSeconds, &one.EndedBattleSeconds, &one.ArenaID, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for battles")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice battles")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battles")
	}

	if len(battleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Battles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleR{}
			}
			foreign.R.Players = append(foreign.R.Players, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.Battles = append(local.R.Battles, foreign)
				if foreign.R == nil {
					foreign.R = &battleR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleWins allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleWins(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_wins`),
		qm.WhereIn(`battle_wins.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_wins")
	}

	var resultSlice []*BattleWin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_wins")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_wins")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_wins")
	}

	if len(battleWinAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleWins = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleWinR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleWins = append(local.R.OwnerBattleWins, foreign)
				if foreign.R == nil {
					foreign.R = &battleWinR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadChatHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadChatHistories(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`chat_history`),
		qm.WhereIn(`chat_history.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load chat_history")
	}

	var resultSlice []*ChatHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice chat_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on chat_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chat_history")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ChatHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &chatHistoryR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.ChatHistories = append(local.R.ChatHistories, foreign)
				if foreign.R == nil {
					foreign.R = &chatHistoryR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerCollectionItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerCollectionItems(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`collection_items`),
		qm.WhereIn(`collection_items.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load collection_items")
	}

	var resultSlice []*CollectionItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice collection_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on collection_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for collection_items")
	}

	if len(collectionItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerCollectionItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &collectionItemR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerCollectionItems = append(local.R.OwnerCollectionItems, foreign)
				if foreign.R == nil {
					foreign.R = &collectionItemR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadConsumedByConsumedAbilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadConsumedByConsumedAbilities(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`consumed_abilities`),
		qm.WhereIn(`consumed_abilities.consumed_by in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load consumed_abilities")
	}

	var resultSlice []*ConsumedAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice consumed_abilities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on consumed_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for consumed_abilities")
	}

	if len(consumedAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ConsumedByConsumedAbilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &consumedAbilityR{}
			}
			foreign.R.ConsumedByPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ConsumedBy {
				local.R.ConsumedByConsumedAbilities = append(local.R.ConsumedByConsumedAbilities, foreign)
				if foreign.R == nil {
					foreign.R = &consumedAbilityR{}
				}
				foreign.R.ConsumedByPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadDevices allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadDevices(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`devices`),
		qm.WhereIn(`devices.player_id in ?`, args...),
		qmhelper.WhereIsNull(`devices.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load devices")
	}

	var resultSlice []*Device
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice devices")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on devices")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for devices")
	}

	if len(deviceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Devices = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &deviceR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.Devices = append(local.R.Devices, foreign)
				if foreign.R == nil {
					foreign.R = &deviceR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadMVPPlayerFactionStats allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadMVPPlayerFactionStats(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`faction_stats`),
		qm.WhereIn(`faction_stats.mvp_player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load faction_stats")
	}

	var resultSlice []*FactionStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice faction_stats")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on faction_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for faction_stats")
	}

	if len(factionStatAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MVPPlayerFactionStats = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &factionStatR{}
			}
			foreign.R.MVPPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MVPPlayerID) {
				local.R.MVPPlayerFactionStats = append(local.R.MVPPlayerFactionStats, foreign)
				if foreign.R == nil {
					foreign.R = &factionStatR{}
				}
				foreign.R.MVPPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerItemKeycardSales allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerItemKeycardSales(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_keycard_sales`),
		qm.WhereIn(`item_keycard_sales.owner_id in ?`, args...),
		qmhelper.WhereIsNull(`item_keycard_sales.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_keycard_sales")
	}

	var resultSlice []*ItemKeycardSale
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_keycard_sales")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_keycard_sales")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_keycard_sales")
	}

	if len(itemKeycardSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerItemKeycardSales = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemKeycardSaleR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerItemKeycardSales = append(local.R.OwnerItemKeycardSales, foreign)
				if foreign.R == nil {
					foreign.R = &itemKeycardSaleR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadSoldToItemKeycardSales allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadSoldToItemKeycardSales(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_keycard_sales`),
		qm.WhereIn(`item_keycard_sales.sold_to in ?`, args...),
		qmhelper.WhereIsNull(`item_keycard_sales.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_keycard_sales")
	}

	var resultSlice []*ItemKeycardSale
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_keycard_sales")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_keycard_sales")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_keycard_sales")
	}

	if len(itemKeycardSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SoldToItemKeycardSales = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemKeycardSaleR{}
			}
			foreign.R.SoldToPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SoldTo) {
				local.R.SoldToItemKeycardSales = append(local.R.SoldToItemKeycardSales, foreign)
				if foreign.R == nil {
					foreign.R = &itemKeycardSaleR{}
				}
				foreign.R.SoldToPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerItemSales allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerItemSales(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_sales`),
		qm.WhereIn(`item_sales.owner_id in ?`, args...),
		qmhelper.WhereIsNull(`item_sales.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_sales")
	}

	var resultSlice []*ItemSale
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_sales")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_sales")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_sales")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerItemSales = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemSaleR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerItemSales = append(local.R.OwnerItemSales, foreign)
				if foreign.R == nil {
					foreign.R = &itemSaleR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadSoldToItemSales allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadSoldToItemSales(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_sales`),
		qm.WhereIn(`item_sales.sold_to in ?`, args...),
		qmhelper.WhereIsNull(`item_sales.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_sales")
	}

	var resultSlice []*ItemSale
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_sales")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_sales")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_sales")
	}

	if len(itemSaleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SoldToItemSales = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemSaleR{}
			}
			foreign.R.SoldToPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SoldTo) {
				local.R.SoldToItemSales = append(local.R.SoldToItemSales, foreign)
				if foreign.R == nil {
					foreign.R = &itemSaleR{}
				}
				foreign.R.SoldToPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadBidderItemSalesBidHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBidderItemSalesBidHistories(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_sales_bid_history`),
		qm.WhereIn(`item_sales_bid_history.bidder_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_sales_bid_history")
	}

	var resultSlice []*ItemSalesBidHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_sales_bid_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_sales_bid_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_sales_bid_history")
	}

	if len(itemSalesBidHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BidderItemSalesBidHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemSalesBidHistoryR{}
			}
			foreign.R.Bidder = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.BidderID {
				local.R.BidderItemSalesBidHistories = append(local.R.BidderItemSalesBidHistories, foreign)
				if foreign.R == nil {
					foreign.R = &itemSalesBidHistoryR{}
				}
				foreign.R.Bidder = local
				break
			}
		}
	}

	return nil
}

// LoadUserMarketplaceEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadUserMarketplaceEvents(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`marketplace_events`),
		qm.WhereIn(`marketplace_events.user_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load marketplace_events")
	}

	var resultSlice []*MarketplaceEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice marketplace_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on marketplace_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for marketplace_events")
	}

	if len(marketplaceEventAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserMarketplaceEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &marketplaceEventR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserMarketplaceEvents = append(local.R.UserMarketplaceEvents, foreign)
				if foreign.R == nil {
					foreign.R = &marketplaceEventR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadTriggeredByMechAbilityTriggerLogsOlds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadTriggeredByMechAbilityTriggerLogsOlds(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mech_ability_trigger_logs_old`),
		qm.WhereIn(`mech_ability_trigger_logs_old.triggered_by_id in ?`, args...),
		qmhelper.WhereIsNull(`mech_ability_trigger_logs_old.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mech_ability_trigger_logs_old")
	}

	var resultSlice []*MechAbilityTriggerLogsOld
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mech_ability_trigger_logs_old")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mech_ability_trigger_logs_old")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mech_ability_trigger_logs_old")
	}

	if len(mechAbilityTriggerLogsOldAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.TriggeredByMechAbilityTriggerLogsOlds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mechAbilityTriggerLogsOldR{}
			}
			foreign.R.TriggeredBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.TriggeredByID {
				local.R.TriggeredByMechAbilityTriggerLogsOlds = append(local.R.TriggeredByMechAbilityTriggerLogsOlds, foreign)
				if foreign.R == nil {
					foreign.R = &mechAbilityTriggerLogsOldR{}
				}
				foreign.R.TriggeredBy = local
				break
			}
		}
	}

	return nil
}

// LoadTriggeredByMechMoveCommandLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadTriggeredByMechMoveCommandLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mech_move_command_logs`),
		qm.WhereIn(`mech_move_command_logs.triggered_by_id in ?`, args...),
		qmhelper.WhereIsNull(`mech_move_command_logs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mech_move_command_logs")
	}

	var resultSlice []*MechMoveCommandLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mech_move_command_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mech_move_command_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mech_move_command_logs")
	}

	if len(mechMoveCommandLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.TriggeredByMechMoveCommandLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mechMoveCommandLogR{}
			}
			foreign.R.TriggeredBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.TriggeredByID {
				local.R.TriggeredByMechMoveCommandLogs = append(local.R.TriggeredByMechMoveCommandLogs, foreign)
				if foreign.R == nil {
					foreign.R = &mechMoveCommandLogR{}
				}
				foreign.R.TriggeredBy = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerMechsOlds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerMechsOlds(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mechs_old`),
		qm.WhereIn(`mechs_old.owner_id in ?`, args...),
		qmhelper.WhereIsNull(`mechs_old.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mechs_old")
	}

	var resultSlice []*MechsOld
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mechs_old")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mechs_old")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mechs_old")
	}

	if len(mechsOldAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerMechsOlds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mechsOldR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerMechsOlds = append(local.R.OwnerMechsOlds, foreign)
				if foreign.R == nil {
					foreign.R = &mechsOldR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadLookupPlayerModActionAudits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadLookupPlayerModActionAudits(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mod_action_audit`),
		qm.WhereIn(`mod_action_audit.lookup_player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mod_action_audit")
	}

	var resultSlice []*ModActionAudit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mod_action_audit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mod_action_audit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mod_action_audit")
	}

	if len(modActionAuditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LookupPlayerModActionAudits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &modActionAuditR{}
			}
			foreign.R.LookupPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.LookupPlayerID) {
				local.R.LookupPlayerModActionAudits = append(local.R.LookupPlayerModActionAudits, foreign)
				if foreign.R == nil {
					foreign.R = &modActionAuditR{}
				}
				foreign.R.LookupPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadModModActionAudits allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadModModActionAudits(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mod_action_audit`),
		qm.WhereIn(`mod_action_audit.mod_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mod_action_audit")
	}

	var resultSlice []*ModActionAudit
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mod_action_audit")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mod_action_audit")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mod_action_audit")
	}

	if len(modActionAuditAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ModModActionAudits = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &modActionAuditR{}
			}
			foreign.R.Mod = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ModID {
				local.R.ModModActionAudits = append(local.R.ModModActionAudits, foreign)
				if foreign.R == nil {
					foreign.R = &modActionAuditR{}
				}
				foreign.R.Mod = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerPlayerAbilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerPlayerAbilities(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_abilities`),
		qm.WhereIn(`player_abilities.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_abilities")
	}

	var resultSlice []*PlayerAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_abilities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_abilities")
	}

	if len(playerAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerPlayerAbilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerAbilityR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerPlayerAbilities = append(local.R.OwnerPlayerAbilities, foreign)
				if foreign.R == nil {
					foreign.R = &playerAbilityR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerActiveLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerActiveLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_active_logs`),
		qm.WhereIn(`player_active_logs.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_active_logs")
	}

	var resultSlice []*PlayerActiveLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_active_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_active_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_active_logs")
	}

	if len(playerActiveLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerActiveLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerActiveLogR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerActiveLogs = append(local.R.PlayerActiveLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerActiveLogR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBannedByPlayerBans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBannedByPlayerBans(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_bans`),
		qm.WhereIn(`player_bans.banned_by_id in ?`, args...),
		qmhelper.WhereIsNull(`player_bans.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_bans")
	}

	var resultSlice []*PlayerBan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_bans")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_bans")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_bans")
	}

	if len(playerBanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BannedByPlayerBans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerBanR{}
			}
			foreign.R.BannedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.BannedByID {
				local.R.BannedByPlayerBans = append(local.R.BannedByPlayerBans, foreign)
				if foreign.R == nil {
					foreign.R = &playerBanR{}
				}
				foreign.R.BannedBy = local
				break
			}
		}
	}

	return nil
}

// LoadBannedPlayerPlayerBans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBannedPlayerPlayerBans(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_bans`),
		qm.WhereIn(`player_bans.banned_player_id in ?`, args...),
		qmhelper.WhereIsNull(`player_bans.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_bans")
	}

	var resultSlice []*PlayerBan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_bans")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_bans")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_bans")
	}

	if len(playerBanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BannedPlayerPlayerBans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerBanR{}
			}
			foreign.R.BannedPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.BannedPlayerID {
				local.R.BannedPlayerPlayerBans = append(local.R.BannedPlayerPlayerBans, foreign)
				if foreign.R == nil {
					foreign.R = &playerBanR{}
				}
				foreign.R.BannedPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerFingerprints allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerFingerprints(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_fingerprints`),
		qm.WhereIn(`player_fingerprints.player_id in ?`, args...),
		qmhelper.WhereIsNull(`player_fingerprints.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_fingerprints")
	}

	var resultSlice []*PlayerFingerprint
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_fingerprints")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_fingerprints")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_fingerprints")
	}

	if len(playerFingerprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerFingerprints = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerFingerprintR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerFingerprints = append(local.R.PlayerFingerprints, foreign)
				if foreign.R == nil {
					foreign.R = &playerFingerprintR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerIps allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerIps(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_ips`),
		qm.WhereIn(`player_ips.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_ips")
	}

	var resultSlice []*PlayerIP
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_ips")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_ips")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_ips")
	}

	if len(playerIPAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerIps = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerIPR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerIps = append(local.R.PlayerIps, foreign)
				if foreign.R == nil {
					foreign.R = &playerIPR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerKeycards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerKeycards(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_keycards`),
		qm.WhereIn(`player_keycards.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_keycards")
	}

	var resultSlice []*PlayerKeycard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_keycards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_keycards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_keycards")
	}

	if len(playerKeycardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerKeycards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerKeycardR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerKeycards = append(local.R.PlayerKeycards, foreign)
				if foreign.R == nil {
					foreign.R = &playerKeycardR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerKillLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerKillLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_kill_log`),
		qm.WhereIn(`player_kill_log.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_kill_log")
	}

	var resultSlice []*PlayerKillLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_kill_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_kill_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_kill_log")
	}

	if len(playerKillLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerKillLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerKillLogR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerKillLogs = append(local.R.PlayerKillLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerKillLogR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerLanguages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerLanguages(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_languages`),
		qm.WhereIn(`player_languages.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_languages")
	}

	var resultSlice []*PlayerLanguage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_languages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_languages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_languages")
	}

	if len(playerLanguageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerLanguages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerLanguageR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerLanguages = append(local.R.PlayerLanguages, foreign)
				if foreign.R == nil {
					foreign.R = &playerLanguageR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerMechRepairSlots allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerMechRepairSlots(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_mech_repair_slots`),
		qm.WhereIn(`player_mech_repair_slots.player_id in ?`, args...),
		qmhelper.WhereIsNull(`player_mech_repair_slots.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_mech_repair_slots")
	}

	var resultSlice []*PlayerMechRepairSlot
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_mech_repair_slots")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_mech_repair_slots")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_mech_repair_slots")
	}

	if len(playerMechRepairSlotAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerMechRepairSlots = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerMechRepairSlotR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerMechRepairSlots = append(local.R.PlayerMechRepairSlots, foreign)
				if foreign.R == nil {
					foreign.R = &playerMechRepairSlotR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerMultipliers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerMultipliers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_multipliers`),
		qm.WhereIn(`player_multipliers.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_multipliers")
	}

	var resultSlice []*PlayerMultiplier
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_multipliers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_multipliers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_multipliers")
	}

	if len(playerMultiplierAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerMultipliers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerMultiplierR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerMultipliers = append(local.R.PlayerMultipliers, foreign)
				if foreign.R == nil {
					foreign.R = &playerMultiplierR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerPreferences allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerPreferences(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_preferences`),
		qm.WhereIn(`player_preferences.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_preferences")
	}

	var resultSlice []*PlayerPreference
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_preferences")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_preferences")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_preferences")
	}

	if len(playerPreferenceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerPreferences = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerPreferenceR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerPreferences = append(local.R.PlayerPreferences, foreign)
				if foreign.R == nil {
					foreign.R = &playerPreferenceR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerSpoilsOfWars allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerSpoilsOfWars(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_spoils_of_war`),
		qm.WhereIn(`player_spoils_of_war.player_id in ?`, args...),
		qmhelper.WhereIsNull(`player_spoils_of_war.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_spoils_of_war")
	}

	var resultSlice []*PlayerSpoilsOfWar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_spoils_of_war")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_spoils_of_war")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_spoils_of_war")
	}

	if len(playerSpoilsOfWarAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerSpoilsOfWars = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerSpoilsOfWarR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerSpoilsOfWars = append(local.R.PlayerSpoilsOfWars, foreign)
				if foreign.R == nil {
					foreign.R = &playerSpoilsOfWarR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayersFeatures allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayersFeatures(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players_features`),
		qm.WhereIn(`players_features.player_id in ?`, args...),
		qmhelper.WhereIsNull(`players_features.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players_features")
	}

	var resultSlice []*PlayersFeature
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players_features")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players_features")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players_features")
	}

	if len(playersFeatureAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayersFeatures = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playersFeatureR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayersFeatures = append(local.R.PlayersFeatures, foreign)
				if foreign.R == nil {
					foreign.R = &playersFeatureR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayersObtainedQuests allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayersObtainedQuests(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players_obtained_quests`),
		qm.WhereIn(`players_obtained_quests.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players_obtained_quests")
	}

	var resultSlice []*PlayersObtainedQuest
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players_obtained_quests")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players_obtained_quests")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players_obtained_quests")
	}

	if len(playersObtainedQuestAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayersObtainedQuests = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playersObtainedQuestR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayersObtainedQuests = append(local.R.PlayersObtainedQuests, foreign)
				if foreign.R == nil {
					foreign.R = &playersObtainedQuestR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayersProfileAvatars allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayersProfileAvatars(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players_profile_avatars`),
		qm.WhereIn(`players_profile_avatars.player_id in ?`, args...),
		qmhelper.WhereIsNull(`players_profile_avatars.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players_profile_avatars")
	}

	var resultSlice []*PlayersProfileAvatar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players_profile_avatars")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players_profile_avatars")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players_profile_avatars")
	}

	if len(playersProfileAvatarAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayersProfileAvatars = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playersProfileAvatarR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayersProfileAvatars = append(local.R.PlayersProfileAvatars, foreign)
				if foreign.R == nil {
					foreign.R = &playersProfileAvatarR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayersPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayersPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players_punish_votes`),
		qm.WhereIn(`players_punish_votes.player_id in ?`, args...),
		qmhelper.WhereIsNull(`players_punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players_punish_votes")
	}

	var resultSlice []*PlayersPunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players_punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players_punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players_punish_votes")
	}

	if len(playersPunishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayersPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playersPunishVoteR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayersPunishVotes = append(local.R.PlayersPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &playersPunishVoteR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadProfileCustomAvatars allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadProfileCustomAvatars(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`profile_custom_avatars`),
		qm.WhereIn(`profile_custom_avatars.player_id in ?`, args...),
		qmhelper.WhereIsNull(`profile_custom_avatars.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load profile_custom_avatars")
	}

	var resultSlice []*ProfileCustomAvatar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice profile_custom_avatars")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on profile_custom_avatars")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for profile_custom_avatars")
	}

	if len(profileCustomAvatarAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProfileCustomAvatars = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &profileCustomAvatarR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.ProfileCustomAvatars = append(local.R.ProfileCustomAvatars, foreign)
				if foreign.R == nil {
					foreign.R = &profileCustomAvatarR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadVoteByPlayerPunishVoteInstantPassRecords allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadVoteByPlayerPunishVoteInstantPassRecords(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_vote_instant_pass_records`),
		qm.WhereIn(`punish_vote_instant_pass_records.vote_by_player_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_vote_instant_pass_records.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_vote_instant_pass_records")
	}

	var resultSlice []*PunishVoteInstantPassRecord
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_vote_instant_pass_records")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_vote_instant_pass_records")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_vote_instant_pass_records")
	}

	if len(punishVoteInstantPassRecordAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VoteByPlayerPunishVoteInstantPassRecords = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteInstantPassRecordR{}
			}
			foreign.R.VoteByPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.VoteByPlayerID {
				local.R.VoteByPlayerPunishVoteInstantPassRecords = append(local.R.VoteByPlayerPunishVoteInstantPassRecords, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteInstantPassRecordR{}
				}
				foreign.R.VoteByPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadInstantPassByPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadInstantPassByPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.instant_pass_by_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.InstantPassByPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.InstantPassBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.InstantPassByID) {
				local.R.InstantPassByPunishVotes = append(local.R.InstantPassByPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.InstantPassBy = local
				break
			}
		}
	}

	return nil
}

// LoadIssuedByPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadIssuedByPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.issued_by_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.IssuedByPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.IssuedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.IssuedByID {
				local.R.IssuedByPunishVotes = append(local.R.IssuedByPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.IssuedBy = local
				break
			}
		}
	}

	return nil
}

// LoadReportedPlayerPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadReportedPlayerPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.reported_player_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReportedPlayerPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.ReportedPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReportedPlayerID {
				local.R.ReportedPlayerPunishVotes = append(local.R.ReportedPlayerPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.ReportedPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadRepairAgents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadRepairAgents(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`repair_agents`),
		qm.WhereIn(`repair_agents.player_id in ?`, args...),
		qmhelper.WhereIsNull(`repair_agents.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load repair_agents")
	}

	var resultSlice []*RepairAgent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice repair_agents")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on repair_agents")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for repair_agents")
	}

	if len(repairAgentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RepairAgents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &repairAgentR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.RepairAgents = append(local.R.RepairAgents, foreign)
				if foreign.R == nil {
					foreign.R = &repairAgentR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadOfferedByRepairOffers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOfferedByRepairOffers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`repair_offers`),
		qm.WhereIn(`repair_offers.offered_by_id in ?`, args...),
		qmhelper.WhereIsNull(`repair_offers.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load repair_offers")
	}

	var resultSlice []*RepairOffer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice repair_offers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on repair_offers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for repair_offers")
	}

	if len(repairOfferAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OfferedByRepairOffers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &repairOfferR{}
			}
			foreign.R.OfferedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.OfferedByID) {
				local.R.OfferedByRepairOffers = append(local.R.OfferedByRepairOffers, foreign)
				if foreign.R == nil {
					foreign.R = &repairOfferR{}
				}
				foreign.R.OfferedBy = local
				break
			}
		}
	}

	return nil
}

// LoadSyndicateCommittees allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadSyndicateCommittees(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_committees`),
		qm.WhereIn(`syndicate_committees.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_committees")
	}

	var resultSlice []*SyndicateCommittee
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_committees")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_committees")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_committees")
	}

	if len(syndicateCommitteeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SyndicateCommittees = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateCommitteeR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.SyndicateCommittees = append(local.R.SyndicateCommittees, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateCommitteeR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadSyndicateDirectors allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadSyndicateDirectors(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_directors`),
		qm.WhereIn(`syndicate_directors.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_directors")
	}

	var resultSlice []*SyndicateDirector
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_directors")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_directors")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_directors")
	}

	if len(syndicateDirectorAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SyndicateDirectors = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateDirectorR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.SyndicateDirectors = append(local.R.SyndicateDirectors, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateDirectorR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadCandidateSyndicateElectionCandidates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadCandidateSyndicateElectionCandidates(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_election_candidates`),
		qm.WhereIn(`syndicate_election_candidates.candidate_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_election_candidates.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_election_candidates")
	}

	var resultSlice []*SyndicateElectionCandidate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_election_candidates")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_election_candidates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_election_candidates")
	}

	if len(syndicateElectionCandidateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CandidateSyndicateElectionCandidates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateElectionCandidateR{}
			}
			foreign.R.Candidate = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CandidateID {
				local.R.CandidateSyndicateElectionCandidates = append(local.R.CandidateSyndicateElectionCandidates, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateElectionCandidateR{}
				}
				foreign.R.Candidate = local
				break
			}
		}
	}

	return nil
}

// LoadVotedBySyndicateElectionVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadVotedBySyndicateElectionVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_election_votes`),
		qm.WhereIn(`syndicate_election_votes.voted_by_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_election_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_election_votes")
	}

	var resultSlice []*SyndicateElectionVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_election_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_election_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_election_votes")
	}

	if len(syndicateElectionVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VotedBySyndicateElectionVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateElectionVoteR{}
			}
			foreign.R.VotedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.VotedByID {
				local.R.VotedBySyndicateElectionVotes = append(local.R.VotedBySyndicateElectionVotes, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateElectionVoteR{}
				}
				foreign.R.VotedBy = local
				break
			}
		}
	}

	return nil
}

// LoadVotedForCandidateSyndicateElectionVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadVotedForCandidateSyndicateElectionVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_election_votes`),
		qm.WhereIn(`syndicate_election_votes.voted_for_candidate_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_election_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_election_votes")
	}

	var resultSlice []*SyndicateElectionVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_election_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_election_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_election_votes")
	}

	if len(syndicateElectionVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VotedForCandidateSyndicateElectionVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateElectionVoteR{}
			}
			foreign.R.VotedForCandidate = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.VotedForCandidateID {
				local.R.VotedForCandidateSyndicateElectionVotes = append(local.R.VotedForCandidateSyndicateElectionVotes, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateElectionVoteR{}
				}
				foreign.R.VotedForCandidate = local
				break
			}
		}
	}

	return nil
}

// LoadWinnerSyndicateElections allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadWinnerSyndicateElections(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_elections`),
		qm.WhereIn(`syndicate_elections.winner_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_elections.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_elections")
	}

	var resultSlice []*SyndicateElection
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_elections")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_elections")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_elections")
	}

	if len(syndicateElectionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.WinnerSyndicateElections = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateElectionR{}
			}
			foreign.R.Winner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.WinnerID) {
				local.R.WinnerSyndicateElections = append(local.R.WinnerSyndicateElections, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateElectionR{}
				}
				foreign.R.Winner = local
				break
			}
		}
	}

	return nil
}

// LoadApplicantSyndicateJoinApplications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadApplicantSyndicateJoinApplications(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_join_applications`),
		qm.WhereIn(`syndicate_join_applications.applicant_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_join_applications.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_join_applications")
	}

	var resultSlice []*SyndicateJoinApplication
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_join_applications")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_join_applications")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_join_applications")
	}

	if len(syndicateJoinApplicationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ApplicantSyndicateJoinApplications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateJoinApplicationR{}
			}
			foreign.R.Applicant = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ApplicantID {
				local.R.ApplicantSyndicateJoinApplications = append(local.R.ApplicantSyndicateJoinApplications, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateJoinApplicationR{}
				}
				foreign.R.Applicant = local
				break
			}
		}
	}

	return nil
}

// LoadVoteBySyndicateMotionVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadVoteBySyndicateMotionVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_motion_votes`),
		qm.WhereIn(`syndicate_motion_votes.vote_by_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_motion_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_motion_votes")
	}

	var resultSlice []*SyndicateMotionVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_motion_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_motion_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_motion_votes")
	}

	if len(syndicateMotionVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VoteBySyndicateMotionVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateMotionVoteR{}
			}
			foreign.R.VoteBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.VoteByID {
				local.R.VoteBySyndicateMotionVotes = append(local.R.VoteBySyndicateMotionVotes, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateMotionVoteR{}
				}
				foreign.R.VoteBy = local
				break
			}
		}
	}

	return nil
}

// LoadIssuedBySyndicateMotions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadIssuedBySyndicateMotions(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_motions`),
		qm.WhereIn(`syndicate_motions.issued_by_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_motions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_motions")
	}

	var resultSlice []*SyndicateMotion
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_motions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_motions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_motions")
	}

	if len(syndicateMotionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.IssuedBySyndicateMotions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateMotionR{}
			}
			foreign.R.IssuedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.IssuedByID {
				local.R.IssuedBySyndicateMotions = append(local.R.IssuedBySyndicateMotions, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateMotionR{}
				}
				foreign.R.IssuedBy = local
				break
			}
		}
	}

	return nil
}

// LoadMemberSyndicateMotions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadMemberSyndicateMotions(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicate_motions`),
		qm.WhereIn(`syndicate_motions.member_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicate_motions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicate_motions")
	}

	var resultSlice []*SyndicateMotion
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicate_motions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicate_motions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicate_motions")
	}

	if len(syndicateMotionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MemberSyndicateMotions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateMotionR{}
			}
			foreign.R.Member = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MemberID) {
				local.R.MemberSyndicateMotions = append(local.R.MemberSyndicateMotions, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateMotionR{}
				}
				foreign.R.Member = local
				break
			}
		}
	}

	return nil
}

// LoadAdminSyndicates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadAdminSyndicates(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicates`),
		qm.WhereIn(`syndicates.admin_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicates.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicates")
	}

	var resultSlice []*Syndicate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicates")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicates")
	}

	if len(syndicateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AdminSyndicates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateR{}
			}
			foreign.R.Admin = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.AdminID) {
				local.R.AdminSyndicates = append(local.R.AdminSyndicates, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateR{}
				}
				foreign.R.Admin = local
				break
			}
		}
	}

	return nil
}

// LoadCeoPlayerSyndicates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadCeoPlayerSyndicates(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicates`),
		qm.WhereIn(`syndicates.ceo_player_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicates.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicates")
	}

	var resultSlice []*Syndicate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicates")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicates")
	}

	if len(syndicateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CeoPlayerSyndicates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateR{}
			}
			foreign.R.CeoPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CeoPlayerID) {
				local.R.CeoPlayerSyndicates = append(local.R.CeoPlayerSyndicates, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateR{}
				}
				foreign.R.CeoPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadFoundedBySyndicates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadFoundedBySyndicates(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`syndicates`),
		qm.WhereIn(`syndicates.founded_by_id in ?`, args...),
		qmhelper.WhereIsNull(`syndicates.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load syndicates")
	}

	var resultSlice []*Syndicate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice syndicates")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on syndicates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for syndicates")
	}

	if len(syndicateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FoundedBySyndicates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &syndicateR{}
			}
			foreign.R.FoundedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.FoundedByID {
				local.R.FoundedBySyndicates = append(local.R.FoundedBySyndicates, foreign)
				if foreign.R == nil {
					foreign.R = &syndicateR{}
				}
				foreign.R.FoundedBy = local
				break
			}
		}
	}

	return nil
}

// LoadSystemMessages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadSystemMessages(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`system_messages`),
		qm.WhereIn(`system_messages.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load system_messages")
	}

	var resultSlice []*SystemMessage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice system_messages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on system_messages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for system_messages")
	}

	if len(systemMessageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SystemMessages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &systemMessageR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.SystemMessages = append(local.R.SystemMessages, foreign)
				if foreign.R == nil {
					foreign.R = &systemMessageR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadSenderSystemMessages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadSenderSystemMessages(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`system_messages`),
		qm.WhereIn(`system_messages.sender_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load system_messages")
	}

	var resultSlice []*SystemMessage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice system_messages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on system_messages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for system_messages")
	}

	if len(systemMessageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SenderSystemMessages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &systemMessageR{}
			}
			foreign.R.Sender = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SenderID {
				local.R.SenderSystemMessages = append(local.R.SenderSystemMessages, foreign)
				if foreign.R == nil {
					foreign.R = &systemMessageR{}
				}
				foreign.R.Sender = local
				break
			}
		}
	}

	return nil
}

// SetCustomAvatar of the player to the related item.
// Sets o.R.CustomAvatar to related.
// Adds o to related.R.CustomAvatarPlayers.
func (o *Player) SetCustomAvatar(exec boil.Executor, insert bool, related *ProfileCustomAvatar) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"custom_avatar_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CustomAvatarID, related.ID)
	if o.R == nil {
		o.R = &playerR{
			CustomAvatar: related,
		}
	} else {
		o.R.CustomAvatar = related
	}

	if related.R == nil {
		related.R = &profileCustomAvatarR{
			CustomAvatarPlayers: PlayerSlice{o},
		}
	} else {
		related.R.CustomAvatarPlayers = append(related.R.CustomAvatarPlayers, o)
	}

	return nil
}

// RemoveCustomAvatar relationship.
// Sets o.R.CustomAvatar to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Player) RemoveCustomAvatar(exec boil.Executor, related *ProfileCustomAvatar) error {
	var err error

	queries.SetScanner(&o.CustomAvatarID, nil)
	if _, err = o.Update(exec, boil.Whitelist("custom_avatar_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CustomAvatar = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CustomAvatarPlayers {
		if queries.Equal(o.CustomAvatarID, ri.CustomAvatarID) {
			continue
		}

		ln := len(related.R.CustomAvatarPlayers)
		if ln > 1 && i < ln-1 {
			related.R.CustomAvatarPlayers[i] = related.R.CustomAvatarPlayers[ln-1]
		}
		related.R.CustomAvatarPlayers = related.R.CustomAvatarPlayers[:ln-1]
		break
	}
	return nil
}

// SetFaction of the player to the related item.
// Sets o.R.Faction to related.
// Adds o to related.R.Players.
func (o *Player) SetFaction(exec boil.Executor, insert bool, related *Faction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.FactionID, related.ID)
	if o.R == nil {
		o.R = &playerR{
			Faction: related,
		}
	} else {
		o.R.Faction = related
	}

	if related.R == nil {
		related.R = &factionR{
			Players: PlayerSlice{o},
		}
	} else {
		related.R.Players = append(related.R.Players, o)
	}

	return nil
}

// RemoveFaction relationship.
// Sets o.R.Faction to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Player) RemoveFaction(exec boil.Executor, related *Faction) error {
	var err error

	queries.SetScanner(&o.FactionID, nil)
	if _, err = o.Update(exec, boil.Whitelist("faction_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Faction = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Players {
		if queries.Equal(o.FactionID, ri.FactionID) {
			continue
		}

		ln := len(related.R.Players)
		if ln > 1 && i < ln-1 {
			related.R.Players[i] = related.R.Players[ln-1]
		}
		related.R.Players = related.R.Players[:ln-1]
		break
	}
	return nil
}

// SetProfileAvatar of the player to the related item.
// Sets o.R.ProfileAvatar to related.
// Adds o to related.R.Players.
func (o *Player) SetProfileAvatar(exec boil.Executor, insert bool, related *ProfileAvatar) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"profile_avatar_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProfileAvatarID, related.ID)
	if o.R == nil {
		o.R = &playerR{
			ProfileAvatar: related,
		}
	} else {
		o.R.ProfileAvatar = related
	}

	if related.R == nil {
		related.R = &profileAvatarR{
			Players: PlayerSlice{o},
		}
	} else {
		related.R.Players = append(related.R.Players, o)
	}

	return nil
}

// RemoveProfileAvatar relationship.
// Sets o.R.ProfileAvatar to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Player) RemoveProfileAvatar(exec boil.Executor, related *ProfileAvatar) error {
	var err error

	queries.SetScanner(&o.ProfileAvatarID, nil)
	if _, err = o.Update(exec, boil.Whitelist("profile_avatar_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProfileAvatar = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Players {
		if queries.Equal(o.ProfileAvatarID, ri.ProfileAvatarID) {
			continue
		}

		ln := len(related.R.Players)
		if ln > 1 && i < ln-1 {
			related.R.Players[i] = related.R.Players[ln-1]
		}
		related.R.Players = related.R.Players[:ln-1]
		break
	}
	return nil
}

// SetRole of the player to the related item.
// Sets o.R.Role to related.
// Adds o to related.R.Players.
func (o *Player) SetRole(exec boil.Executor, insert bool, related *Role) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"role_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.RoleID = related.ID
	if o.R == nil {
		o.R = &playerR{
			Role: related,
		}
	} else {
		o.R.Role = related
	}

	if related.R == nil {
		related.R = &roleR{
			Players: PlayerSlice{o},
		}
	} else {
		related.R.Players = append(related.R.Players, o)
	}

	return nil
}

// SetSyndicate of the player to the related item.
// Sets o.R.Syndicate to related.
// Adds o to related.R.Players.
func (o *Player) SetSyndicate(exec boil.Executor, insert bool, related *Syndicate) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"syndicate_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SyndicateID, related.ID)
	if o.R == nil {
		o.R = &playerR{
			Syndicate: related,
		}
	} else {
		o.R.Syndicate = related
	}

	if related.R == nil {
		related.R = &syndicateR{
			Players: PlayerSlice{o},
		}
	} else {
		related.R.Players = append(related.R.Players, o)
	}

	return nil
}

// RemoveSyndicate relationship.
// Sets o.R.Syndicate to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Player) RemoveSyndicate(exec boil.Executor, related *Syndicate) error {
	var err error

	queries.SetScanner(&o.SyndicateID, nil)
	if _, err = o.Update(exec, boil.Whitelist("syndicate_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Syndicate = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Players {
		if queries.Equal(o.SyndicateID, ri.SyndicateID) {
			continue
		}

		ln := len(related.R.Players)
		if ln > 1 && i < ln-1 {
			related.R.Players[i] = related.R.Players[ln-1]
		}
		related.R.Players = related.R.Players[:ln-1]
		break
	}
	return nil
}

// SetPlayerSettingsPreference of the player to the related item.
// Sets o.R.PlayerSettingsPreference to related.
// Adds o to related.R.Player.
func (o *Player) SetPlayerSettingsPreference(exec boil.Executor, insert bool, related *PlayerSettingsPreference) error {
	var err error

	if insert {
		related.PlayerID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"player_settings_preferences\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
			strmangle.WhereClause("\"", "\"", 2, playerSettingsPreferencePrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PlayerID = o.ID

	}

	if o.R == nil {
		o.R = &playerR{
			PlayerSettingsPreference: related,
		}
	} else {
		o.R.PlayerSettingsPreference = related
	}

	if related.R == nil {
		related.R = &playerSettingsPreferenceR{
			Player: o,
		}
	} else {
		related.R.Player = o
	}
	return nil
}

// SetIDPlayerStat of the player to the related item.
// Sets o.R.IDPlayerStat to related.
// Adds o to related.R.IDPlayer.
func (o *Player) SetIDPlayerStat(exec boil.Executor, insert bool, related *PlayerStat) error {
	var err error

	if insert {
		related.ID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"player_stats\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"id"}),
			strmangle.WhereClause("\"", "\"", 2, playerStatPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.ID = o.ID

	}

	if o.R == nil {
		o.R = &playerR{
			IDPlayerStat: related,
		}
	} else {
		o.R.IDPlayerStat = related
	}

	if related.R == nil {
		related.R = &playerStatR{
			IDPlayer: o,
		}
	} else {
		related.R.IDPlayer = o
	}
	return nil
}

// AddOwnerAmmos adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerAmmos.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerAmmos(exec boil.Executor, insert bool, related ...*Ammo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"ammo\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, ammoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BlueprintID, rel.OwnerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerAmmos: related,
		}
	} else {
		o.R.OwnerAmmos = append(o.R.OwnerAmmos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &ammoR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddVotedByApplicationVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.VotedByApplicationVotes.
// Sets related.R.VotedBy appropriately.
func (o *Player) AddVotedByApplicationVotes(exec boil.Executor, insert bool, related ...*ApplicationVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.VotedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"application_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"voted_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, applicationVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ApplicationID, rel.VotedByID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.VotedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			VotedByApplicationVotes: related,
		}
	} else {
		o.R.VotedByApplicationVotes = append(o.R.VotedByApplicationVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &applicationVoteR{
				VotedBy: o,
			}
		} else {
			rel.R.VotedBy = o
		}
	}
	return nil
}

// AddBattleAbilityOptInLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleAbilityOptInLogs.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleAbilityOptInLogs(exec boil.Executor, insert bool, related ...*BattleAbilityOptInLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_ability_opt_in_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleAbilityOptInLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleAbilityOptInLogs: related,
		}
	} else {
		o.R.BattleAbilityOptInLogs = append(o.R.BattleAbilityOptInLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleAbilityOptInLogR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddBattleAbilityTriggers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleAbilityTriggers.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_ability_triggers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleAbilityTriggerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleAbilityTriggers: related,
		}
	} else {
		o.R.BattleAbilityTriggers = append(o.R.BattleAbilityTriggers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleAbilityTriggerR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// SetBattleAbilityTriggers removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Player's BattleAbilityTriggers accordingly.
// Replaces o.R.BattleAbilityTriggers with related.
// Sets related.R.Player's BattleAbilityTriggers accordingly.
func (o *Player) SetBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	query := "update \"battle_ability_triggers\" set \"player_id\" = null where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BattleAbilityTriggers {
			queries.SetScanner(&rel.PlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Player = nil
		}

		o.R.BattleAbilityTriggers = nil
	}
	return o.AddBattleAbilityTriggers(exec, insert, related...)
}

// RemoveBattleAbilityTriggers relationships from objects passed in.
// Removes related items from R.BattleAbilityTriggers (uses pointer comparison, removal does not keep order)
// Sets related.R.Player.
func (o *Player) RemoveBattleAbilityTriggers(exec boil.Executor, related ...*BattleAbilityTrigger) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PlayerID, nil)
		if rel.R != nil {
			rel.R.Player = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BattleAbilityTriggers {
			if rel != ri {
				continue
			}

			ln := len(o.R.BattleAbilityTriggers)
			if ln > 1 && i < ln-1 {
				o.R.BattleAbilityTriggers[i] = o.R.BattleAbilityTriggers[ln-1]
			}
			o.R.BattleAbilityTriggers = o.R.BattleAbilityTriggers[:ln-1]
			break
		}
	}

	return nil
}

// AddBattleContracts adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleContracts.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleContracts(exec boil.Executor, insert bool, related ...*BattleContract) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contracts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContractPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleContracts: related,
		}
	} else {
		o.R.BattleContracts = append(o.R.BattleContracts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContractR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddBattleContributions adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleContributions.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleContributions(exec boil.Executor, insert bool, related ...*BattleContribution) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contributions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContributionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleContributions: related,
		}
	} else {
		o.R.BattleContributions = append(o.R.BattleContributions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContributionR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddOwnerBattleMechs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleMechs.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleMechs(exec boil.Executor, insert bool, related ...*BattleMech) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_mechs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleMechPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleMechs: related,
		}
	} else {
		o.R.OwnerBattleMechs = append(o.R.OwnerBattleMechs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleMechR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddOwnerBattleQueues adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleQueues.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleQueues(exec boil.Executor, insert bool, related ...*BattleQueue) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_queue\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleQueuePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleQueues: related,
		}
	} else {
		o.R.OwnerBattleQueues = append(o.R.OwnerBattleQueues, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleQueueR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddPaidByBattleQueueFees adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PaidByBattleQueueFees.
// Sets related.R.PaidBy appropriately.
func (o *Player) AddPaidByBattleQueueFees(exec boil.Executor, insert bool, related ...*BattleQueueFee) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PaidByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_queue_fees\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"paid_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleQueueFeePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PaidByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PaidByBattleQueueFees: related,
		}
	} else {
		o.R.PaidByBattleQueueFees = append(o.R.PaidByBattleQueueFees, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleQueueFeeR{
				PaidBy: o,
			}
		} else {
			rel.R.PaidBy = o
		}
	}
	return nil
}

// AddBattles adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Battles.
// Sets related.R.Players appropriately.
func (o *Player) AddBattles(exec boil.Executor, insert bool, related ...*Battle) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"battle_viewers\" (\"player_id\", \"battle_id\") values ($1, $2)"
		values := []interface{}{o.ID, rel.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, query)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		_, err = exec.Exec(query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &playerR{
			Battles: related,
		}
	} else {
		o.R.Battles = append(o.R.Battles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleR{
				Players: PlayerSlice{o},
			}
		} else {
			rel.R.Players = append(rel.R.Players, o)
		}
	}
	return nil
}

// SetBattles removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Players's Battles accordingly.
// Replaces o.R.Battles with related.
// Sets related.R.Players's Battles accordingly.
func (o *Player) SetBattles(exec boil.Executor, insert bool, related ...*Battle) error {
	query := "delete from \"battle_viewers\" where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeBattlesFromPlayersSlice(o, related)
	if o.R != nil {
		o.R.Battles = nil
	}
	return o.AddBattles(exec, insert, related...)
}

// RemoveBattles relationships from objects passed in.
// Removes related items from R.Battles (uses pointer comparison, removal does not keep order)
// Sets related.R.Players.
func (o *Player) RemoveBattles(exec boil.Executor, related ...*Battle) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"battle_viewers\" where \"player_id\" = $1 and \"battle_id\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeBattlesFromPlayersSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Battles {
			if rel != ri {
				continue
			}

			ln := len(o.R.Battles)
			if ln > 1 && i < ln-1 {
				o.R.Battles[i] = o.R.Battles[ln-1]
			}
			o.R.Battles = o.R.Battles[:ln-1]
			break
		}
	}

	return nil
}

func removeBattlesFromPlayersSlice(o *Player, related []*Battle) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Players {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Players)
			if ln > 1 && i < ln-1 {
				rel.R.Players[i] = rel.R.Players[ln-1]
			}
			rel.R.Players = rel.R.Players[:ln-1]
			break
		}
	}
}

// AddOwnerBattleWins adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleWins.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleWins(exec boil.Executor, insert bool, related ...*BattleWin) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_wins\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleWinPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleWins: related,
		}
	} else {
		o.R.OwnerBattleWins = append(o.R.OwnerBattleWins, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleWinR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddChatHistories adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ChatHistories.
// Sets related.R.Player appropriately.
func (o *Player) AddChatHistories(exec boil.Executor, insert bool, related ...*ChatHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"chat_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ChatHistories: related,
		}
	} else {
		o.R.ChatHistories = append(o.R.ChatHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &chatHistoryR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddOwnerCollectionItems adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerCollectionItems.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerCollectionItems(exec boil.Executor, insert bool, related ...*CollectionItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"collection_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, collectionItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerCollectionItems: related,
		}
	} else {
		o.R.OwnerCollectionItems = append(o.R.OwnerCollectionItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &collectionItemR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddConsumedByConsumedAbilities adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ConsumedByConsumedAbilities.
// Sets related.R.ConsumedByPlayer appropriately.
func (o *Player) AddConsumedByConsumedAbilities(exec boil.Executor, insert bool, related ...*ConsumedAbility) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ConsumedBy = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"consumed_abilities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"consumed_by"}),
				strmangle.WhereClause("\"", "\"", 2, consumedAbilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ConsumedBy = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ConsumedByConsumedAbilities: related,
		}
	} else {
		o.R.ConsumedByConsumedAbilities = append(o.R.ConsumedByConsumedAbilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &consumedAbilityR{
				ConsumedByPlayer: o,
			}
		} else {
			rel.R.ConsumedByPlayer = o
		}
	}
	return nil
}

// AddDevices adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Devices.
// Sets related.R.Player appropriately.
func (o *Player) AddDevices(exec boil.Executor, insert bool, related ...*Device) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"devices\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, devicePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			Devices: related,
		}
	} else {
		o.R.Devices = append(o.R.Devices, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &deviceR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddMVPPlayerFactionStats adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.MVPPlayerFactionStats.
// Sets related.R.MVPPlayer appropriately.
func (o *Player) AddMVPPlayerFactionStats(exec boil.Executor, insert bool, related ...*FactionStat) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MVPPlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"faction_stats\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"mvp_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, factionStatPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MVPPlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			MVPPlayerFactionStats: related,
		}
	} else {
		o.R.MVPPlayerFactionStats = append(o.R.MVPPlayerFactionStats, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &factionStatR{
				MVPPlayer: o,
			}
		} else {
			rel.R.MVPPlayer = o
		}
	}
	return nil
}

// SetMVPPlayerFactionStats removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MVPPlayer's MVPPlayerFactionStats accordingly.
// Replaces o.R.MVPPlayerFactionStats with related.
// Sets related.R.MVPPlayer's MVPPlayerFactionStats accordingly.
func (o *Player) SetMVPPlayerFactionStats(exec boil.Executor, insert bool, related ...*FactionStat) error {
	query := "update \"faction_stats\" set \"mvp_player_id\" = null where \"mvp_player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MVPPlayerFactionStats {
			queries.SetScanner(&rel.MVPPlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MVPPlayer = nil
		}

		o.R.MVPPlayerFactionStats = nil
	}
	return o.AddMVPPlayerFactionStats(exec, insert, related...)
}

// RemoveMVPPlayerFactionStats relationships from objects passed in.
// Removes related items from R.MVPPlayerFactionStats (uses pointer comparison, removal does not keep order)
// Sets related.R.MVPPlayer.
func (o *Player) RemoveMVPPlayerFactionStats(exec boil.Executor, related ...*FactionStat) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MVPPlayerID, nil)
		if rel.R != nil {
			rel.R.MVPPlayer = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("mvp_player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MVPPlayerFactionStats {
			if rel != ri {
				continue
			}

			ln := len(o.R.MVPPlayerFactionStats)
			if ln > 1 && i < ln-1 {
				o.R.MVPPlayerFactionStats[i] = o.R.MVPPlayerFactionStats[ln-1]
			}
			o.R.MVPPlayerFactionStats = o.R.MVPPlayerFactionStats[:ln-1]
			break
		}
	}

	return nil
}

// AddOwnerItemKeycardSales adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerItemKeycardSales.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerItemKeycardSales(exec boil.Executor, insert bool, related ...*ItemKeycardSale) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_keycard_sales\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemKeycardSalePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerItemKeycardSales: related,
		}
	} else {
		o.R.OwnerItemKeycardSales = append(o.R.OwnerItemKeycardSales, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemKeycardSaleR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddSoldToItemKeycardSales adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.SoldToItemKeycardSales.
// Sets related.R.SoldToPlayer appropriately.
func (o *Player) AddSoldToItemKeycardSales(exec boil.Executor, insert bool, related ...*ItemKeycardSale) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SoldTo, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_keycard_sales\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"sold_to"}),
				strmangle.WhereClause("\"", "\"", 2, itemKeycardSalePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SoldTo, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			SoldToItemKeycardSales: related,
		}
	} else {
		o.R.SoldToItemKeycardSales = append(o.R.SoldToItemKeycardSales, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemKeycardSaleR{
				SoldToPlayer: o,
			}
		} else {
			rel.R.SoldToPlayer = o
		}
	}
	return nil
}

// SetSoldToItemKeycardSales removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.SoldToPlayer's SoldToItemKeycardSales accordingly.
// Replaces o.R.SoldToItemKeycardSales with related.
// Sets related.R.SoldToPlayer's SoldToItemKeycardSales accordingly.
func (o *Player) SetSoldToItemKeycardSales(exec boil.Executor, insert bool, related ...*ItemKeycardSale) error {
	query := "update \"item_keycard_sales\" set \"sold_to\" = null where \"sold_to\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.SoldToItemKeycardSales {
			queries.SetScanner(&rel.SoldTo, nil)
			if rel.R == nil {
				continue
			}

			rel.R.SoldToPlayer = nil
		}

		o.R.SoldToItemKeycardSales = nil
	}
	return o.AddSoldToItemKeycardSales(exec, insert, related...)
}

// RemoveSoldToItemKeycardSales relationships from objects passed in.
// Removes related items from R.SoldToItemKeycardSales (uses pointer comparison, removal does not keep order)
// Sets related.R.SoldToPlayer.
func (o *Player) RemoveSoldToItemKeycardSales(exec boil.Executor, related ...*ItemKeycardSale) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SoldTo, nil)
		if rel.R != nil {
			rel.R.SoldToPlayer = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("sold_to")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.SoldToItemKeycardSales {
			if rel != ri {
				continue
			}

			ln := len(o.R.SoldToItemKeycardSales)
			if ln > 1 && i < ln-1 {
				o.R.SoldToItemKeycardSales[i] = o.R.SoldToItemKeycardSales[ln-1]
			}
			o.R.SoldToItemKeycardSales = o.R.SoldToItemKeycardSales[:ln-1]
			break
		}
	}

	return nil
}

// AddOwnerItemSales adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerItemSales.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerItemSales(exec boil.Executor, insert bool, related ...*ItemSale) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_sales\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemSalePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerItemSales: related,
		}
	} else {
		o.R.OwnerItemSales = append(o.R.OwnerItemSales, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemSaleR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddSoldToItemSales adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.SoldToItemSales.
// Sets related.R.SoldToPlayer appropriately.
func (o *Player) AddSoldToItemSales(exec boil.Executor, insert bool, related ...*ItemSale) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SoldTo, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_sales\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"sold_to"}),
				strmangle.WhereClause("\"", "\"", 2, itemSalePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SoldTo, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			SoldToItemSales: related,
		}
	} else {
		o.R.SoldToItemSales = append(o.R.SoldToItemSales, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemSaleR{
				SoldToPlayer: o,
			}
		} else {
			rel.R.SoldToPlayer = o
		}
	}
	return nil
}

// SetSoldToItemSales removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.SoldToPlayer's SoldToItemSales accordingly.
// Replaces o.R.SoldToItemSales with related.
// Sets related.R.SoldToPlayer's SoldToItemSales accordingly.
func (o *Player) SetSoldToItemSales(exec boil.Executor, insert bool, related ...*ItemSale) error {
	query := "update \"item_sales\" set \"sold_to\" = null where \"sold_to\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.SoldToItemSales {
			queries.SetScanner(&rel.SoldTo, nil)
			if rel.R == nil {
				continue
			}

			rel.R.SoldToPlayer = nil
		}

		o.R.SoldToItemSales = nil
	}
	return o.AddSoldToItemSales(exec, insert, related...)
}

// RemoveSoldToItemSales relationships from objects passed in.
// Removes related items from R.SoldToItemSales (uses pointer comparison, removal does not keep order)
// Sets related.R.SoldToPlayer.
func (o *Player) RemoveSoldToItemSales(exec boil.Executor, related ...*ItemSale) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SoldTo, nil)
		if rel.R != nil {
			rel.R.SoldToPlayer = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("sold_to")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.SoldToItemSales {
			if rel != ri {
				continue
			}

			ln := len(o.R.SoldToItemSales)
			if ln > 1 && i < ln-1 {
				o.R.SoldToItemSales[i] = o.R.SoldToItemSales[ln-1]
			}
			o.R.SoldToItemSales = o.R.SoldToItemSales[:ln-1]
			break
		}
	}

	return nil
}

// AddBidderItemSalesBidHistories adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BidderItemSalesBidHistories.
// Sets related.R.Bidder appropriately.
func (o *Player) AddBidderItemSalesBidHistories(exec boil.Executor, insert bool, related ...*ItemSalesBidHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BidderID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_sales_bid_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"bidder_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemSalesBidHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ItemSaleID, rel.BidderID, rel.BidAt}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BidderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BidderItemSalesBidHistories: related,
		}
	} else {
		o.R.BidderItemSalesBidHistories = append(o.R.BidderItemSalesBidHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemSalesBidHistoryR{
				Bidder: o,
			}
		} else {
			rel.R.Bidder = o
		}
	}
	return nil
}

// AddUserMarketplaceEvents adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.UserMarketplaceEvents.
// Sets related.R.User appropriately.
func (o *Player) AddUserMarketplaceEvents(exec boil.Executor, insert bool, related ...*MarketplaceEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"marketplace_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, marketplaceEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			UserMarketplaceEvents: related,
		}
	} else {
		o.R.UserMarketplaceEvents = append(o.R.UserMarketplaceEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &marketplaceEventR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddTriggeredByMechAbilityTriggerLogsOlds adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.TriggeredByMechAbilityTriggerLogsOlds.
// Sets related.R.TriggeredBy appropriately.
func (o *Player) AddTriggeredByMechAbilityTriggerLogsOlds(exec boil.Executor, insert bool, related ...*MechAbilityTriggerLogsOld) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.TriggeredByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mech_ability_trigger_logs_old\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"triggered_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, mechAbilityTriggerLogsOldPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.TriggeredByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			TriggeredByMechAbilityTriggerLogsOlds: related,
		}
	} else {
		o.R.TriggeredByMechAbilityTriggerLogsOlds = append(o.R.TriggeredByMechAbilityTriggerLogsOlds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mechAbilityTriggerLogsOldR{
				TriggeredBy: o,
			}
		} else {
			rel.R.TriggeredBy = o
		}
	}
	return nil
}

// AddTriggeredByMechMoveCommandLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.TriggeredByMechMoveCommandLogs.
// Sets related.R.TriggeredBy appropriately.
func (o *Player) AddTriggeredByMechMoveCommandLogs(exec boil.Executor, insert bool, related ...*MechMoveCommandLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.TriggeredByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mech_move_command_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"triggered_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, mechMoveCommandLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.TriggeredByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			TriggeredByMechMoveCommandLogs: related,
		}
	} else {
		o.R.TriggeredByMechMoveCommandLogs = append(o.R.TriggeredByMechMoveCommandLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mechMoveCommandLogR{
				TriggeredBy: o,
			}
		} else {
			rel.R.TriggeredBy = o
		}
	}
	return nil
}

// AddOwnerMechsOlds adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerMechsOlds.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerMechsOlds(exec boil.Executor, insert bool, related ...*MechsOld) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mechs_old\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, mechsOldPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerMechsOlds: related,
		}
	} else {
		o.R.OwnerMechsOlds = append(o.R.OwnerMechsOlds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mechsOldR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddLookupPlayerModActionAudits adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.LookupPlayerModActionAudits.
// Sets related.R.LookupPlayer appropriately.
func (o *Player) AddLookupPlayerModActionAudits(exec boil.Executor, insert bool, related ...*ModActionAudit) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.LookupPlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mod_action_audit\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"lookup_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, modActionAuditPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.LookupPlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			LookupPlayerModActionAudits: related,
		}
	} else {
		o.R.LookupPlayerModActionAudits = append(o.R.LookupPlayerModActionAudits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &modActionAuditR{
				LookupPlayer: o,
			}
		} else {
			rel.R.LookupPlayer = o
		}
	}
	return nil
}

// SetLookupPlayerModActionAudits removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.LookupPlayer's LookupPlayerModActionAudits accordingly.
// Replaces o.R.LookupPlayerModActionAudits with related.
// Sets related.R.LookupPlayer's LookupPlayerModActionAudits accordingly.
func (o *Player) SetLookupPlayerModActionAudits(exec boil.Executor, insert bool, related ...*ModActionAudit) error {
	query := "update \"mod_action_audit\" set \"lookup_player_id\" = null where \"lookup_player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.LookupPlayerModActionAudits {
			queries.SetScanner(&rel.LookupPlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.LookupPlayer = nil
		}

		o.R.LookupPlayerModActionAudits = nil
	}
	return o.AddLookupPlayerModActionAudits(exec, insert, related...)
}

// RemoveLookupPlayerModActionAudits relationships from objects passed in.
// Removes related items from R.LookupPlayerModActionAudits (uses pointer comparison, removal does not keep order)
// Sets related.R.LookupPlayer.
func (o *Player) RemoveLookupPlayerModActionAudits(exec boil.Executor, related ...*ModActionAudit) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.LookupPlayerID, nil)
		if rel.R != nil {
			rel.R.LookupPlayer = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("lookup_player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.LookupPlayerModActionAudits {
			if rel != ri {
				continue
			}

			ln := len(o.R.LookupPlayerModActionAudits)
			if ln > 1 && i < ln-1 {
				o.R.LookupPlayerModActionAudits[i] = o.R.LookupPlayerModActionAudits[ln-1]
			}
			o.R.LookupPlayerModActionAudits = o.R.LookupPlayerModActionAudits[:ln-1]
			break
		}
	}

	return nil
}

// AddModModActionAudits adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ModModActionAudits.
// Sets related.R.Mod appropriately.
func (o *Player) AddModModActionAudits(exec boil.Executor, insert bool, related ...*ModActionAudit) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ModID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mod_action_audit\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"mod_id"}),
				strmangle.WhereClause("\"", "\"", 2, modActionAuditPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ModID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ModModActionAudits: related,
		}
	} else {
		o.R.ModModActionAudits = append(o.R.ModModActionAudits, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &modActionAuditR{
				Mod: o,
			}
		} else {
			rel.R.Mod = o
		}
	}
	return nil
}

// AddOwnerPlayerAbilities adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerPlayerAbilities.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerPlayerAbilities(exec boil.Executor, insert bool, related ...*PlayerAbility) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_abilities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerAbilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerPlayerAbilities: related,
		}
	} else {
		o.R.OwnerPlayerAbilities = append(o.R.OwnerPlayerAbilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerAbilityR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddPlayerActiveLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerActiveLogs.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerActiveLogs(exec boil.Executor, insert bool, related ...*PlayerActiveLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_active_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerActiveLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerActiveLogs: related,
		}
	} else {
		o.R.PlayerActiveLogs = append(o.R.PlayerActiveLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerActiveLogR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddBannedByPlayerBans adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BannedByPlayerBans.
// Sets related.R.BannedBy appropriately.
func (o *Player) AddBannedByPlayerBans(exec boil.Executor, insert bool, related ...*PlayerBan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BannedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_bans\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"banned_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerBanPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BannedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BannedByPlayerBans: related,
		}
	} else {
		o.R.BannedByPlayerBans = append(o.R.BannedByPlayerBans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerBanR{
				BannedBy: o,
			}
		} else {
			rel.R.BannedBy = o
		}
	}
	return nil
}

// AddBannedPlayerPlayerBans adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BannedPlayerPlayerBans.
// Sets related.R.BannedPlayer appropriately.
func (o *Player) AddBannedPlayerPlayerBans(exec boil.Executor, insert bool, related ...*PlayerBan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BannedPlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_bans\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"banned_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerBanPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BannedPlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BannedPlayerPlayerBans: related,
		}
	} else {
		o.R.BannedPlayerPlayerBans = append(o.R.BannedPlayerPlayerBans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerBanR{
				BannedPlayer: o,
			}
		} else {
			rel.R.BannedPlayer = o
		}
	}
	return nil
}

// AddPlayerFingerprints adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerFingerprints.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerFingerprints(exec boil.Executor, insert bool, related ...*PlayerFingerprint) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_fingerprints\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerFingerprintPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.FingerprintID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerFingerprints: related,
		}
	} else {
		o.R.PlayerFingerprints = append(o.R.PlayerFingerprints, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerFingerprintR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerIps adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerIps.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerIps(exec boil.Executor, insert bool, related ...*PlayerIP) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_ips\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerIPPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.IP}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerIps: related,
		}
	} else {
		o.R.PlayerIps = append(o.R.PlayerIps, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerIPR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerKeycards adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerKeycards.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerKeycards(exec boil.Executor, insert bool, related ...*PlayerKeycard) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_keycards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerKeycardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerKeycards: related,
		}
	} else {
		o.R.PlayerKeycards = append(o.R.PlayerKeycards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerKeycardR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerKillLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerKillLogs.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerKillLogs(exec boil.Executor, insert bool, related ...*PlayerKillLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_kill_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerKillLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerKillLogs: related,
		}
	} else {
		o.R.PlayerKillLogs = append(o.R.PlayerKillLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerKillLogR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerLanguages adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerLanguages.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerLanguages(exec boil.Executor, insert bool, related ...*PlayerLanguage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_languages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerLanguagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerLanguages: related,
		}
	} else {
		o.R.PlayerLanguages = append(o.R.PlayerLanguages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerLanguageR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerMechRepairSlots adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerMechRepairSlots.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerMechRepairSlots(exec boil.Executor, insert bool, related ...*PlayerMechRepairSlot) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_mech_repair_slots\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerMechRepairSlotPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerMechRepairSlots: related,
		}
	} else {
		o.R.PlayerMechRepairSlots = append(o.R.PlayerMechRepairSlots, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerMechRepairSlotR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerMultipliers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerMultipliers.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerMultipliers(exec boil.Executor, insert bool, related ...*PlayerMultiplier) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_multipliers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerMultiplierPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerMultipliers: related,
		}
	} else {
		o.R.PlayerMultipliers = append(o.R.PlayerMultipliers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerMultiplierR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerPreferences adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerPreferences.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerPreferences(exec boil.Executor, insert bool, related ...*PlayerPreference) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_preferences\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerPreferencePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.Key}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerPreferences: related,
		}
	} else {
		o.R.PlayerPreferences = append(o.R.PlayerPreferences, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerPreferenceR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerSpoilsOfWars adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerSpoilsOfWars.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerSpoilsOfWars(exec boil.Executor, insert bool, related ...*PlayerSpoilsOfWar) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_spoils_of_war\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerSpoilsOfWarPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerSpoilsOfWars: related,
		}
	} else {
		o.R.PlayerSpoilsOfWars = append(o.R.PlayerSpoilsOfWars, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerSpoilsOfWarR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayersFeatures adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayersFeatures.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayersFeatures(exec boil.Executor, insert bool, related ...*PlayersFeature) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players_features\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playersFeaturePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayersFeatures: related,
		}
	} else {
		o.R.PlayersFeatures = append(o.R.PlayersFeatures, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playersFeatureR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayersObtainedQuests adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayersObtainedQuests.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayersObtainedQuests(exec boil.Executor, insert bool, related ...*PlayersObtainedQuest) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players_obtained_quests\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playersObtainedQuestPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.ObtainedQuestID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayersObtainedQuests: related,
		}
	} else {
		o.R.PlayersObtainedQuests = append(o.R.PlayersObtainedQuests, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playersObtainedQuestR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayersProfileAvatars adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayersProfileAvatars.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayersProfileAvatars(exec boil.Executor, insert bool, related ...*PlayersProfileAvatar) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players_profile_avatars\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playersProfileAvatarPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayersProfileAvatars: related,
		}
	} else {
		o.R.PlayersProfileAvatars = append(o.R.PlayersProfileAvatars, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playersProfileAvatarR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayersPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayersPunishVotes.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayersPunishVotes(exec boil.Executor, insert bool, related ...*PlayersPunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players_punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playersPunishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayersPunishVotes: related,
		}
	} else {
		o.R.PlayersPunishVotes = append(o.R.PlayersPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playersPunishVoteR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddProfileCustomAvatars adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ProfileCustomAvatars.
// Sets related.R.Player appropriately.
func (o *Player) AddProfileCustomAvatars(exec boil.Executor, insert bool, related ...*ProfileCustomAvatar) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"profile_custom_avatars\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, profileCustomAvatarPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ProfileCustomAvatars: related,
		}
	} else {
		o.R.ProfileCustomAvatars = append(o.R.ProfileCustomAvatars, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &profileCustomAvatarR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddVoteByPlayerPunishVoteInstantPassRecords adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.VoteByPlayerPunishVoteInstantPassRecords.
// Sets related.R.VoteByPlayer appropriately.
func (o *Player) AddVoteByPlayerPunishVoteInstantPassRecords(exec boil.Executor, insert bool, related ...*PunishVoteInstantPassRecord) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.VoteByPlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_vote_instant_pass_records\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"vote_by_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVoteInstantPassRecordPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.VoteByPlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			VoteByPlayerPunishVoteInstantPassRecords: related,
		}
	} else {
		o.R.VoteByPlayerPunishVoteInstantPassRecords = append(o.R.VoteByPlayerPunishVoteInstantPassRecords, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteInstantPassRecordR{
				VoteByPlayer: o,
			}
		} else {
			rel.R.VoteByPlayer = o
		}
	}
	return nil
}

// AddInstantPassByPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.InstantPassByPunishVotes.
// Sets related.R.InstantPassBy appropriately.
func (o *Player) AddInstantPassByPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.InstantPassByID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"instant_pass_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.InstantPassByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			InstantPassByPunishVotes: related,
		}
	} else {
		o.R.InstantPassByPunishVotes = append(o.R.InstantPassByPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				InstantPassBy: o,
			}
		} else {
			rel.R.InstantPassBy = o
		}
	}
	return nil
}

// SetInstantPassByPunishVotes removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.InstantPassBy's InstantPassByPunishVotes accordingly.
// Replaces o.R.InstantPassByPunishVotes with related.
// Sets related.R.InstantPassBy's InstantPassByPunishVotes accordingly.
func (o *Player) SetInstantPassByPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	query := "update \"punish_votes\" set \"instant_pass_by_id\" = null where \"instant_pass_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.InstantPassByPunishVotes {
			queries.SetScanner(&rel.InstantPassByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.InstantPassBy = nil
		}

		o.R.InstantPassByPunishVotes = nil
	}
	return o.AddInstantPassByPunishVotes(exec, insert, related...)
}

// RemoveInstantPassByPunishVotes relationships from objects passed in.
// Removes related items from R.InstantPassByPunishVotes (uses pointer comparison, removal does not keep order)
// Sets related.R.InstantPassBy.
func (o *Player) RemoveInstantPassByPunishVotes(exec boil.Executor, related ...*PunishVote) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.InstantPassByID, nil)
		if rel.R != nil {
			rel.R.InstantPassBy = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("instant_pass_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.InstantPassByPunishVotes {
			if rel != ri {
				continue
			}

			ln := len(o.R.InstantPassByPunishVotes)
			if ln > 1 && i < ln-1 {
				o.R.InstantPassByPunishVotes[i] = o.R.InstantPassByPunishVotes[ln-1]
			}
			o.R.InstantPassByPunishVotes = o.R.InstantPassByPunishVotes[:ln-1]
			break
		}
	}

	return nil
}

// AddIssuedByPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.IssuedByPunishVotes.
// Sets related.R.IssuedBy appropriately.
func (o *Player) AddIssuedByPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.IssuedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"issued_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.IssuedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			IssuedByPunishVotes: related,
		}
	} else {
		o.R.IssuedByPunishVotes = append(o.R.IssuedByPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				IssuedBy: o,
			}
		} else {
			rel.R.IssuedBy = o
		}
	}
	return nil
}

// AddReportedPlayerPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ReportedPlayerPunishVotes.
// Sets related.R.ReportedPlayer appropriately.
func (o *Player) AddReportedPlayerPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReportedPlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"reported_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReportedPlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ReportedPlayerPunishVotes: related,
		}
	} else {
		o.R.ReportedPlayerPunishVotes = append(o.R.ReportedPlayerPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				ReportedPlayer: o,
			}
		} else {
			rel.R.ReportedPlayer = o
		}
	}
	return nil
}

// AddRepairAgents adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.RepairAgents.
// Sets related.R.Player appropriately.
func (o *Player) AddRepairAgents(exec boil.Executor, insert bool, related ...*RepairAgent) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"repair_agents\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, repairAgentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			RepairAgents: related,
		}
	} else {
		o.R.RepairAgents = append(o.R.RepairAgents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &repairAgentR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddOfferedByRepairOffers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OfferedByRepairOffers.
// Sets related.R.OfferedBy appropriately.
func (o *Player) AddOfferedByRepairOffers(exec boil.Executor, insert bool, related ...*RepairOffer) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OfferedByID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"repair_offers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"offered_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, repairOfferPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OfferedByID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OfferedByRepairOffers: related,
		}
	} else {
		o.R.OfferedByRepairOffers = append(o.R.OfferedByRepairOffers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &repairOfferR{
				OfferedBy: o,
			}
		} else {
			rel.R.OfferedBy = o
		}
	}
	return nil
}

// SetOfferedByRepairOffers removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OfferedBy's OfferedByRepairOffers accordingly.
// Replaces o.R.OfferedByRepairOffers with related.
// Sets related.R.OfferedBy's OfferedByRepairOffers accordingly.
func (o *Player) SetOfferedByRepairOffers(exec boil.Executor, insert bool, related ...*RepairOffer) error {
	query := "update \"repair_offers\" set \"offered_by_id\" = null where \"offered_by_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OfferedByRepairOffers {
			queries.SetScanner(&rel.OfferedByID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.OfferedBy = nil
		}

		o.R.OfferedByRepairOffers = nil
	}
	return o.AddOfferedByRepairOffers(exec, insert, related...)
}

// RemoveOfferedByRepairOffers relationships from objects passed in.
// Removes related items from R.OfferedByRepairOffers (uses pointer comparison, removal does not keep order)
// Sets related.R.OfferedBy.
func (o *Player) RemoveOfferedByRepairOffers(exec boil.Executor, related ...*RepairOffer) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OfferedByID, nil)
		if rel.R != nil {
			rel.R.OfferedBy = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("offered_by_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OfferedByRepairOffers {
			if rel != ri {
				continue
			}

			ln := len(o.R.OfferedByRepairOffers)
			if ln > 1 && i < ln-1 {
				o.R.OfferedByRepairOffers[i] = o.R.OfferedByRepairOffers[ln-1]
			}
			o.R.OfferedByRepairOffers = o.R.OfferedByRepairOffers[:ln-1]
			break
		}
	}

	return nil
}

// AddSyndicateCommittees adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.SyndicateCommittees.
// Sets related.R.Player appropriately.
func (o *Player) AddSyndicateCommittees(exec boil.Executor, insert bool, related ...*SyndicateCommittee) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_committees\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateCommitteePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			SyndicateCommittees: related,
		}
	} else {
		o.R.SyndicateCommittees = append(o.R.SyndicateCommittees, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateCommitteeR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddSyndicateDirectors adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.SyndicateDirectors.
// Sets related.R.Player appropriately.
func (o *Player) AddSyndicateDirectors(exec boil.Executor, insert bool, related ...*SyndicateDirector) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_directors\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateDirectorPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.SyndicateID, rel.PlayerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			SyndicateDirectors: related,
		}
	} else {
		o.R.SyndicateDirectors = append(o.R.SyndicateDirectors, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateDirectorR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddCandidateSyndicateElectionCandidates adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.CandidateSyndicateElectionCandidates.
// Sets related.R.Candidate appropriately.
func (o *Player) AddCandidateSyndicateElectionCandidates(exec boil.Executor, insert bool, related ...*SyndicateElectionCandidate) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CandidateID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_election_candidates\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"candidate_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateElectionCandidatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.SyndicateElectionID, rel.CandidateID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CandidateID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			CandidateSyndicateElectionCandidates: related,
		}
	} else {
		o.R.CandidateSyndicateElectionCandidates = append(o.R.CandidateSyndicateElectionCandidates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateElectionCandidateR{
				Candidate: o,
			}
		} else {
			rel.R.Candidate = o
		}
	}
	return nil
}

// AddVotedBySyndicateElectionVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.VotedBySyndicateElectionVotes.
// Sets related.R.VotedBy appropriately.
func (o *Player) AddVotedBySyndicateElectionVotes(exec boil.Executor, insert bool, related ...*SyndicateElectionVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.VotedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_election_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"voted_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateElectionVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.SyndicateElectionID, rel.VotedByID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.VotedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			VotedBySyndicateElectionVotes: related,
		}
	} else {
		o.R.VotedBySyndicateElectionVotes = append(o.R.VotedBySyndicateElectionVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateElectionVoteR{
				VotedBy: o,
			}
		} else {
			rel.R.VotedBy = o
		}
	}
	return nil
}

// AddVotedForCandidateSyndicateElectionVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.VotedForCandidateSyndicateElectionVotes.
// Sets related.R.VotedForCandidate appropriately.
func (o *Player) AddVotedForCandidateSyndicateElectionVotes(exec boil.Executor, insert bool, related ...*SyndicateElectionVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.VotedForCandidateID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_election_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"voted_for_candidate_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateElectionVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.SyndicateElectionID, rel.VotedByID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.VotedForCandidateID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			VotedForCandidateSyndicateElectionVotes: related,
		}
	} else {
		o.R.VotedForCandidateSyndicateElectionVotes = append(o.R.VotedForCandidateSyndicateElectionVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateElectionVoteR{
				VotedForCandidate: o,
			}
		} else {
			rel.R.VotedForCandidate = o
		}
	}
	return nil
}

// AddWinnerSyndicateElections adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.WinnerSyndicateElections.
// Sets related.R.Winner appropriately.
func (o *Player) AddWinnerSyndicateElections(exec boil.Executor, insert bool, related ...*SyndicateElection) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.WinnerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_elections\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"winner_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateElectionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.WinnerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			WinnerSyndicateElections: related,
		}
	} else {
		o.R.WinnerSyndicateElections = append(o.R.WinnerSyndicateElections, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateElectionR{
				Winner: o,
			}
		} else {
			rel.R.Winner = o
		}
	}
	return nil
}

// SetWinnerSyndicateElections removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Winner's WinnerSyndicateElections accordingly.
// Replaces o.R.WinnerSyndicateElections with related.
// Sets related.R.Winner's WinnerSyndicateElections accordingly.
func (o *Player) SetWinnerSyndicateElections(exec boil.Executor, insert bool, related ...*SyndicateElection) error {
	query := "update \"syndicate_elections\" set \"winner_id\" = null where \"winner_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.WinnerSyndicateElections {
			queries.SetScanner(&rel.WinnerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Winner = nil
		}

		o.R.WinnerSyndicateElections = nil
	}
	return o.AddWinnerSyndicateElections(exec, insert, related...)
}

// RemoveWinnerSyndicateElections relationships from objects passed in.
// Removes related items from R.WinnerSyndicateElections (uses pointer comparison, removal does not keep order)
// Sets related.R.Winner.
func (o *Player) RemoveWinnerSyndicateElections(exec boil.Executor, related ...*SyndicateElection) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.WinnerID, nil)
		if rel.R != nil {
			rel.R.Winner = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("winner_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.WinnerSyndicateElections {
			if rel != ri {
				continue
			}

			ln := len(o.R.WinnerSyndicateElections)
			if ln > 1 && i < ln-1 {
				o.R.WinnerSyndicateElections[i] = o.R.WinnerSyndicateElections[ln-1]
			}
			o.R.WinnerSyndicateElections = o.R.WinnerSyndicateElections[:ln-1]
			break
		}
	}

	return nil
}

// AddApplicantSyndicateJoinApplications adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ApplicantSyndicateJoinApplications.
// Sets related.R.Applicant appropriately.
func (o *Player) AddApplicantSyndicateJoinApplications(exec boil.Executor, insert bool, related ...*SyndicateJoinApplication) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ApplicantID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_join_applications\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"applicant_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateJoinApplicationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ApplicantID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ApplicantSyndicateJoinApplications: related,
		}
	} else {
		o.R.ApplicantSyndicateJoinApplications = append(o.R.ApplicantSyndicateJoinApplications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateJoinApplicationR{
				Applicant: o,
			}
		} else {
			rel.R.Applicant = o
		}
	}
	return nil
}

// AddVoteBySyndicateMotionVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.VoteBySyndicateMotionVotes.
// Sets related.R.VoteBy appropriately.
func (o *Player) AddVoteBySyndicateMotionVotes(exec boil.Executor, insert bool, related ...*SyndicateMotionVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.VoteByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_motion_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"vote_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateMotionVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.MotionID, rel.VoteByID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.VoteByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			VoteBySyndicateMotionVotes: related,
		}
	} else {
		o.R.VoteBySyndicateMotionVotes = append(o.R.VoteBySyndicateMotionVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateMotionVoteR{
				VoteBy: o,
			}
		} else {
			rel.R.VoteBy = o
		}
	}
	return nil
}

// AddIssuedBySyndicateMotions adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.IssuedBySyndicateMotions.
// Sets related.R.IssuedBy appropriately.
func (o *Player) AddIssuedBySyndicateMotions(exec boil.Executor, insert bool, related ...*SyndicateMotion) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.IssuedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_motions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"issued_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateMotionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.IssuedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			IssuedBySyndicateMotions: related,
		}
	} else {
		o.R.IssuedBySyndicateMotions = append(o.R.IssuedBySyndicateMotions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateMotionR{
				IssuedBy: o,
			}
		} else {
			rel.R.IssuedBy = o
		}
	}
	return nil
}

// AddMemberSyndicateMotions adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.MemberSyndicateMotions.
// Sets related.R.Member appropriately.
func (o *Player) AddMemberSyndicateMotions(exec boil.Executor, insert bool, related ...*SyndicateMotion) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MemberID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicate_motions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"member_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicateMotionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MemberID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			MemberSyndicateMotions: related,
		}
	} else {
		o.R.MemberSyndicateMotions = append(o.R.MemberSyndicateMotions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateMotionR{
				Member: o,
			}
		} else {
			rel.R.Member = o
		}
	}
	return nil
}

// SetMemberSyndicateMotions removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Member's MemberSyndicateMotions accordingly.
// Replaces o.R.MemberSyndicateMotions with related.
// Sets related.R.Member's MemberSyndicateMotions accordingly.
func (o *Player) SetMemberSyndicateMotions(exec boil.Executor, insert bool, related ...*SyndicateMotion) error {
	query := "update \"syndicate_motions\" set \"member_id\" = null where \"member_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MemberSyndicateMotions {
			queries.SetScanner(&rel.MemberID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Member = nil
		}

		o.R.MemberSyndicateMotions = nil
	}
	return o.AddMemberSyndicateMotions(exec, insert, related...)
}

// RemoveMemberSyndicateMotions relationships from objects passed in.
// Removes related items from R.MemberSyndicateMotions (uses pointer comparison, removal does not keep order)
// Sets related.R.Member.
func (o *Player) RemoveMemberSyndicateMotions(exec boil.Executor, related ...*SyndicateMotion) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MemberID, nil)
		if rel.R != nil {
			rel.R.Member = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("member_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MemberSyndicateMotions {
			if rel != ri {
				continue
			}

			ln := len(o.R.MemberSyndicateMotions)
			if ln > 1 && i < ln-1 {
				o.R.MemberSyndicateMotions[i] = o.R.MemberSyndicateMotions[ln-1]
			}
			o.R.MemberSyndicateMotions = o.R.MemberSyndicateMotions[:ln-1]
			break
		}
	}

	return nil
}

// AddAdminSyndicates adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AdminSyndicates.
// Sets related.R.Admin appropriately.
func (o *Player) AddAdminSyndicates(exec boil.Executor, insert bool, related ...*Syndicate) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.AdminID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicates\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"admin_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.AdminID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			AdminSyndicates: related,
		}
	} else {
		o.R.AdminSyndicates = append(o.R.AdminSyndicates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateR{
				Admin: o,
			}
		} else {
			rel.R.Admin = o
		}
	}
	return nil
}

// SetAdminSyndicates removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Admin's AdminSyndicates accordingly.
// Replaces o.R.AdminSyndicates with related.
// Sets related.R.Admin's AdminSyndicates accordingly.
func (o *Player) SetAdminSyndicates(exec boil.Executor, insert bool, related ...*Syndicate) error {
	query := "update \"syndicates\" set \"admin_id\" = null where \"admin_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AdminSyndicates {
			queries.SetScanner(&rel.AdminID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Admin = nil
		}

		o.R.AdminSyndicates = nil
	}
	return o.AddAdminSyndicates(exec, insert, related...)
}

// RemoveAdminSyndicates relationships from objects passed in.
// Removes related items from R.AdminSyndicates (uses pointer comparison, removal does not keep order)
// Sets related.R.Admin.
func (o *Player) RemoveAdminSyndicates(exec boil.Executor, related ...*Syndicate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.AdminID, nil)
		if rel.R != nil {
			rel.R.Admin = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("admin_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AdminSyndicates {
			if rel != ri {
				continue
			}

			ln := len(o.R.AdminSyndicates)
			if ln > 1 && i < ln-1 {
				o.R.AdminSyndicates[i] = o.R.AdminSyndicates[ln-1]
			}
			o.R.AdminSyndicates = o.R.AdminSyndicates[:ln-1]
			break
		}
	}

	return nil
}

// AddCeoPlayerSyndicates adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.CeoPlayerSyndicates.
// Sets related.R.CeoPlayer appropriately.
func (o *Player) AddCeoPlayerSyndicates(exec boil.Executor, insert bool, related ...*Syndicate) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CeoPlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicates\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"ceo_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CeoPlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			CeoPlayerSyndicates: related,
		}
	} else {
		o.R.CeoPlayerSyndicates = append(o.R.CeoPlayerSyndicates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateR{
				CeoPlayer: o,
			}
		} else {
			rel.R.CeoPlayer = o
		}
	}
	return nil
}

// SetCeoPlayerSyndicates removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CeoPlayer's CeoPlayerSyndicates accordingly.
// Replaces o.R.CeoPlayerSyndicates with related.
// Sets related.R.CeoPlayer's CeoPlayerSyndicates accordingly.
func (o *Player) SetCeoPlayerSyndicates(exec boil.Executor, insert bool, related ...*Syndicate) error {
	query := "update \"syndicates\" set \"ceo_player_id\" = null where \"ceo_player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CeoPlayerSyndicates {
			queries.SetScanner(&rel.CeoPlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CeoPlayer = nil
		}

		o.R.CeoPlayerSyndicates = nil
	}
	return o.AddCeoPlayerSyndicates(exec, insert, related...)
}

// RemoveCeoPlayerSyndicates relationships from objects passed in.
// Removes related items from R.CeoPlayerSyndicates (uses pointer comparison, removal does not keep order)
// Sets related.R.CeoPlayer.
func (o *Player) RemoveCeoPlayerSyndicates(exec boil.Executor, related ...*Syndicate) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CeoPlayerID, nil)
		if rel.R != nil {
			rel.R.CeoPlayer = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("ceo_player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CeoPlayerSyndicates {
			if rel != ri {
				continue
			}

			ln := len(o.R.CeoPlayerSyndicates)
			if ln > 1 && i < ln-1 {
				o.R.CeoPlayerSyndicates[i] = o.R.CeoPlayerSyndicates[ln-1]
			}
			o.R.CeoPlayerSyndicates = o.R.CeoPlayerSyndicates[:ln-1]
			break
		}
	}

	return nil
}

// AddFoundedBySyndicates adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.FoundedBySyndicates.
// Sets related.R.FoundedBy appropriately.
func (o *Player) AddFoundedBySyndicates(exec boil.Executor, insert bool, related ...*Syndicate) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FoundedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"syndicates\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"founded_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, syndicatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FoundedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			FoundedBySyndicates: related,
		}
	} else {
		o.R.FoundedBySyndicates = append(o.R.FoundedBySyndicates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &syndicateR{
				FoundedBy: o,
			}
		} else {
			rel.R.FoundedBy = o
		}
	}
	return nil
}

// AddSystemMessages adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.SystemMessages.
// Sets related.R.Player appropriately.
func (o *Player) AddSystemMessages(exec boil.Executor, insert bool, related ...*SystemMessage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"system_messages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, systemMessagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			SystemMessages: related,
		}
	} else {
		o.R.SystemMessages = append(o.R.SystemMessages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &systemMessageR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddSenderSystemMessages adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.SenderSystemMessages.
// Sets related.R.Sender appropriately.
func (o *Player) AddSenderSystemMessages(exec boil.Executor, insert bool, related ...*SystemMessage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SenderID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"system_messages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"sender_id"}),
				strmangle.WhereClause("\"", "\"", 2, systemMessagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SenderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			SenderSystemMessages: related,
		}
	} else {
		o.R.SenderSystemMessages = append(o.R.SenderSystemMessages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &systemMessageR{
				Sender: o,
			}
		} else {
			rel.R.Sender = o
		}
	}
	return nil
}

// Players retrieves all the records using an executor.
func Players(mods ...qm.QueryMod) playerQuery {
	mods = append(mods, qm.From("\"players\""), qmhelper.WhereIsNull("\"players\".\"deleted_at\""))
	return playerQuery{NewQuery(mods...)}
}

// FindPlayer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPlayer(exec boil.Executor, iD string, selectCols ...string) (*Player, error) {
	playerObj := &Player{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"players\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, playerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from players")
	}

	if err = playerObj.doAfterSelectHooks(exec); err != nil {
		return playerObj, err
	}

	return playerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Player) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no players provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	playerInsertCacheMut.RLock()
	cache, cached := playerInsertCache[key]
	playerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(playerType, playerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"players\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"players\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into players")
	}

	if !cached {
		playerInsertCacheMut.Lock()
		playerInsertCache[key] = cache
		playerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the Player.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Player) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	playerUpdateCacheMut.RLock()
	cache, cached := playerUpdateCache[key]
	playerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update players, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, playerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update players row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for players")
	}

	if !cached {
		playerUpdateCacheMut.Lock()
		playerUpdateCache[key] = cache
		playerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q playerQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for players")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PlayerSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, playerPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all player")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Player) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no players provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	playerUpsertCacheMut.RLock()
	cache, cached := playerUpsertCache[key]
	playerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert players, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(playerPrimaryKeyColumns))
			copy(conflict, playerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"players\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(playerType, playerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert players")
	}

	if !cached {
		playerUpsertCacheMut.Lock()
		playerUpsertCache[key] = cache
		playerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single Player record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Player) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no Player provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), playerPrimaryKeyMapping)
		sql = "DELETE FROM \"players\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for players")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q playerQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no playerQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for players")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PlayerSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(playerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"players\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, playerPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for players")
	}

	if len(playerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Player) Reload(exec boil.Executor) error {
	ret, err := FindPlayer(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PlayerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"players\".* FROM \"players\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in PlayerSlice")
	}

	*o = slice

	return nil
}

// PlayerExists checks if the Player row exists.
func PlayerExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"players\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if players exists")
	}

	return exists, nil
}
