// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/shopspring/decimal"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Player is an object representing the database table.
type Player struct {
	ID               string          `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	FactionID        null.String     `boiler:"faction_id" boil:"faction_id" json:"faction_id,omitempty" toml:"faction_id" yaml:"faction_id,omitempty"`
	Username         null.String     `boiler:"username" boil:"username" json:"username,omitempty" toml:"username" yaml:"username,omitempty"`
	PublicAddress    null.String     `boiler:"public_address" boil:"public_address" json:"public_address,omitempty" toml:"public_address" yaml:"public_address,omitempty"`
	IsAi             bool            `boiler:"is_ai" boil:"is_ai" json:"is_ai" toml:"is_ai" yaml:"is_ai"`
	DeletedAt        null.Time       `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	UpdatedAt        time.Time       `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt        time.Time       `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	MobileNumber     null.String     `boiler:"mobile_number" boil:"mobile_number" json:"mobile_number,omitempty" toml:"mobile_number" yaml:"mobile_number,omitempty"`
	IssuePunishFee   decimal.Decimal `boiler:"issue_punish_fee" boil:"issue_punish_fee" json:"issue_punish_fee" toml:"issue_punish_fee" yaml:"issue_punish_fee"`
	ReportedCost     decimal.Decimal `boiler:"reported_cost" boil:"reported_cost" json:"reported_cost" toml:"reported_cost" yaml:"reported_cost"`
	Gid              int             `boiler:"gid" boil:"gid" json:"gid" toml:"gid" yaml:"gid"`
	Rank             string          `boiler:"rank" boil:"rank" json:"rank" toml:"rank" yaml:"rank"`
	SentMessageCount int             `boiler:"sent_message_count" boil:"sent_message_count" json:"sent_message_count" toml:"sent_message_count" yaml:"sent_message_count"`

	R *playerR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L playerL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PlayerColumns = struct {
	ID               string
	FactionID        string
	Username         string
	PublicAddress    string
	IsAi             string
	DeletedAt        string
	UpdatedAt        string
	CreatedAt        string
	MobileNumber     string
	IssuePunishFee   string
	ReportedCost     string
	Gid              string
	Rank             string
	SentMessageCount string
}{
	ID:               "id",
	FactionID:        "faction_id",
	Username:         "username",
	PublicAddress:    "public_address",
	IsAi:             "is_ai",
	DeletedAt:        "deleted_at",
	UpdatedAt:        "updated_at",
	CreatedAt:        "created_at",
	MobileNumber:     "mobile_number",
	IssuePunishFee:   "issue_punish_fee",
	ReportedCost:     "reported_cost",
	Gid:              "gid",
	Rank:             "rank",
	SentMessageCount: "sent_message_count",
}

var PlayerTableColumns = struct {
	ID               string
	FactionID        string
	Username         string
	PublicAddress    string
	IsAi             string
	DeletedAt        string
	UpdatedAt        string
	CreatedAt        string
	MobileNumber     string
	IssuePunishFee   string
	ReportedCost     string
	Gid              string
	Rank             string
	SentMessageCount string
}{
	ID:               "players.id",
	FactionID:        "players.faction_id",
	Username:         "players.username",
	PublicAddress:    "players.public_address",
	IsAi:             "players.is_ai",
	DeletedAt:        "players.deleted_at",
	UpdatedAt:        "players.updated_at",
	CreatedAt:        "players.created_at",
	MobileNumber:     "players.mobile_number",
	IssuePunishFee:   "players.issue_punish_fee",
	ReportedCost:     "players.reported_cost",
	Gid:              "players.gid",
	Rank:             "players.rank",
	SentMessageCount: "players.sent_message_count",
}

// Generated where

var PlayerWhere = struct {
	ID               whereHelperstring
	FactionID        whereHelpernull_String
	Username         whereHelpernull_String
	PublicAddress    whereHelpernull_String
	IsAi             whereHelperbool
	DeletedAt        whereHelpernull_Time
	UpdatedAt        whereHelpertime_Time
	CreatedAt        whereHelpertime_Time
	MobileNumber     whereHelpernull_String
	IssuePunishFee   whereHelperdecimal_Decimal
	ReportedCost     whereHelperdecimal_Decimal
	Gid              whereHelperint
	Rank             whereHelperstring
	SentMessageCount whereHelperint
}{
	ID:               whereHelperstring{field: "\"players\".\"id\""},
	FactionID:        whereHelpernull_String{field: "\"players\".\"faction_id\""},
	Username:         whereHelpernull_String{field: "\"players\".\"username\""},
	PublicAddress:    whereHelpernull_String{field: "\"players\".\"public_address\""},
	IsAi:             whereHelperbool{field: "\"players\".\"is_ai\""},
	DeletedAt:        whereHelpernull_Time{field: "\"players\".\"deleted_at\""},
	UpdatedAt:        whereHelpertime_Time{field: "\"players\".\"updated_at\""},
	CreatedAt:        whereHelpertime_Time{field: "\"players\".\"created_at\""},
	MobileNumber:     whereHelpernull_String{field: "\"players\".\"mobile_number\""},
	IssuePunishFee:   whereHelperdecimal_Decimal{field: "\"players\".\"issue_punish_fee\""},
	ReportedCost:     whereHelperdecimal_Decimal{field: "\"players\".\"reported_cost\""},
	Gid:              whereHelperint{field: "\"players\".\"gid\""},
	Rank:             whereHelperstring{field: "\"players\".\"rank\""},
	SentMessageCount: whereHelperint{field: "\"players\".\"sent_message_count\""},
}

// PlayerRels is where relationship names are stored.
var PlayerRels = struct {
	Faction                     string
	PlayerSettingsPreference    string
	IDPlayerStat                string
	OwnerAmmos                  string
	BattleAbilityTriggers       string
	BattleContracts             string
	BattleContributions         string
	OwnerBattleMechs            string
	OwnerBattleQueues           string
	Battles                     string
	OwnerBattleWins             string
	ChatHistories               string
	OwnerCollectionItems        string
	ConsumedByConsumedAbilities string
	MVPPlayerFactionStats       string
	OwnerMechsOlds              string
	OwnerPlayerAbilities        string
	PlayerActiveLogs            string
	PlayerFingerprints          string
	PlayerKeycards              string
	PlayerKillLogs              string
	PlayerLanguages             string
	PlayerMultipliers           string
	PlayerPreferences           string
	PlayerSpoilsOfWars          string
	PlayersPunishVotes          string
	IssuedByPunishVotes         string
	ReportedPlayerPunishVotes   string
	PunishedPlayers             string
	OwnerWeaponSkins            string
}{
	Faction:                     "Faction",
	PlayerSettingsPreference:    "PlayerSettingsPreference",
	IDPlayerStat:                "IDPlayerStat",
	OwnerAmmos:                  "OwnerAmmos",
	BattleAbilityTriggers:       "BattleAbilityTriggers",
	BattleContracts:             "BattleContracts",
	BattleContributions:         "BattleContributions",
	OwnerBattleMechs:            "OwnerBattleMechs",
	OwnerBattleQueues:           "OwnerBattleQueues",
	Battles:                     "Battles",
	OwnerBattleWins:             "OwnerBattleWins",
	ChatHistories:               "ChatHistories",
	OwnerCollectionItems:        "OwnerCollectionItems",
	ConsumedByConsumedAbilities: "ConsumedByConsumedAbilities",
	MVPPlayerFactionStats:       "MVPPlayerFactionStats",
	OwnerMechsOlds:              "OwnerMechsOlds",
	OwnerPlayerAbilities:        "OwnerPlayerAbilities",
	PlayerActiveLogs:            "PlayerActiveLogs",
	PlayerFingerprints:          "PlayerFingerprints",
	PlayerKeycards:              "PlayerKeycards",
	PlayerKillLogs:              "PlayerKillLogs",
	PlayerLanguages:             "PlayerLanguages",
	PlayerMultipliers:           "PlayerMultipliers",
	PlayerPreferences:           "PlayerPreferences",
	PlayerSpoilsOfWars:          "PlayerSpoilsOfWars",
	PlayersPunishVotes:          "PlayersPunishVotes",
	IssuedByPunishVotes:         "IssuedByPunishVotes",
	ReportedPlayerPunishVotes:   "ReportedPlayerPunishVotes",
	PunishedPlayers:             "PunishedPlayers",
	OwnerWeaponSkins:            "OwnerWeaponSkins",
}

// playerR is where relationships are stored.
type playerR struct {
	Faction                     *Faction                  `boiler:"Faction" boil:"Faction" json:"Faction" toml:"Faction" yaml:"Faction"`
	PlayerSettingsPreference    *PlayerSettingsPreference `boiler:"PlayerSettingsPreference" boil:"PlayerSettingsPreference" json:"PlayerSettingsPreference" toml:"PlayerSettingsPreference" yaml:"PlayerSettingsPreference"`
	IDPlayerStat                *PlayerStat               `boiler:"IDPlayerStat" boil:"IDPlayerStat" json:"IDPlayerStat" toml:"IDPlayerStat" yaml:"IDPlayerStat"`
	OwnerAmmos                  AmmoSlice                 `boiler:"OwnerAmmos" boil:"OwnerAmmos" json:"OwnerAmmos" toml:"OwnerAmmos" yaml:"OwnerAmmos"`
	BattleAbilityTriggers       BattleAbilityTriggerSlice `boiler:"BattleAbilityTriggers" boil:"BattleAbilityTriggers" json:"BattleAbilityTriggers" toml:"BattleAbilityTriggers" yaml:"BattleAbilityTriggers"`
	BattleContracts             BattleContractSlice       `boiler:"BattleContracts" boil:"BattleContracts" json:"BattleContracts" toml:"BattleContracts" yaml:"BattleContracts"`
	BattleContributions         BattleContributionSlice   `boiler:"BattleContributions" boil:"BattleContributions" json:"BattleContributions" toml:"BattleContributions" yaml:"BattleContributions"`
	OwnerBattleMechs            BattleMechSlice           `boiler:"OwnerBattleMechs" boil:"OwnerBattleMechs" json:"OwnerBattleMechs" toml:"OwnerBattleMechs" yaml:"OwnerBattleMechs"`
	OwnerBattleQueues           BattleQueueSlice          `boiler:"OwnerBattleQueues" boil:"OwnerBattleQueues" json:"OwnerBattleQueues" toml:"OwnerBattleQueues" yaml:"OwnerBattleQueues"`
	Battles                     BattleSlice               `boiler:"Battles" boil:"Battles" json:"Battles" toml:"Battles" yaml:"Battles"`
	OwnerBattleWins             BattleWinSlice            `boiler:"OwnerBattleWins" boil:"OwnerBattleWins" json:"OwnerBattleWins" toml:"OwnerBattleWins" yaml:"OwnerBattleWins"`
	ChatHistories               ChatHistorySlice          `boiler:"ChatHistories" boil:"ChatHistories" json:"ChatHistories" toml:"ChatHistories" yaml:"ChatHistories"`
	OwnerCollectionItems        CollectionItemSlice       `boiler:"OwnerCollectionItems" boil:"OwnerCollectionItems" json:"OwnerCollectionItems" toml:"OwnerCollectionItems" yaml:"OwnerCollectionItems"`
	ConsumedByConsumedAbilities ConsumedAbilitySlice      `boiler:"ConsumedByConsumedAbilities" boil:"ConsumedByConsumedAbilities" json:"ConsumedByConsumedAbilities" toml:"ConsumedByConsumedAbilities" yaml:"ConsumedByConsumedAbilities"`
	MVPPlayerFactionStats       FactionStatSlice          `boiler:"MVPPlayerFactionStats" boil:"MVPPlayerFactionStats" json:"MVPPlayerFactionStats" toml:"MVPPlayerFactionStats" yaml:"MVPPlayerFactionStats"`
	OwnerMechsOlds              MechsOldSlice             `boiler:"OwnerMechsOlds" boil:"OwnerMechsOlds" json:"OwnerMechsOlds" toml:"OwnerMechsOlds" yaml:"OwnerMechsOlds"`
	OwnerPlayerAbilities        PlayerAbilitySlice        `boiler:"OwnerPlayerAbilities" boil:"OwnerPlayerAbilities" json:"OwnerPlayerAbilities" toml:"OwnerPlayerAbilities" yaml:"OwnerPlayerAbilities"`
	PlayerActiveLogs            PlayerActiveLogSlice      `boiler:"PlayerActiveLogs" boil:"PlayerActiveLogs" json:"PlayerActiveLogs" toml:"PlayerActiveLogs" yaml:"PlayerActiveLogs"`
	PlayerFingerprints          PlayerFingerprintSlice    `boiler:"PlayerFingerprints" boil:"PlayerFingerprints" json:"PlayerFingerprints" toml:"PlayerFingerprints" yaml:"PlayerFingerprints"`
	PlayerKeycards              PlayerKeycardSlice        `boiler:"PlayerKeycards" boil:"PlayerKeycards" json:"PlayerKeycards" toml:"PlayerKeycards" yaml:"PlayerKeycards"`
	PlayerKillLogs              PlayerKillLogSlice        `boiler:"PlayerKillLogs" boil:"PlayerKillLogs" json:"PlayerKillLogs" toml:"PlayerKillLogs" yaml:"PlayerKillLogs"`
	PlayerLanguages             PlayerLanguageSlice       `boiler:"PlayerLanguages" boil:"PlayerLanguages" json:"PlayerLanguages" toml:"PlayerLanguages" yaml:"PlayerLanguages"`
	PlayerMultipliers           PlayerMultiplierSlice     `boiler:"PlayerMultipliers" boil:"PlayerMultipliers" json:"PlayerMultipliers" toml:"PlayerMultipliers" yaml:"PlayerMultipliers"`
	PlayerPreferences           PlayerPreferenceSlice     `boiler:"PlayerPreferences" boil:"PlayerPreferences" json:"PlayerPreferences" toml:"PlayerPreferences" yaml:"PlayerPreferences"`
	PlayerSpoilsOfWars          PlayerSpoilsOfWarSlice    `boiler:"PlayerSpoilsOfWars" boil:"PlayerSpoilsOfWars" json:"PlayerSpoilsOfWars" toml:"PlayerSpoilsOfWars" yaml:"PlayerSpoilsOfWars"`
	PlayersPunishVotes          PlayersPunishVoteSlice    `boiler:"PlayersPunishVotes" boil:"PlayersPunishVotes" json:"PlayersPunishVotes" toml:"PlayersPunishVotes" yaml:"PlayersPunishVotes"`
	IssuedByPunishVotes         PunishVoteSlice           `boiler:"IssuedByPunishVotes" boil:"IssuedByPunishVotes" json:"IssuedByPunishVotes" toml:"IssuedByPunishVotes" yaml:"IssuedByPunishVotes"`
	ReportedPlayerPunishVotes   PunishVoteSlice           `boiler:"ReportedPlayerPunishVotes" boil:"ReportedPlayerPunishVotes" json:"ReportedPlayerPunishVotes" toml:"ReportedPlayerPunishVotes" yaml:"ReportedPlayerPunishVotes"`
	PunishedPlayers             PunishedPlayerSlice       `boiler:"PunishedPlayers" boil:"PunishedPlayers" json:"PunishedPlayers" toml:"PunishedPlayers" yaml:"PunishedPlayers"`
	OwnerWeaponSkins            WeaponSkinSlice           `boiler:"OwnerWeaponSkins" boil:"OwnerWeaponSkins" json:"OwnerWeaponSkins" toml:"OwnerWeaponSkins" yaml:"OwnerWeaponSkins"`
}

// NewStruct creates a new relationship struct
func (*playerR) NewStruct() *playerR {
	return &playerR{}
}

// playerL is where Load methods for each relationship are stored.
type playerL struct{}

var (
	playerAllColumns            = []string{"id", "faction_id", "username", "public_address", "is_ai", "deleted_at", "updated_at", "created_at", "mobile_number", "issue_punish_fee", "reported_cost", "gid", "rank", "sent_message_count"}
	playerColumnsWithoutDefault = []string{"id"}
	playerColumnsWithDefault    = []string{"faction_id", "username", "public_address", "is_ai", "deleted_at", "updated_at", "created_at", "mobile_number", "issue_punish_fee", "reported_cost", "gid", "rank", "sent_message_count"}
	playerPrimaryKeyColumns     = []string{"id"}
	playerGeneratedColumns      = []string{}
)

type (
	// PlayerSlice is an alias for a slice of pointers to Player.
	// This should almost always be used instead of []Player.
	PlayerSlice []*Player
	// PlayerHook is the signature for custom Player hook methods
	PlayerHook func(boil.Executor, *Player) error

	playerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	playerType                 = reflect.TypeOf(&Player{})
	playerMapping              = queries.MakeStructMapping(playerType)
	playerPrimaryKeyMapping, _ = queries.BindMapping(playerType, playerMapping, playerPrimaryKeyColumns)
	playerInsertCacheMut       sync.RWMutex
	playerInsertCache          = make(map[string]insertCache)
	playerUpdateCacheMut       sync.RWMutex
	playerUpdateCache          = make(map[string]updateCache)
	playerUpsertCacheMut       sync.RWMutex
	playerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var playerAfterSelectHooks []PlayerHook

var playerBeforeInsertHooks []PlayerHook
var playerAfterInsertHooks []PlayerHook

var playerBeforeUpdateHooks []PlayerHook
var playerAfterUpdateHooks []PlayerHook

var playerBeforeDeleteHooks []PlayerHook
var playerAfterDeleteHooks []PlayerHook

var playerBeforeUpsertHooks []PlayerHook
var playerAfterUpsertHooks []PlayerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Player) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Player) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Player) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Player) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Player) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Player) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Player) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Player) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Player) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPlayerHook registers your hook function for all future operations.
func AddPlayerHook(hookPoint boil.HookPoint, playerHook PlayerHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		playerAfterSelectHooks = append(playerAfterSelectHooks, playerHook)
	case boil.BeforeInsertHook:
		playerBeforeInsertHooks = append(playerBeforeInsertHooks, playerHook)
	case boil.AfterInsertHook:
		playerAfterInsertHooks = append(playerAfterInsertHooks, playerHook)
	case boil.BeforeUpdateHook:
		playerBeforeUpdateHooks = append(playerBeforeUpdateHooks, playerHook)
	case boil.AfterUpdateHook:
		playerAfterUpdateHooks = append(playerAfterUpdateHooks, playerHook)
	case boil.BeforeDeleteHook:
		playerBeforeDeleteHooks = append(playerBeforeDeleteHooks, playerHook)
	case boil.AfterDeleteHook:
		playerAfterDeleteHooks = append(playerAfterDeleteHooks, playerHook)
	case boil.BeforeUpsertHook:
		playerBeforeUpsertHooks = append(playerBeforeUpsertHooks, playerHook)
	case boil.AfterUpsertHook:
		playerAfterUpsertHooks = append(playerAfterUpsertHooks, playerHook)
	}
}

// One returns a single player record from the query.
func (q playerQuery) One(exec boil.Executor) (*Player, error) {
	o := &Player{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for players")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Player records from the query.
func (q playerQuery) All(exec boil.Executor) (PlayerSlice, error) {
	var o []*Player

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to Player slice")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Player records in the query.
func (q playerQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count players rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q playerQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if players exists")
	}

	return count > 0, nil
}

// Faction pointed to by the foreign key.
func (o *Player) Faction(mods ...qm.QueryMod) factionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FactionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Factions(queryMods...)
	queries.SetFrom(query.Query, "\"factions\"")

	return query
}

// PlayerSettingsPreference pointed to by the foreign key.
func (o *Player) PlayerSettingsPreference(mods ...qm.QueryMod) playerSettingsPreferenceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"player_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := PlayerSettingsPreferences(queryMods...)
	queries.SetFrom(query.Query, "\"player_settings_preferences\"")

	return query
}

// IDPlayerStat pointed to by the foreign key.
func (o *Player) IDPlayerStat(mods ...qm.QueryMod) playerStatQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := PlayerStats(queryMods...)
	queries.SetFrom(query.Query, "\"player_stats\"")

	return query
}

// OwnerAmmos retrieves all the ammo's Ammos with an executor via owner_id column.
func (o *Player) OwnerAmmos(mods ...qm.QueryMod) ammoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"ammo\".\"owner_id\"=?", o.ID),
	)

	query := Ammos(queryMods...)
	queries.SetFrom(query.Query, "\"ammo\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"ammo\".*"})
	}

	return query
}

// BattleAbilityTriggers retrieves all the battle_ability_trigger's BattleAbilityTriggers with an executor.
func (o *Player) BattleAbilityTriggers(mods ...qm.QueryMod) battleAbilityTriggerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_ability_triggers\".\"player_id\"=?", o.ID),
	)

	query := BattleAbilityTriggers(queryMods...)
	queries.SetFrom(query.Query, "\"battle_ability_triggers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_ability_triggers\".*"})
	}

	return query
}

// BattleContracts retrieves all the battle_contract's BattleContracts with an executor.
func (o *Player) BattleContracts(mods ...qm.QueryMod) battleContractQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contracts\".\"player_id\"=?", o.ID),
	)

	query := BattleContracts(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contracts\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contracts\".*"})
	}

	return query
}

// BattleContributions retrieves all the battle_contribution's BattleContributions with an executor.
func (o *Player) BattleContributions(mods ...qm.QueryMod) battleContributionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contributions\".\"player_id\"=?", o.ID),
	)

	query := BattleContributions(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contributions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contributions\".*"})
	}

	return query
}

// OwnerBattleMechs retrieves all the battle_mech's BattleMechs with an executor via owner_id column.
func (o *Player) OwnerBattleMechs(mods ...qm.QueryMod) battleMechQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_mechs\".\"owner_id\"=?", o.ID),
	)

	query := BattleMechs(queryMods...)
	queries.SetFrom(query.Query, "\"battle_mechs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_mechs\".*"})
	}

	return query
}

// OwnerBattleQueues retrieves all the battle_queue's BattleQueues with an executor via owner_id column.
func (o *Player) OwnerBattleQueues(mods ...qm.QueryMod) battleQueueQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_queue\".\"owner_id\"=?", o.ID),
	)

	query := BattleQueues(queryMods...)
	queries.SetFrom(query.Query, "\"battle_queue\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_queue\".*"})
	}

	return query
}

// Battles retrieves all the battle's Battles with an executor.
func (o *Player) Battles(mods ...qm.QueryMod) battleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"battle_viewers\" on \"battles\".\"id\" = \"battle_viewers\".\"battle_id\""),
		qm.Where("\"battle_viewers\".\"player_id\"=?", o.ID),
	)

	query := Battles(queryMods...)
	queries.SetFrom(query.Query, "\"battles\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battles\".*"})
	}

	return query
}

// OwnerBattleWins retrieves all the battle_win's BattleWins with an executor via owner_id column.
func (o *Player) OwnerBattleWins(mods ...qm.QueryMod) battleWinQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_wins\".\"owner_id\"=?", o.ID),
	)

	query := BattleWins(queryMods...)
	queries.SetFrom(query.Query, "\"battle_wins\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_wins\".*"})
	}

	return query
}

// ChatHistories retrieves all the chat_history's ChatHistories with an executor.
func (o *Player) ChatHistories(mods ...qm.QueryMod) chatHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"chat_history\".\"player_id\"=?", o.ID),
	)

	query := ChatHistories(queryMods...)
	queries.SetFrom(query.Query, "\"chat_history\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"chat_history\".*"})
	}

	return query
}

// OwnerCollectionItems retrieves all the collection_item's CollectionItems with an executor via owner_id column.
func (o *Player) OwnerCollectionItems(mods ...qm.QueryMod) collectionItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"collection_items\".\"owner_id\"=?", o.ID),
	)

	query := CollectionItems(queryMods...)
	queries.SetFrom(query.Query, "\"collection_items\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"collection_items\".*"})
	}

	return query
}

// ConsumedByConsumedAbilities retrieves all the consumed_ability's ConsumedAbilities with an executor via consumed_by column.
func (o *Player) ConsumedByConsumedAbilities(mods ...qm.QueryMod) consumedAbilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"consumed_abilities\".\"consumed_by\"=?", o.ID),
	)

	query := ConsumedAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"consumed_abilities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"consumed_abilities\".*"})
	}

	return query
}

// MVPPlayerFactionStats retrieves all the faction_stat's FactionStats with an executor via mvp_player_id column.
func (o *Player) MVPPlayerFactionStats(mods ...qm.QueryMod) factionStatQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"faction_stats\".\"mvp_player_id\"=?", o.ID),
	)

	query := FactionStats(queryMods...)
	queries.SetFrom(query.Query, "\"faction_stats\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"faction_stats\".*"})
	}

	return query
}

// OwnerMechsOlds retrieves all the mechs_old's MechsOlds with an executor via owner_id column.
func (o *Player) OwnerMechsOlds(mods ...qm.QueryMod) mechsOldQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mechs_old\".\"owner_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"mechs_old\".\"deleted_at\""),
	)

	query := MechsOlds(queryMods...)
	queries.SetFrom(query.Query, "\"mechs_old\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mechs_old\".*"})
	}

	return query
}

// OwnerPlayerAbilities retrieves all the player_ability's PlayerAbilities with an executor via owner_id column.
func (o *Player) OwnerPlayerAbilities(mods ...qm.QueryMod) playerAbilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_abilities\".\"owner_id\"=?", o.ID),
	)

	query := PlayerAbilities(queryMods...)
	queries.SetFrom(query.Query, "\"player_abilities\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_abilities\".*"})
	}

	return query
}

// PlayerActiveLogs retrieves all the player_active_log's PlayerActiveLogs with an executor.
func (o *Player) PlayerActiveLogs(mods ...qm.QueryMod) playerActiveLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_active_logs\".\"player_id\"=?", o.ID),
	)

	query := PlayerActiveLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_active_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_active_logs\".*"})
	}

	return query
}

// PlayerFingerprints retrieves all the player_fingerprint's PlayerFingerprints with an executor.
func (o *Player) PlayerFingerprints(mods ...qm.QueryMod) playerFingerprintQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_fingerprints\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_fingerprints\".\"deleted_at\""),
	)

	query := PlayerFingerprints(queryMods...)
	queries.SetFrom(query.Query, "\"player_fingerprints\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_fingerprints\".*"})
	}

	return query
}

// PlayerKeycards retrieves all the player_keycard's PlayerKeycards with an executor.
func (o *Player) PlayerKeycards(mods ...qm.QueryMod) playerKeycardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_keycards\".\"player_id\"=?", o.ID),
	)

	query := PlayerKeycards(queryMods...)
	queries.SetFrom(query.Query, "\"player_keycards\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_keycards\".*"})
	}

	return query
}

// PlayerKillLogs retrieves all the player_kill_log's PlayerKillLogs with an executor.
func (o *Player) PlayerKillLogs(mods ...qm.QueryMod) playerKillLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_kill_log\".\"player_id\"=?", o.ID),
	)

	query := PlayerKillLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_kill_log\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_kill_log\".*"})
	}

	return query
}

// PlayerLanguages retrieves all the player_language's PlayerLanguages with an executor.
func (o *Player) PlayerLanguages(mods ...qm.QueryMod) playerLanguageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_languages\".\"player_id\"=?", o.ID),
	)

	query := PlayerLanguages(queryMods...)
	queries.SetFrom(query.Query, "\"player_languages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_languages\".*"})
	}

	return query
}

// PlayerMultipliers retrieves all the player_multiplier's PlayerMultipliers with an executor.
func (o *Player) PlayerMultipliers(mods ...qm.QueryMod) playerMultiplierQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_multipliers\".\"player_id\"=?", o.ID),
	)

	query := PlayerMultipliers(queryMods...)
	queries.SetFrom(query.Query, "\"player_multipliers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_multipliers\".*"})
	}

	return query
}

// PlayerPreferences retrieves all the player_preference's PlayerPreferences with an executor.
func (o *Player) PlayerPreferences(mods ...qm.QueryMod) playerPreferenceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_preferences\".\"player_id\"=?", o.ID),
	)

	query := PlayerPreferences(queryMods...)
	queries.SetFrom(query.Query, "\"player_preferences\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_preferences\".*"})
	}

	return query
}

// PlayerSpoilsOfWars retrieves all the player_spoils_of_war's PlayerSpoilsOfWars with an executor.
func (o *Player) PlayerSpoilsOfWars(mods ...qm.QueryMod) playerSpoilsOfWarQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_spoils_of_war\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_spoils_of_war\".\"deleted_at\""),
	)

	query := PlayerSpoilsOfWars(queryMods...)
	queries.SetFrom(query.Query, "\"player_spoils_of_war\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_spoils_of_war\".*"})
	}

	return query
}

// PlayersPunishVotes retrieves all the players_punish_vote's PlayersPunishVotes with an executor.
func (o *Player) PlayersPunishVotes(mods ...qm.QueryMod) playersPunishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players_punish_votes\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"players_punish_votes\".\"deleted_at\""),
	)

	query := PlayersPunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"players_punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players_punish_votes\".*"})
	}

	return query
}

// IssuedByPunishVotes retrieves all the punish_vote's PunishVotes with an executor via issued_by_id column.
func (o *Player) IssuedByPunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"issued_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// ReportedPlayerPunishVotes retrieves all the punish_vote's PunishVotes with an executor via reported_player_id column.
func (o *Player) ReportedPlayerPunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"reported_player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// PunishedPlayers retrieves all the punished_player's PunishedPlayers with an executor.
func (o *Player) PunishedPlayers(mods ...qm.QueryMod) punishedPlayerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punished_players\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punished_players\".\"deleted_at\""),
	)

	query := PunishedPlayers(queryMods...)
	queries.SetFrom(query.Query, "\"punished_players\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punished_players\".*"})
	}

	return query
}

// OwnerWeaponSkins retrieves all the weapon_skin's WeaponSkins with an executor via owner_id column.
func (o *Player) OwnerWeaponSkins(mods ...qm.QueryMod) weaponSkinQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"weapon_skin\".\"owner_id\"=?", o.ID),
	)

	query := WeaponSkins(queryMods...)
	queries.SetFrom(query.Query, "\"weapon_skin\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"weapon_skin\".*"})
	}

	return query
}

// LoadFaction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadFaction(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		if !queries.IsNil(object.FactionID) {
			args = append(args, object.FactionID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FactionID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.FactionID) {
				args = append(args, obj.FactionID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`factions`),
		qm.WhereIn(`factions.id in ?`, args...),
		qmhelper.WhereIsNull(`factions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Faction")
	}

	var resultSlice []*Faction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Faction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factions")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Faction = foreign
		if foreign.R == nil {
			foreign.R = &factionR{}
		}
		foreign.R.Players = append(foreign.R.Players, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.FactionID, foreign.ID) {
				local.R.Faction = foreign
				if foreign.R == nil {
					foreign.R = &factionR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadPlayerSettingsPreference allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (playerL) LoadPlayerSettingsPreference(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_settings_preferences`),
		qm.WhereIn(`player_settings_preferences.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PlayerSettingsPreference")
	}

	var resultSlice []*PlayerSettingsPreference
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PlayerSettingsPreference")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for player_settings_preferences")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_settings_preferences")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PlayerSettingsPreference = foreign
		if foreign.R == nil {
			foreign.R = &playerSettingsPreferenceR{}
		}
		foreign.R.Player = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerSettingsPreference = foreign
				if foreign.R == nil {
					foreign.R = &playerSettingsPreferenceR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadIDPlayerStat allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (playerL) LoadIDPlayerStat(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_stats`),
		qm.WhereIn(`player_stats.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PlayerStat")
	}

	var resultSlice []*PlayerStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PlayerStat")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for player_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_stats")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IDPlayerStat = foreign
		if foreign.R == nil {
			foreign.R = &playerStatR{}
		}
		foreign.R.IDPlayer = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.ID {
				local.R.IDPlayerStat = foreign
				if foreign.R == nil {
					foreign.R = &playerStatR{}
				}
				foreign.R.IDPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerAmmos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerAmmos(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`ammo`),
		qm.WhereIn(`ammo.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ammo")
	}

	var resultSlice []*Ammo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ammo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on ammo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for ammo")
	}

	if len(ammoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerAmmos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &ammoR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerAmmos = append(local.R.OwnerAmmos, foreign)
				if foreign.R == nil {
					foreign.R = &ammoR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadBattleAbilityTriggers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleAbilityTriggers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_ability_triggers`),
		qm.WhereIn(`battle_ability_triggers.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_ability_triggers")
	}

	var resultSlice []*BattleAbilityTrigger
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_ability_triggers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_ability_triggers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_ability_triggers")
	}

	if len(battleAbilityTriggerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleAbilityTriggers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleAbilityTriggerR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PlayerID) {
				local.R.BattleAbilityTriggers = append(local.R.BattleAbilityTriggers, foreign)
				if foreign.R == nil {
					foreign.R = &battleAbilityTriggerR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContracts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleContracts(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contracts`),
		qm.WhereIn(`battle_contracts.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contracts")
	}

	var resultSlice []*BattleContract
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contracts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contracts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contracts")
	}

	if len(battleContractAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContracts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContractR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.BattleContracts = append(local.R.BattleContracts, foreign)
				if foreign.R == nil {
					foreign.R = &battleContractR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContributions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleContributions(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contributions`),
		qm.WhereIn(`battle_contributions.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contributions")
	}

	var resultSlice []*BattleContribution
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contributions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contributions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contributions")
	}

	if len(battleContributionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContributions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContributionR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.BattleContributions = append(local.R.BattleContributions, foreign)
				if foreign.R == nil {
					foreign.R = &battleContributionR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleMechs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleMechs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_mechs`),
		qm.WhereIn(`battle_mechs.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_mechs")
	}

	var resultSlice []*BattleMech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_mechs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_mechs")
	}

	if len(battleMechAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleMechs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleMechR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleMechs = append(local.R.OwnerBattleMechs, foreign)
				if foreign.R == nil {
					foreign.R = &battleMechR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleQueues allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleQueues(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_queue`),
		qm.WhereIn(`battle_queue.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_queue")
	}

	var resultSlice []*BattleQueue
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_queue")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_queue")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_queue")
	}

	if len(battleQueueAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleQueues = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleQueueR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleQueues = append(local.R.OwnerBattleQueues, foreign)
				if foreign.R == nil {
					foreign.R = &battleQueueR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadBattles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattles(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"battles\".id, \"battles\".game_map_id, \"battles\".started_at, \"battles\".ended_at, \"battles\".battle_number, \"battles\".started_battle_seconds, \"battles\".ended_battle_seconds, \"a\".\"player_id\""),
		qm.From("\"battles\""),
		qm.InnerJoin("\"battle_viewers\" as \"a\" on \"battles\".\"id\" = \"a\".\"battle_id\""),
		qm.WhereIn("\"a\".\"player_id\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battles")
	}

	var resultSlice []*Battle

	var localJoinCols []string
	for results.Next() {
		one := new(Battle)
		var localJoinCol string

		err = results.Scan(&one.ID, &one.GameMapID, &one.StartedAt, &one.EndedAt, &one.BattleNumber, &one.StartedBattleSeconds, &one.EndedBattleSeconds, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for battles")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice battles")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battles")
	}

	if len(battleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Battles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleR{}
			}
			foreign.R.Players = append(foreign.R.Players, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.Battles = append(local.R.Battles, foreign)
				if foreign.R == nil {
					foreign.R = &battleR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleWins allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleWins(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_wins`),
		qm.WhereIn(`battle_wins.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_wins")
	}

	var resultSlice []*BattleWin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_wins")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_wins")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_wins")
	}

	if len(battleWinAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleWins = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleWinR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleWins = append(local.R.OwnerBattleWins, foreign)
				if foreign.R == nil {
					foreign.R = &battleWinR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadChatHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadChatHistories(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`chat_history`),
		qm.WhereIn(`chat_history.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load chat_history")
	}

	var resultSlice []*ChatHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice chat_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on chat_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chat_history")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ChatHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &chatHistoryR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.ChatHistories = append(local.R.ChatHistories, foreign)
				if foreign.R == nil {
					foreign.R = &chatHistoryR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerCollectionItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerCollectionItems(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`collection_items`),
		qm.WhereIn(`collection_items.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load collection_items")
	}

	var resultSlice []*CollectionItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice collection_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on collection_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for collection_items")
	}

	if len(collectionItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerCollectionItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &collectionItemR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerCollectionItems = append(local.R.OwnerCollectionItems, foreign)
				if foreign.R == nil {
					foreign.R = &collectionItemR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadConsumedByConsumedAbilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadConsumedByConsumedAbilities(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`consumed_abilities`),
		qm.WhereIn(`consumed_abilities.consumed_by in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load consumed_abilities")
	}

	var resultSlice []*ConsumedAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice consumed_abilities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on consumed_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for consumed_abilities")
	}

	if len(consumedAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ConsumedByConsumedAbilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &consumedAbilityR{}
			}
			foreign.R.ConsumedByPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ConsumedBy {
				local.R.ConsumedByConsumedAbilities = append(local.R.ConsumedByConsumedAbilities, foreign)
				if foreign.R == nil {
					foreign.R = &consumedAbilityR{}
				}
				foreign.R.ConsumedByPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadMVPPlayerFactionStats allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadMVPPlayerFactionStats(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`faction_stats`),
		qm.WhereIn(`faction_stats.mvp_player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load faction_stats")
	}

	var resultSlice []*FactionStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice faction_stats")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on faction_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for faction_stats")
	}

	if len(factionStatAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MVPPlayerFactionStats = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &factionStatR{}
			}
			foreign.R.MVPPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MVPPlayerID) {
				local.R.MVPPlayerFactionStats = append(local.R.MVPPlayerFactionStats, foreign)
				if foreign.R == nil {
					foreign.R = &factionStatR{}
				}
				foreign.R.MVPPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerMechsOlds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerMechsOlds(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mechs_old`),
		qm.WhereIn(`mechs_old.owner_id in ?`, args...),
		qmhelper.WhereIsNull(`mechs_old.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mechs_old")
	}

	var resultSlice []*MechsOld
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mechs_old")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mechs_old")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mechs_old")
	}

	if len(mechsOldAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerMechsOlds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mechsOldR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerMechsOlds = append(local.R.OwnerMechsOlds, foreign)
				if foreign.R == nil {
					foreign.R = &mechsOldR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerPlayerAbilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerPlayerAbilities(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_abilities`),
		qm.WhereIn(`player_abilities.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_abilities")
	}

	var resultSlice []*PlayerAbility
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_abilities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_abilities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_abilities")
	}

	if len(playerAbilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerPlayerAbilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerAbilityR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerPlayerAbilities = append(local.R.OwnerPlayerAbilities, foreign)
				if foreign.R == nil {
					foreign.R = &playerAbilityR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerActiveLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerActiveLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_active_logs`),
		qm.WhereIn(`player_active_logs.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_active_logs")
	}

	var resultSlice []*PlayerActiveLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_active_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_active_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_active_logs")
	}

	if len(playerActiveLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerActiveLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerActiveLogR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerActiveLogs = append(local.R.PlayerActiveLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerActiveLogR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerFingerprints allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerFingerprints(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_fingerprints`),
		qm.WhereIn(`player_fingerprints.player_id in ?`, args...),
		qmhelper.WhereIsNull(`player_fingerprints.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_fingerprints")
	}

	var resultSlice []*PlayerFingerprint
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_fingerprints")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_fingerprints")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_fingerprints")
	}

	if len(playerFingerprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerFingerprints = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerFingerprintR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerFingerprints = append(local.R.PlayerFingerprints, foreign)
				if foreign.R == nil {
					foreign.R = &playerFingerprintR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerKeycards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerKeycards(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_keycards`),
		qm.WhereIn(`player_keycards.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_keycards")
	}

	var resultSlice []*PlayerKeycard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_keycards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_keycards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_keycards")
	}

	if len(playerKeycardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerKeycards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerKeycardR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerKeycards = append(local.R.PlayerKeycards, foreign)
				if foreign.R == nil {
					foreign.R = &playerKeycardR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerKillLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerKillLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_kill_log`),
		qm.WhereIn(`player_kill_log.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_kill_log")
	}

	var resultSlice []*PlayerKillLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_kill_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_kill_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_kill_log")
	}

	if len(playerKillLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerKillLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerKillLogR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerKillLogs = append(local.R.PlayerKillLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerKillLogR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerLanguages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerLanguages(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_languages`),
		qm.WhereIn(`player_languages.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_languages")
	}

	var resultSlice []*PlayerLanguage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_languages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_languages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_languages")
	}

	if len(playerLanguageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerLanguages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerLanguageR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerLanguages = append(local.R.PlayerLanguages, foreign)
				if foreign.R == nil {
					foreign.R = &playerLanguageR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerMultipliers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerMultipliers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_multipliers`),
		qm.WhereIn(`player_multipliers.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_multipliers")
	}

	var resultSlice []*PlayerMultiplier
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_multipliers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_multipliers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_multipliers")
	}

	if len(playerMultiplierAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerMultipliers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerMultiplierR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerMultipliers = append(local.R.PlayerMultipliers, foreign)
				if foreign.R == nil {
					foreign.R = &playerMultiplierR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerPreferences allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerPreferences(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_preferences`),
		qm.WhereIn(`player_preferences.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_preferences")
	}

	var resultSlice []*PlayerPreference
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_preferences")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_preferences")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_preferences")
	}

	if len(playerPreferenceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerPreferences = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerPreferenceR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerPreferences = append(local.R.PlayerPreferences, foreign)
				if foreign.R == nil {
					foreign.R = &playerPreferenceR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerSpoilsOfWars allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerSpoilsOfWars(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_spoils_of_war`),
		qm.WhereIn(`player_spoils_of_war.player_id in ?`, args...),
		qmhelper.WhereIsNull(`player_spoils_of_war.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_spoils_of_war")
	}

	var resultSlice []*PlayerSpoilsOfWar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_spoils_of_war")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_spoils_of_war")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_spoils_of_war")
	}

	if len(playerSpoilsOfWarAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerSpoilsOfWars = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerSpoilsOfWarR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerSpoilsOfWars = append(local.R.PlayerSpoilsOfWars, foreign)
				if foreign.R == nil {
					foreign.R = &playerSpoilsOfWarR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayersPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayersPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players_punish_votes`),
		qm.WhereIn(`players_punish_votes.player_id in ?`, args...),
		qmhelper.WhereIsNull(`players_punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players_punish_votes")
	}

	var resultSlice []*PlayersPunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players_punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players_punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players_punish_votes")
	}

	if len(playersPunishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayersPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playersPunishVoteR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayersPunishVotes = append(local.R.PlayersPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &playersPunishVoteR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadIssuedByPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadIssuedByPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.issued_by_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.IssuedByPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.IssuedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.IssuedByID {
				local.R.IssuedByPunishVotes = append(local.R.IssuedByPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.IssuedBy = local
				break
			}
		}
	}

	return nil
}

// LoadReportedPlayerPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadReportedPlayerPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.reported_player_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReportedPlayerPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.ReportedPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReportedPlayerID {
				local.R.ReportedPlayerPunishVotes = append(local.R.ReportedPlayerPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.ReportedPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadPunishedPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPunishedPlayers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punished_players`),
		qm.WhereIn(`punished_players.player_id in ?`, args...),
		qmhelper.WhereIsNull(`punished_players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punished_players")
	}

	var resultSlice []*PunishedPlayer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punished_players")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punished_players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punished_players")
	}

	if len(punishedPlayerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PunishedPlayers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishedPlayerR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PunishedPlayers = append(local.R.PunishedPlayers, foreign)
				if foreign.R == nil {
					foreign.R = &punishedPlayerR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerWeaponSkins allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerWeaponSkins(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`weapon_skin`),
		qm.WhereIn(`weapon_skin.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load weapon_skin")
	}

	var resultSlice []*WeaponSkin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice weapon_skin")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on weapon_skin")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for weapon_skin")
	}

	if len(weaponSkinAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerWeaponSkins = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &weaponSkinR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerWeaponSkins = append(local.R.OwnerWeaponSkins, foreign)
				if foreign.R == nil {
					foreign.R = &weaponSkinR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// SetFaction of the player to the related item.
// Sets o.R.Faction to related.
// Adds o to related.R.Players.
func (o *Player) SetFaction(exec boil.Executor, insert bool, related *Faction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.FactionID, related.ID)
	if o.R == nil {
		o.R = &playerR{
			Faction: related,
		}
	} else {
		o.R.Faction = related
	}

	if related.R == nil {
		related.R = &factionR{
			Players: PlayerSlice{o},
		}
	} else {
		related.R.Players = append(related.R.Players, o)
	}

	return nil
}

// RemoveFaction relationship.
// Sets o.R.Faction to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Player) RemoveFaction(exec boil.Executor, related *Faction) error {
	var err error

	queries.SetScanner(&o.FactionID, nil)
	if _, err = o.Update(exec, boil.Whitelist("faction_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Faction = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Players {
		if queries.Equal(o.FactionID, ri.FactionID) {
			continue
		}

		ln := len(related.R.Players)
		if ln > 1 && i < ln-1 {
			related.R.Players[i] = related.R.Players[ln-1]
		}
		related.R.Players = related.R.Players[:ln-1]
		break
	}
	return nil
}

// SetPlayerSettingsPreference of the player to the related item.
// Sets o.R.PlayerSettingsPreference to related.
// Adds o to related.R.Player.
func (o *Player) SetPlayerSettingsPreference(exec boil.Executor, insert bool, related *PlayerSettingsPreference) error {
	var err error

	if insert {
		related.PlayerID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"player_settings_preferences\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
			strmangle.WhereClause("\"", "\"", 2, playerSettingsPreferencePrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PlayerID = o.ID

	}

	if o.R == nil {
		o.R = &playerR{
			PlayerSettingsPreference: related,
		}
	} else {
		o.R.PlayerSettingsPreference = related
	}

	if related.R == nil {
		related.R = &playerSettingsPreferenceR{
			Player: o,
		}
	} else {
		related.R.Player = o
	}
	return nil
}

// SetIDPlayerStat of the player to the related item.
// Sets o.R.IDPlayerStat to related.
// Adds o to related.R.IDPlayer.
func (o *Player) SetIDPlayerStat(exec boil.Executor, insert bool, related *PlayerStat) error {
	var err error

	if insert {
		related.ID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"player_stats\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"id"}),
			strmangle.WhereClause("\"", "\"", 2, playerStatPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.ID = o.ID

	}

	if o.R == nil {
		o.R = &playerR{
			IDPlayerStat: related,
		}
	} else {
		o.R.IDPlayerStat = related
	}

	if related.R == nil {
		related.R = &playerStatR{
			IDPlayer: o,
		}
	} else {
		related.R.IDPlayer = o
	}
	return nil
}

// AddOwnerAmmos adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerAmmos.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerAmmos(exec boil.Executor, insert bool, related ...*Ammo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"ammo\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, ammoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BlueprintID, rel.OwnerID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerAmmos: related,
		}
	} else {
		o.R.OwnerAmmos = append(o.R.OwnerAmmos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &ammoR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddBattleAbilityTriggers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleAbilityTriggers.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_ability_triggers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleAbilityTriggerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleAbilityTriggers: related,
		}
	} else {
		o.R.BattleAbilityTriggers = append(o.R.BattleAbilityTriggers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleAbilityTriggerR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// SetBattleAbilityTriggers removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Player's BattleAbilityTriggers accordingly.
// Replaces o.R.BattleAbilityTriggers with related.
// Sets related.R.Player's BattleAbilityTriggers accordingly.
func (o *Player) SetBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	query := "update \"battle_ability_triggers\" set \"player_id\" = null where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BattleAbilityTriggers {
			queries.SetScanner(&rel.PlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Player = nil
		}

		o.R.BattleAbilityTriggers = nil
	}
	return o.AddBattleAbilityTriggers(exec, insert, related...)
}

// RemoveBattleAbilityTriggers relationships from objects passed in.
// Removes related items from R.BattleAbilityTriggers (uses pointer comparison, removal does not keep order)
// Sets related.R.Player.
func (o *Player) RemoveBattleAbilityTriggers(exec boil.Executor, related ...*BattleAbilityTrigger) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PlayerID, nil)
		if rel.R != nil {
			rel.R.Player = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BattleAbilityTriggers {
			if rel != ri {
				continue
			}

			ln := len(o.R.BattleAbilityTriggers)
			if ln > 1 && i < ln-1 {
				o.R.BattleAbilityTriggers[i] = o.R.BattleAbilityTriggers[ln-1]
			}
			o.R.BattleAbilityTriggers = o.R.BattleAbilityTriggers[:ln-1]
			break
		}
	}

	return nil
}

// AddBattleContracts adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleContracts.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleContracts(exec boil.Executor, insert bool, related ...*BattleContract) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contracts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContractPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleContracts: related,
		}
	} else {
		o.R.BattleContracts = append(o.R.BattleContracts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContractR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddBattleContributions adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleContributions.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleContributions(exec boil.Executor, insert bool, related ...*BattleContribution) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contributions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContributionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleContributions: related,
		}
	} else {
		o.R.BattleContributions = append(o.R.BattleContributions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContributionR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddOwnerBattleMechs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleMechs.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleMechs(exec boil.Executor, insert bool, related ...*BattleMech) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_mechs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleMechPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleMechs: related,
		}
	} else {
		o.R.OwnerBattleMechs = append(o.R.OwnerBattleMechs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleMechR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddOwnerBattleQueues adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleQueues.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleQueues(exec boil.Executor, insert bool, related ...*BattleQueue) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_queue\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleQueuePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleQueues: related,
		}
	} else {
		o.R.OwnerBattleQueues = append(o.R.OwnerBattleQueues, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleQueueR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddBattles adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Battles.
// Sets related.R.Players appropriately.
func (o *Player) AddBattles(exec boil.Executor, insert bool, related ...*Battle) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"battle_viewers\" (\"player_id\", \"battle_id\") values ($1, $2)"
		values := []interface{}{o.ID, rel.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, query)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		_, err = exec.Exec(query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &playerR{
			Battles: related,
		}
	} else {
		o.R.Battles = append(o.R.Battles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleR{
				Players: PlayerSlice{o},
			}
		} else {
			rel.R.Players = append(rel.R.Players, o)
		}
	}
	return nil
}

// SetBattles removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Players's Battles accordingly.
// Replaces o.R.Battles with related.
// Sets related.R.Players's Battles accordingly.
func (o *Player) SetBattles(exec boil.Executor, insert bool, related ...*Battle) error {
	query := "delete from \"battle_viewers\" where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeBattlesFromPlayersSlice(o, related)
	if o.R != nil {
		o.R.Battles = nil
	}
	return o.AddBattles(exec, insert, related...)
}

// RemoveBattles relationships from objects passed in.
// Removes related items from R.Battles (uses pointer comparison, removal does not keep order)
// Sets related.R.Players.
func (o *Player) RemoveBattles(exec boil.Executor, related ...*Battle) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"battle_viewers\" where \"player_id\" = $1 and \"battle_id\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeBattlesFromPlayersSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Battles {
			if rel != ri {
				continue
			}

			ln := len(o.R.Battles)
			if ln > 1 && i < ln-1 {
				o.R.Battles[i] = o.R.Battles[ln-1]
			}
			o.R.Battles = o.R.Battles[:ln-1]
			break
		}
	}

	return nil
}

func removeBattlesFromPlayersSlice(o *Player, related []*Battle) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Players {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Players)
			if ln > 1 && i < ln-1 {
				rel.R.Players[i] = rel.R.Players[ln-1]
			}
			rel.R.Players = rel.R.Players[:ln-1]
			break
		}
	}
}

// AddOwnerBattleWins adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleWins.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleWins(exec boil.Executor, insert bool, related ...*BattleWin) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_wins\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleWinPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleWins: related,
		}
	} else {
		o.R.OwnerBattleWins = append(o.R.OwnerBattleWins, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleWinR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddChatHistories adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ChatHistories.
// Sets related.R.Player appropriately.
func (o *Player) AddChatHistories(exec boil.Executor, insert bool, related ...*ChatHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"chat_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ChatHistories: related,
		}
	} else {
		o.R.ChatHistories = append(o.R.ChatHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &chatHistoryR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddOwnerCollectionItems adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerCollectionItems.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerCollectionItems(exec boil.Executor, insert bool, related ...*CollectionItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"collection_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, collectionItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerCollectionItems: related,
		}
	} else {
		o.R.OwnerCollectionItems = append(o.R.OwnerCollectionItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &collectionItemR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddConsumedByConsumedAbilities adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ConsumedByConsumedAbilities.
// Sets related.R.ConsumedByPlayer appropriately.
func (o *Player) AddConsumedByConsumedAbilities(exec boil.Executor, insert bool, related ...*ConsumedAbility) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ConsumedBy = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"consumed_abilities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"consumed_by"}),
				strmangle.WhereClause("\"", "\"", 2, consumedAbilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ConsumedBy = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ConsumedByConsumedAbilities: related,
		}
	} else {
		o.R.ConsumedByConsumedAbilities = append(o.R.ConsumedByConsumedAbilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &consumedAbilityR{
				ConsumedByPlayer: o,
			}
		} else {
			rel.R.ConsumedByPlayer = o
		}
	}
	return nil
}

// AddMVPPlayerFactionStats adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.MVPPlayerFactionStats.
// Sets related.R.MVPPlayer appropriately.
func (o *Player) AddMVPPlayerFactionStats(exec boil.Executor, insert bool, related ...*FactionStat) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MVPPlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"faction_stats\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"mvp_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, factionStatPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MVPPlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			MVPPlayerFactionStats: related,
		}
	} else {
		o.R.MVPPlayerFactionStats = append(o.R.MVPPlayerFactionStats, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &factionStatR{
				MVPPlayer: o,
			}
		} else {
			rel.R.MVPPlayer = o
		}
	}
	return nil
}

// SetMVPPlayerFactionStats removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MVPPlayer's MVPPlayerFactionStats accordingly.
// Replaces o.R.MVPPlayerFactionStats with related.
// Sets related.R.MVPPlayer's MVPPlayerFactionStats accordingly.
func (o *Player) SetMVPPlayerFactionStats(exec boil.Executor, insert bool, related ...*FactionStat) error {
	query := "update \"faction_stats\" set \"mvp_player_id\" = null where \"mvp_player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MVPPlayerFactionStats {
			queries.SetScanner(&rel.MVPPlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MVPPlayer = nil
		}

		o.R.MVPPlayerFactionStats = nil
	}
	return o.AddMVPPlayerFactionStats(exec, insert, related...)
}

// RemoveMVPPlayerFactionStats relationships from objects passed in.
// Removes related items from R.MVPPlayerFactionStats (uses pointer comparison, removal does not keep order)
// Sets related.R.MVPPlayer.
func (o *Player) RemoveMVPPlayerFactionStats(exec boil.Executor, related ...*FactionStat) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MVPPlayerID, nil)
		if rel.R != nil {
			rel.R.MVPPlayer = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("mvp_player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MVPPlayerFactionStats {
			if rel != ri {
				continue
			}

			ln := len(o.R.MVPPlayerFactionStats)
			if ln > 1 && i < ln-1 {
				o.R.MVPPlayerFactionStats[i] = o.R.MVPPlayerFactionStats[ln-1]
			}
			o.R.MVPPlayerFactionStats = o.R.MVPPlayerFactionStats[:ln-1]
			break
		}
	}

	return nil
}

// AddOwnerMechsOlds adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerMechsOlds.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerMechsOlds(exec boil.Executor, insert bool, related ...*MechsOld) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mechs_old\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, mechsOldPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerMechsOlds: related,
		}
	} else {
		o.R.OwnerMechsOlds = append(o.R.OwnerMechsOlds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mechsOldR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddOwnerPlayerAbilities adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerPlayerAbilities.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerPlayerAbilities(exec boil.Executor, insert bool, related ...*PlayerAbility) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_abilities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerAbilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerPlayerAbilities: related,
		}
	} else {
		o.R.OwnerPlayerAbilities = append(o.R.OwnerPlayerAbilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerAbilityR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddPlayerActiveLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerActiveLogs.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerActiveLogs(exec boil.Executor, insert bool, related ...*PlayerActiveLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_active_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerActiveLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerActiveLogs: related,
		}
	} else {
		o.R.PlayerActiveLogs = append(o.R.PlayerActiveLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerActiveLogR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerFingerprints adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerFingerprints.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerFingerprints(exec boil.Executor, insert bool, related ...*PlayerFingerprint) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_fingerprints\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerFingerprintPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.FingerprintID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerFingerprints: related,
		}
	} else {
		o.R.PlayerFingerprints = append(o.R.PlayerFingerprints, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerFingerprintR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerKeycards adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerKeycards.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerKeycards(exec boil.Executor, insert bool, related ...*PlayerKeycard) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_keycards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerKeycardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerKeycards: related,
		}
	} else {
		o.R.PlayerKeycards = append(o.R.PlayerKeycards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerKeycardR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerKillLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerKillLogs.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerKillLogs(exec boil.Executor, insert bool, related ...*PlayerKillLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_kill_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerKillLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerKillLogs: related,
		}
	} else {
		o.R.PlayerKillLogs = append(o.R.PlayerKillLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerKillLogR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerLanguages adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerLanguages.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerLanguages(exec boil.Executor, insert bool, related ...*PlayerLanguage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_languages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerLanguagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerLanguages: related,
		}
	} else {
		o.R.PlayerLanguages = append(o.R.PlayerLanguages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerLanguageR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerMultipliers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerMultipliers.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerMultipliers(exec boil.Executor, insert bool, related ...*PlayerMultiplier) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_multipliers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerMultiplierPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerMultipliers: related,
		}
	} else {
		o.R.PlayerMultipliers = append(o.R.PlayerMultipliers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerMultiplierR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerPreferences adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerPreferences.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerPreferences(exec boil.Executor, insert bool, related ...*PlayerPreference) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_preferences\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerPreferencePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.Key}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerPreferences: related,
		}
	} else {
		o.R.PlayerPreferences = append(o.R.PlayerPreferences, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerPreferenceR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerSpoilsOfWars adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerSpoilsOfWars.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerSpoilsOfWars(exec boil.Executor, insert bool, related ...*PlayerSpoilsOfWar) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_spoils_of_war\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerSpoilsOfWarPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerSpoilsOfWars: related,
		}
	} else {
		o.R.PlayerSpoilsOfWars = append(o.R.PlayerSpoilsOfWars, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerSpoilsOfWarR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayersPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayersPunishVotes.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayersPunishVotes(exec boil.Executor, insert bool, related ...*PlayersPunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players_punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playersPunishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayersPunishVotes: related,
		}
	} else {
		o.R.PlayersPunishVotes = append(o.R.PlayersPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playersPunishVoteR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddIssuedByPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.IssuedByPunishVotes.
// Sets related.R.IssuedBy appropriately.
func (o *Player) AddIssuedByPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.IssuedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"issued_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.IssuedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			IssuedByPunishVotes: related,
		}
	} else {
		o.R.IssuedByPunishVotes = append(o.R.IssuedByPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				IssuedBy: o,
			}
		} else {
			rel.R.IssuedBy = o
		}
	}
	return nil
}

// AddReportedPlayerPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ReportedPlayerPunishVotes.
// Sets related.R.ReportedPlayer appropriately.
func (o *Player) AddReportedPlayerPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReportedPlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"reported_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReportedPlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ReportedPlayerPunishVotes: related,
		}
	} else {
		o.R.ReportedPlayerPunishVotes = append(o.R.ReportedPlayerPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				ReportedPlayer: o,
			}
		} else {
			rel.R.ReportedPlayer = o
		}
	}
	return nil
}

// AddPunishedPlayers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PunishedPlayers.
// Sets related.R.Player appropriately.
func (o *Player) AddPunishedPlayers(exec boil.Executor, insert bool, related ...*PunishedPlayer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punished_players\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishedPlayerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PunishedPlayers: related,
		}
	} else {
		o.R.PunishedPlayers = append(o.R.PunishedPlayers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishedPlayerR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddOwnerWeaponSkins adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerWeaponSkins.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerWeaponSkins(exec boil.Executor, insert bool, related ...*WeaponSkin) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"weapon_skin\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, weaponSkinPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerWeaponSkins: related,
		}
	} else {
		o.R.OwnerWeaponSkins = append(o.R.OwnerWeaponSkins, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &weaponSkinR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// Players retrieves all the records using an executor.
func Players(mods ...qm.QueryMod) playerQuery {
	mods = append(mods, qm.From("\"players\""), qmhelper.WhereIsNull("\"players\".\"deleted_at\""))
	return playerQuery{NewQuery(mods...)}
}

// FindPlayer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPlayer(exec boil.Executor, iD string, selectCols ...string) (*Player, error) {
	playerObj := &Player{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"players\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, playerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from players")
	}

	if err = playerObj.doAfterSelectHooks(exec); err != nil {
		return playerObj, err
	}

	return playerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Player) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no players provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	playerInsertCacheMut.RLock()
	cache, cached := playerInsertCache[key]
	playerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(playerType, playerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"players\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"players\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into players")
	}

	if !cached {
		playerInsertCacheMut.Lock()
		playerInsertCache[key] = cache
		playerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the Player.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Player) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	playerUpdateCacheMut.RLock()
	cache, cached := playerUpdateCache[key]
	playerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update players, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, playerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update players row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for players")
	}

	if !cached {
		playerUpdateCacheMut.Lock()
		playerUpdateCache[key] = cache
		playerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q playerQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for players")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PlayerSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, playerPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all player")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Player) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no players provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	playerUpsertCacheMut.RLock()
	cache, cached := playerUpsertCache[key]
	playerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert players, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(playerPrimaryKeyColumns))
			copy(conflict, playerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"players\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(playerType, playerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert players")
	}

	if !cached {
		playerUpsertCacheMut.Lock()
		playerUpsertCache[key] = cache
		playerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single Player record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Player) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no Player provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), playerPrimaryKeyMapping)
		sql = "DELETE FROM \"players\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for players")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q playerQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no playerQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for players")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PlayerSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(playerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"players\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, playerPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for players")
	}

	if len(playerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Player) Reload(exec boil.Executor) error {
	ret, err := FindPlayer(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PlayerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"players\".* FROM \"players\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in PlayerSlice")
	}

	*o = slice

	return nil
}

// PlayerExists checks if the Player row exists.
func PlayerExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"players\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if players exists")
	}

	return exists, nil
}
