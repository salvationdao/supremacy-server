// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/shopspring/decimal"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Player is an object representing the database table.
type Player struct {
	ID               string          `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	FactionID        null.String     `boiler:"faction_id" boil:"faction_id" json:"faction_id,omitempty" toml:"faction_id" yaml:"faction_id,omitempty"`
	Username         null.String     `boiler:"username" boil:"username" json:"username,omitempty" toml:"username" yaml:"username,omitempty"`
	PublicAddress    null.String     `boiler:"public_address" boil:"public_address" json:"public_address,omitempty" toml:"public_address" yaml:"public_address,omitempty"`
	IsAi             bool            `boiler:"is_ai" boil:"is_ai" json:"is_ai" toml:"is_ai" yaml:"is_ai"`
	DeletedAt        null.Time       `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	UpdatedAt        time.Time       `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt        time.Time       `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	MobileNumber     null.String     `boiler:"mobile_number" boil:"mobile_number" json:"mobile_number,omitempty" toml:"mobile_number" yaml:"mobile_number,omitempty"`
	IssuePunishFee   decimal.Decimal `boiler:"issue_punish_fee" boil:"issue_punish_fee" json:"issue_punish_fee" toml:"issue_punish_fee" yaml:"issue_punish_fee"`
	ReportedCost     decimal.Decimal `boiler:"reported_cost" boil:"reported_cost" json:"reported_cost" toml:"reported_cost" yaml:"reported_cost"`
	Gid              int             `boiler:"gid" boil:"gid" json:"gid" toml:"gid" yaml:"gid"`
	Rank             string          `boiler:"rank" boil:"rank" json:"rank" toml:"rank" yaml:"rank"`
	SentMessageCount int             `boiler:"sent_message_count" boil:"sent_message_count" json:"sent_message_count" toml:"sent_message_count" yaml:"sent_message_count"`

	R *playerR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L playerL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PlayerColumns = struct {
	ID               string
	FactionID        string
	Username         string
	PublicAddress    string
	IsAi             string
	DeletedAt        string
	UpdatedAt        string
	CreatedAt        string
	MobileNumber     string
	IssuePunishFee   string
	ReportedCost     string
	Gid              string
	Rank             string
	SentMessageCount string
}{
	ID:               "id",
	FactionID:        "faction_id",
	Username:         "username",
	PublicAddress:    "public_address",
	IsAi:             "is_ai",
	DeletedAt:        "deleted_at",
	UpdatedAt:        "updated_at",
	CreatedAt:        "created_at",
	MobileNumber:     "mobile_number",
	IssuePunishFee:   "issue_punish_fee",
	ReportedCost:     "reported_cost",
	Gid:              "gid",
	Rank:             "rank",
	SentMessageCount: "sent_message_count",
}

var PlayerTableColumns = struct {
	ID               string
	FactionID        string
	Username         string
	PublicAddress    string
	IsAi             string
	DeletedAt        string
	UpdatedAt        string
	CreatedAt        string
	MobileNumber     string
	IssuePunishFee   string
	ReportedCost     string
	Gid              string
	Rank             string
	SentMessageCount string
}{
	ID:               "players.id",
	FactionID:        "players.faction_id",
	Username:         "players.username",
	PublicAddress:    "players.public_address",
	IsAi:             "players.is_ai",
	DeletedAt:        "players.deleted_at",
	UpdatedAt:        "players.updated_at",
	CreatedAt:        "players.created_at",
	MobileNumber:     "players.mobile_number",
	IssuePunishFee:   "players.issue_punish_fee",
	ReportedCost:     "players.reported_cost",
	Gid:              "players.gid",
	Rank:             "players.rank",
	SentMessageCount: "players.sent_message_count",
}

// Generated where

var PlayerWhere = struct {
	ID               whereHelperstring
	FactionID        whereHelpernull_String
	Username         whereHelpernull_String
	PublicAddress    whereHelpernull_String
	IsAi             whereHelperbool
	DeletedAt        whereHelpernull_Time
	UpdatedAt        whereHelpertime_Time
	CreatedAt        whereHelpertime_Time
	MobileNumber     whereHelpernull_String
	IssuePunishFee   whereHelperdecimal_Decimal
	ReportedCost     whereHelperdecimal_Decimal
	Gid              whereHelperint
	Rank             whereHelperstring
	SentMessageCount whereHelperint
}{
	ID:               whereHelperstring{field: "\"players\".\"id\""},
	FactionID:        whereHelpernull_String{field: "\"players\".\"faction_id\""},
	Username:         whereHelpernull_String{field: "\"players\".\"username\""},
	PublicAddress:    whereHelpernull_String{field: "\"players\".\"public_address\""},
	IsAi:             whereHelperbool{field: "\"players\".\"is_ai\""},
	DeletedAt:        whereHelpernull_Time{field: "\"players\".\"deleted_at\""},
	UpdatedAt:        whereHelpertime_Time{field: "\"players\".\"updated_at\""},
	CreatedAt:        whereHelpertime_Time{field: "\"players\".\"created_at\""},
	MobileNumber:     whereHelpernull_String{field: "\"players\".\"mobile_number\""},
	IssuePunishFee:   whereHelperdecimal_Decimal{field: "\"players\".\"issue_punish_fee\""},
	ReportedCost:     whereHelperdecimal_Decimal{field: "\"players\".\"reported_cost\""},
	Gid:              whereHelperint{field: "\"players\".\"gid\""},
	Rank:             whereHelperstring{field: "\"players\".\"rank\""},
	SentMessageCount: whereHelperint{field: "\"players\".\"sent_message_count\""},
}

// PlayerRels is where relationship names are stored.
var PlayerRels = struct {
	Faction                   string
	IDUserStat                string
	BattleAbilityTriggers     string
	BattleContracts           string
	BattleContributions       string
	OwnerBattleMechs          string
	OwnerBattleQueues         string
	OwnerBattleWins           string
	Battles                   string
	ChatHistories             string
	MVPPlayerFactionStats     string
	OwnerMechs                string
	ToUserPendingTransactions string
	PlayerActiveLogs          string
	PlayerKillLogs            string
	PlayerLanguages           string
	PlayerPreferences         string
	PlayersPunishVotes        string
	IssuedByPunishVotes       string
	ReportedPlayerPunishVotes string
	PunishedPlayers           string
	TelegramPlayers           string
	UserMultipliers           string
	Users                     string
}{
	Faction:                   "Faction",
	IDUserStat:                "IDUserStat",
	BattleAbilityTriggers:     "BattleAbilityTriggers",
	BattleContracts:           "BattleContracts",
	BattleContributions:       "BattleContributions",
	OwnerBattleMechs:          "OwnerBattleMechs",
	OwnerBattleQueues:         "OwnerBattleQueues",
	OwnerBattleWins:           "OwnerBattleWins",
	Battles:                   "Battles",
	ChatHistories:             "ChatHistories",
	MVPPlayerFactionStats:     "MVPPlayerFactionStats",
	OwnerMechs:                "OwnerMechs",
	ToUserPendingTransactions: "ToUserPendingTransactions",
	PlayerActiveLogs:          "PlayerActiveLogs",
	PlayerKillLogs:            "PlayerKillLogs",
	PlayerLanguages:           "PlayerLanguages",
	PlayerPreferences:         "PlayerPreferences",
	PlayersPunishVotes:        "PlayersPunishVotes",
	IssuedByPunishVotes:       "IssuedByPunishVotes",
	ReportedPlayerPunishVotes: "ReportedPlayerPunishVotes",
	PunishedPlayers:           "PunishedPlayers",
	TelegramPlayers:           "TelegramPlayers",
	UserMultipliers:           "UserMultipliers",
	Users:                     "Users",
}

// playerR is where relationships are stored.
type playerR struct {
	Faction                   *Faction                  `boiler:"Faction" boil:"Faction" json:"Faction" toml:"Faction" yaml:"Faction"`
	IDUserStat                *UserStat                 `boiler:"IDUserStat" boil:"IDUserStat" json:"IDUserStat" toml:"IDUserStat" yaml:"IDUserStat"`
	BattleAbilityTriggers     BattleAbilityTriggerSlice `boiler:"BattleAbilityTriggers" boil:"BattleAbilityTriggers" json:"BattleAbilityTriggers" toml:"BattleAbilityTriggers" yaml:"BattleAbilityTriggers"`
	BattleContracts           BattleContractSlice       `boiler:"BattleContracts" boil:"BattleContracts" json:"BattleContracts" toml:"BattleContracts" yaml:"BattleContracts"`
	BattleContributions       BattleContributionSlice   `boiler:"BattleContributions" boil:"BattleContributions" json:"BattleContributions" toml:"BattleContributions" yaml:"BattleContributions"`
	OwnerBattleMechs          BattleMechSlice           `boiler:"OwnerBattleMechs" boil:"OwnerBattleMechs" json:"OwnerBattleMechs" toml:"OwnerBattleMechs" yaml:"OwnerBattleMechs"`
	OwnerBattleQueues         BattleQueueSlice          `boiler:"OwnerBattleQueues" boil:"OwnerBattleQueues" json:"OwnerBattleQueues" toml:"OwnerBattleQueues" yaml:"OwnerBattleQueues"`
	OwnerBattleWins           BattleWinSlice            `boiler:"OwnerBattleWins" boil:"OwnerBattleWins" json:"OwnerBattleWins" toml:"OwnerBattleWins" yaml:"OwnerBattleWins"`
	Battles                   BattleSlice               `boiler:"Battles" boil:"Battles" json:"Battles" toml:"Battles" yaml:"Battles"`
	ChatHistories             ChatHistorySlice          `boiler:"ChatHistories" boil:"ChatHistories" json:"ChatHistories" toml:"ChatHistories" yaml:"ChatHistories"`
	MVPPlayerFactionStats     FactionStatSlice          `boiler:"MVPPlayerFactionStats" boil:"MVPPlayerFactionStats" json:"MVPPlayerFactionStats" toml:"MVPPlayerFactionStats" yaml:"MVPPlayerFactionStats"`
	OwnerMechs                MechSlice                 `boiler:"OwnerMechs" boil:"OwnerMechs" json:"OwnerMechs" toml:"OwnerMechs" yaml:"OwnerMechs"`
	ToUserPendingTransactions PendingTransactionSlice   `boiler:"ToUserPendingTransactions" boil:"ToUserPendingTransactions" json:"ToUserPendingTransactions" toml:"ToUserPendingTransactions" yaml:"ToUserPendingTransactions"`
	PlayerActiveLogs          PlayerActiveLogSlice      `boiler:"PlayerActiveLogs" boil:"PlayerActiveLogs" json:"PlayerActiveLogs" toml:"PlayerActiveLogs" yaml:"PlayerActiveLogs"`
	PlayerKillLogs            PlayerKillLogSlice        `boiler:"PlayerKillLogs" boil:"PlayerKillLogs" json:"PlayerKillLogs" toml:"PlayerKillLogs" yaml:"PlayerKillLogs"`
	PlayerLanguages           PlayerLanguageSlice       `boiler:"PlayerLanguages" boil:"PlayerLanguages" json:"PlayerLanguages" toml:"PlayerLanguages" yaml:"PlayerLanguages"`
	PlayerPreferences         PlayerPreferenceSlice     `boiler:"PlayerPreferences" boil:"PlayerPreferences" json:"PlayerPreferences" toml:"PlayerPreferences" yaml:"PlayerPreferences"`
	PlayersPunishVotes        PlayersPunishVoteSlice    `boiler:"PlayersPunishVotes" boil:"PlayersPunishVotes" json:"PlayersPunishVotes" toml:"PlayersPunishVotes" yaml:"PlayersPunishVotes"`
	IssuedByPunishVotes       PunishVoteSlice           `boiler:"IssuedByPunishVotes" boil:"IssuedByPunishVotes" json:"IssuedByPunishVotes" toml:"IssuedByPunishVotes" yaml:"IssuedByPunishVotes"`
	ReportedPlayerPunishVotes PunishVoteSlice           `boiler:"ReportedPlayerPunishVotes" boil:"ReportedPlayerPunishVotes" json:"ReportedPlayerPunishVotes" toml:"ReportedPlayerPunishVotes" yaml:"ReportedPlayerPunishVotes"`
	PunishedPlayers           PunishedPlayerSlice       `boiler:"PunishedPlayers" boil:"PunishedPlayers" json:"PunishedPlayers" toml:"PunishedPlayers" yaml:"PunishedPlayers"`
	TelegramPlayers           TelegramPlayerSlice       `boiler:"TelegramPlayers" boil:"TelegramPlayers" json:"TelegramPlayers" toml:"TelegramPlayers" yaml:"TelegramPlayers"`
	UserMultipliers           UserMultiplierSlice       `boiler:"UserMultipliers" boil:"UserMultipliers" json:"UserMultipliers" toml:"UserMultipliers" yaml:"UserMultipliers"`
	Users                     UserSlice                 `boiler:"Users" boil:"Users" json:"Users" toml:"Users" yaml:"Users"`
}

// NewStruct creates a new relationship struct
func (*playerR) NewStruct() *playerR {
	return &playerR{}
}

// playerL is where Load methods for each relationship are stored.
type playerL struct{}

var (
	playerAllColumns            = []string{"id", "faction_id", "username", "public_address", "is_ai", "deleted_at", "updated_at", "created_at", "mobile_number", "issue_punish_fee", "reported_cost", "gid", "rank", "sent_message_count"}
	playerColumnsWithoutDefault = []string{"id"}
	playerColumnsWithDefault    = []string{"faction_id", "username", "public_address", "is_ai", "deleted_at", "updated_at", "created_at", "mobile_number", "issue_punish_fee", "reported_cost", "gid", "rank", "sent_message_count"}
	playerPrimaryKeyColumns     = []string{"id"}
	playerGeneratedColumns      = []string{}
)

type (
	// PlayerSlice is an alias for a slice of pointers to Player.
	// This should almost always be used instead of []Player.
	PlayerSlice []*Player
	// PlayerHook is the signature for custom Player hook methods
	PlayerHook func(boil.Executor, *Player) error

	playerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	playerType                 = reflect.TypeOf(&Player{})
	playerMapping              = queries.MakeStructMapping(playerType)
	playerPrimaryKeyMapping, _ = queries.BindMapping(playerType, playerMapping, playerPrimaryKeyColumns)
	playerInsertCacheMut       sync.RWMutex
	playerInsertCache          = make(map[string]insertCache)
	playerUpdateCacheMut       sync.RWMutex
	playerUpdateCache          = make(map[string]updateCache)
	playerUpsertCacheMut       sync.RWMutex
	playerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var playerAfterSelectHooks []PlayerHook

var playerBeforeInsertHooks []PlayerHook
var playerAfterInsertHooks []PlayerHook

var playerBeforeUpdateHooks []PlayerHook
var playerAfterUpdateHooks []PlayerHook

var playerBeforeDeleteHooks []PlayerHook
var playerAfterDeleteHooks []PlayerHook

var playerBeforeUpsertHooks []PlayerHook
var playerAfterUpsertHooks []PlayerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Player) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Player) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Player) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Player) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Player) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Player) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Player) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Player) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Player) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range playerAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPlayerHook registers your hook function for all future operations.
func AddPlayerHook(hookPoint boil.HookPoint, playerHook PlayerHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		playerAfterSelectHooks = append(playerAfterSelectHooks, playerHook)
	case boil.BeforeInsertHook:
		playerBeforeInsertHooks = append(playerBeforeInsertHooks, playerHook)
	case boil.AfterInsertHook:
		playerAfterInsertHooks = append(playerAfterInsertHooks, playerHook)
	case boil.BeforeUpdateHook:
		playerBeforeUpdateHooks = append(playerBeforeUpdateHooks, playerHook)
	case boil.AfterUpdateHook:
		playerAfterUpdateHooks = append(playerAfterUpdateHooks, playerHook)
	case boil.BeforeDeleteHook:
		playerBeforeDeleteHooks = append(playerBeforeDeleteHooks, playerHook)
	case boil.AfterDeleteHook:
		playerAfterDeleteHooks = append(playerAfterDeleteHooks, playerHook)
	case boil.BeforeUpsertHook:
		playerBeforeUpsertHooks = append(playerBeforeUpsertHooks, playerHook)
	case boil.AfterUpsertHook:
		playerAfterUpsertHooks = append(playerAfterUpsertHooks, playerHook)
	}
}

// One returns a single player record from the query.
func (q playerQuery) One(exec boil.Executor) (*Player, error) {
	o := &Player{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for players")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Player records from the query.
func (q playerQuery) All(exec boil.Executor) (PlayerSlice, error) {
	var o []*Player

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to Player slice")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Player records in the query.
func (q playerQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count players rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q playerQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if players exists")
	}

	return count > 0, nil
}

// Faction pointed to by the foreign key.
func (o *Player) Faction(mods ...qm.QueryMod) factionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FactionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Factions(queryMods...)
	queries.SetFrom(query.Query, "\"factions\"")

	return query
}

// IDUserStat pointed to by the foreign key.
func (o *Player) IDUserStat(mods ...qm.QueryMod) userStatQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	query := UserStats(queryMods...)
	queries.SetFrom(query.Query, "\"user_stats\"")

	return query
}

// BattleAbilityTriggers retrieves all the battle_ability_trigger's BattleAbilityTriggers with an executor.
func (o *Player) BattleAbilityTriggers(mods ...qm.QueryMod) battleAbilityTriggerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_ability_triggers\".\"player_id\"=?", o.ID),
	)

	query := BattleAbilityTriggers(queryMods...)
	queries.SetFrom(query.Query, "\"battle_ability_triggers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_ability_triggers\".*"})
	}

	return query
}

// BattleContracts retrieves all the battle_contract's BattleContracts with an executor.
func (o *Player) BattleContracts(mods ...qm.QueryMod) battleContractQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contracts\".\"player_id\"=?", o.ID),
	)

	query := BattleContracts(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contracts\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contracts\".*"})
	}

	return query
}

// BattleContributions retrieves all the battle_contribution's BattleContributions with an executor.
func (o *Player) BattleContributions(mods ...qm.QueryMod) battleContributionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_contributions\".\"player_id\"=?", o.ID),
	)

	query := BattleContributions(queryMods...)
	queries.SetFrom(query.Query, "\"battle_contributions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_contributions\".*"})
	}

	return query
}

// OwnerBattleMechs retrieves all the battle_mech's BattleMechs with an executor via owner_id column.
func (o *Player) OwnerBattleMechs(mods ...qm.QueryMod) battleMechQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_mechs\".\"owner_id\"=?", o.ID),
	)

	query := BattleMechs(queryMods...)
	queries.SetFrom(query.Query, "\"battle_mechs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_mechs\".*"})
	}

	return query
}

// OwnerBattleQueues retrieves all the battle_queue's BattleQueues with an executor via owner_id column.
func (o *Player) OwnerBattleQueues(mods ...qm.QueryMod) battleQueueQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_queue\".\"owner_id\"=?", o.ID),
	)

	query := BattleQueues(queryMods...)
	queries.SetFrom(query.Query, "\"battle_queue\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_queue\".*"})
	}

	return query
}

// OwnerBattleWins retrieves all the battle_win's BattleWins with an executor via owner_id column.
func (o *Player) OwnerBattleWins(mods ...qm.QueryMod) battleWinQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"battle_wins\".\"owner_id\"=?", o.ID),
	)

	query := BattleWins(queryMods...)
	queries.SetFrom(query.Query, "\"battle_wins\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battle_wins\".*"})
	}

	return query
}

// Battles retrieves all the battle's Battles with an executor.
func (o *Player) Battles(mods ...qm.QueryMod) battleQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"battles_viewers\" on \"battles\".\"id\" = \"battles_viewers\".\"battle_id\""),
		qm.Where("\"battles_viewers\".\"player_id\"=?", o.ID),
	)

	query := Battles(queryMods...)
	queries.SetFrom(query.Query, "\"battles\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"battles\".*"})
	}

	return query
}

// ChatHistories retrieves all the chat_history's ChatHistories with an executor.
func (o *Player) ChatHistories(mods ...qm.QueryMod) chatHistoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"chat_history\".\"player_id\"=?", o.ID),
	)

	query := ChatHistories(queryMods...)
	queries.SetFrom(query.Query, "\"chat_history\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"chat_history\".*"})
	}

	return query
}

// MVPPlayerFactionStats retrieves all the faction_stat's FactionStats with an executor via mvp_player_id column.
func (o *Player) MVPPlayerFactionStats(mods ...qm.QueryMod) factionStatQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"faction_stats\".\"mvp_player_id\"=?", o.ID),
	)

	query := FactionStats(queryMods...)
	queries.SetFrom(query.Query, "\"faction_stats\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"faction_stats\".*"})
	}

	return query
}

// OwnerMechs retrieves all the mech's Mechs with an executor via owner_id column.
func (o *Player) OwnerMechs(mods ...qm.QueryMod) mechQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"mechs\".\"owner_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"mechs\".\"deleted_at\""),
	)

	query := Mechs(queryMods...)
	queries.SetFrom(query.Query, "\"mechs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"mechs\".*"})
	}

	return query
}

// ToUserPendingTransactions retrieves all the pending_transaction's PendingTransactions with an executor via to_user_id column.
func (o *Player) ToUserPendingTransactions(mods ...qm.QueryMod) pendingTransactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"pending_transactions\".\"to_user_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"pending_transactions\".\"deleted_at\""),
	)

	query := PendingTransactions(queryMods...)
	queries.SetFrom(query.Query, "\"pending_transactions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"pending_transactions\".*"})
	}

	return query
}

// PlayerActiveLogs retrieves all the player_active_log's PlayerActiveLogs with an executor.
func (o *Player) PlayerActiveLogs(mods ...qm.QueryMod) playerActiveLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_active_logs\".\"player_id\"=?", o.ID),
	)

	query := PlayerActiveLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_active_logs\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_active_logs\".*"})
	}

	return query
}

// PlayerKillLogs retrieves all the player_kill_log's PlayerKillLogs with an executor.
func (o *Player) PlayerKillLogs(mods ...qm.QueryMod) playerKillLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_kill_log\".\"player_id\"=?", o.ID),
	)

	query := PlayerKillLogs(queryMods...)
	queries.SetFrom(query.Query, "\"player_kill_log\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_kill_log\".*"})
	}

	return query
}

// PlayerLanguages retrieves all the player_language's PlayerLanguages with an executor.
func (o *Player) PlayerLanguages(mods ...qm.QueryMod) playerLanguageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_languages\".\"player_id\"=?", o.ID),
	)

	query := PlayerLanguages(queryMods...)
	queries.SetFrom(query.Query, "\"player_languages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_languages\".*"})
	}

	return query
}

// PlayerPreferences retrieves all the player_preference's PlayerPreferences with an executor.
func (o *Player) PlayerPreferences(mods ...qm.QueryMod) playerPreferenceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_preferences\".\"player_id\"=?", o.ID),
	)

	query := PlayerPreferences(queryMods...)
	queries.SetFrom(query.Query, "\"player_preferences\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_preferences\".*"})
	}

	return query
}

// PlayersPunishVotes retrieves all the players_punish_vote's PlayersPunishVotes with an executor.
func (o *Player) PlayersPunishVotes(mods ...qm.QueryMod) playersPunishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players_punish_votes\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"players_punish_votes\".\"deleted_at\""),
	)

	query := PlayersPunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"players_punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players_punish_votes\".*"})
	}

	return query
}

// IssuedByPunishVotes retrieves all the punish_vote's PunishVotes with an executor via issued_by_id column.
func (o *Player) IssuedByPunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"issued_by_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// ReportedPlayerPunishVotes retrieves all the punish_vote's PunishVotes with an executor via reported_player_id column.
func (o *Player) ReportedPlayerPunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_votes\".\"reported_player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""),
	)

	query := PunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_votes\".*"})
	}

	return query
}

// PunishedPlayers retrieves all the punished_player's PunishedPlayers with an executor.
func (o *Player) PunishedPlayers(mods ...qm.QueryMod) punishedPlayerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punished_players\".\"player_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punished_players\".\"deleted_at\""),
	)

	query := PunishedPlayers(queryMods...)
	queries.SetFrom(query.Query, "\"punished_players\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punished_players\".*"})
	}

	return query
}

// TelegramPlayers retrieves all the telegram_player's TelegramPlayers with an executor.
func (o *Player) TelegramPlayers(mods ...qm.QueryMod) telegramPlayerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"telegram_players\".\"player_id\"=?", o.ID),
	)

	query := TelegramPlayers(queryMods...)
	queries.SetFrom(query.Query, "\"telegram_players\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"telegram_players\".*"})
	}

	return query
}

// UserMultipliers retrieves all the user_multiplier's UserMultipliers with an executor.
func (o *Player) UserMultipliers(mods ...qm.QueryMod) userMultiplierQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_multipliers\".\"player_id\"=?", o.ID),
	)

	query := UserMultipliers(queryMods...)
	queries.SetFrom(query.Query, "\"user_multipliers\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_multipliers\".*"})
	}

	return query
}

// Users retrieves all the user's Users with an executor.
func (o *Player) Users(mods ...qm.QueryMod) userQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"users\".\"player_id\"=?", o.ID),
	)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"users\".*"})
	}

	return query
}

// LoadFaction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadFaction(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		if !queries.IsNil(object.FactionID) {
			args = append(args, object.FactionID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FactionID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.FactionID) {
				args = append(args, obj.FactionID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`factions`),
		qm.WhereIn(`factions.id in ?`, args...),
		qmhelper.WhereIsNull(`factions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Faction")
	}

	var resultSlice []*Faction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Faction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factions")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Faction = foreign
		if foreign.R == nil {
			foreign.R = &factionR{}
		}
		foreign.R.Players = append(foreign.R.Players, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.FactionID, foreign.ID) {
				local.R.Faction = foreign
				if foreign.R == nil {
					foreign.R = &factionR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadIDUserStat allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (playerL) LoadIDUserStat(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_stats`),
		qm.WhereIn(`user_stats.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UserStat")
	}

	var resultSlice []*UserStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UserStat")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for user_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_stats")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IDUserStat = foreign
		if foreign.R == nil {
			foreign.R = &userStatR{}
		}
		foreign.R.IDPlayer = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.ID {
				local.R.IDUserStat = foreign
				if foreign.R == nil {
					foreign.R = &userStatR{}
				}
				foreign.R.IDPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadBattleAbilityTriggers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleAbilityTriggers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_ability_triggers`),
		qm.WhereIn(`battle_ability_triggers.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_ability_triggers")
	}

	var resultSlice []*BattleAbilityTrigger
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_ability_triggers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_ability_triggers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_ability_triggers")
	}

	if len(battleAbilityTriggerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleAbilityTriggers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleAbilityTriggerR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PlayerID) {
				local.R.BattleAbilityTriggers = append(local.R.BattleAbilityTriggers, foreign)
				if foreign.R == nil {
					foreign.R = &battleAbilityTriggerR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContracts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleContracts(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contracts`),
		qm.WhereIn(`battle_contracts.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contracts")
	}

	var resultSlice []*BattleContract
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contracts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contracts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contracts")
	}

	if len(battleContractAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContracts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContractR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.BattleContracts = append(local.R.BattleContracts, foreign)
				if foreign.R == nil {
					foreign.R = &battleContractR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadBattleContributions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattleContributions(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_contributions`),
		qm.WhereIn(`battle_contributions.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_contributions")
	}

	var resultSlice []*BattleContribution
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_contributions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_contributions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_contributions")
	}

	if len(battleContributionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BattleContributions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleContributionR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.BattleContributions = append(local.R.BattleContributions, foreign)
				if foreign.R == nil {
					foreign.R = &battleContributionR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleMechs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleMechs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_mechs`),
		qm.WhereIn(`battle_mechs.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_mechs")
	}

	var resultSlice []*BattleMech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_mechs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_mechs")
	}

	if len(battleMechAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleMechs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleMechR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleMechs = append(local.R.OwnerBattleMechs, foreign)
				if foreign.R == nil {
					foreign.R = &battleMechR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleQueues allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleQueues(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_queue`),
		qm.WhereIn(`battle_queue.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_queue")
	}

	var resultSlice []*BattleQueue
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_queue")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_queue")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_queue")
	}

	if len(battleQueueAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleQueues = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleQueueR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleQueues = append(local.R.OwnerBattleQueues, foreign)
				if foreign.R == nil {
					foreign.R = &battleQueueR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerBattleWins allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerBattleWins(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`battle_wins`),
		qm.WhereIn(`battle_wins.owner_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battle_wins")
	}

	var resultSlice []*BattleWin
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice battle_wins")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battle_wins")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battle_wins")
	}

	if len(battleWinAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerBattleWins = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleWinR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerBattleWins = append(local.R.OwnerBattleWins, foreign)
				if foreign.R == nil {
					foreign.R = &battleWinR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadBattles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadBattles(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"battles\".id, \"battles\".game_map_id, \"battles\".started_at, \"battles\".ended_at, \"battles\".battle_number, \"battles\".started_battle_seconds, \"battles\".ended_battle_seconds, \"a\".\"player_id\""),
		qm.From("\"battles\""),
		qm.InnerJoin("\"battles_viewers\" as \"a\" on \"battles\".\"id\" = \"a\".\"battle_id\""),
		qm.WhereIn("\"a\".\"player_id\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load battles")
	}

	var resultSlice []*Battle

	var localJoinCols []string
	for results.Next() {
		one := new(Battle)
		var localJoinCol string

		err = results.Scan(&one.ID, &one.GameMapID, &one.StartedAt, &one.EndedAt, &one.BattleNumber, &one.StartedBattleSeconds, &one.EndedBattleSeconds, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for battles")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice battles")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on battles")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for battles")
	}

	if len(battleAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Battles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &battleR{}
			}
			foreign.R.Players = append(foreign.R.Players, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.Battles = append(local.R.Battles, foreign)
				if foreign.R == nil {
					foreign.R = &battleR{}
				}
				foreign.R.Players = append(foreign.R.Players, local)
				break
			}
		}
	}

	return nil
}

// LoadChatHistories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadChatHistories(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`chat_history`),
		qm.WhereIn(`chat_history.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load chat_history")
	}

	var resultSlice []*ChatHistory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice chat_history")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on chat_history")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chat_history")
	}

	if len(chatHistoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ChatHistories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &chatHistoryR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.ChatHistories = append(local.R.ChatHistories, foreign)
				if foreign.R == nil {
					foreign.R = &chatHistoryR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadMVPPlayerFactionStats allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadMVPPlayerFactionStats(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`faction_stats`),
		qm.WhereIn(`faction_stats.mvp_player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load faction_stats")
	}

	var resultSlice []*FactionStat
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice faction_stats")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on faction_stats")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for faction_stats")
	}

	if len(factionStatAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MVPPlayerFactionStats = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &factionStatR{}
			}
			foreign.R.MVPPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MVPPlayerID) {
				local.R.MVPPlayerFactionStats = append(local.R.MVPPlayerFactionStats, foreign)
				if foreign.R == nil {
					foreign.R = &factionStatR{}
				}
				foreign.R.MVPPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadOwnerMechs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadOwnerMechs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`mechs`),
		qm.WhereIn(`mechs.owner_id in ?`, args...),
		qmhelper.WhereIsNull(`mechs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mechs")
	}

	var resultSlice []*Mech
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mechs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mechs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mechs")
	}

	if len(mechAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.OwnerMechs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mechR{}
			}
			foreign.R.Owner = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.OwnerID {
				local.R.OwnerMechs = append(local.R.OwnerMechs, foreign)
				if foreign.R == nil {
					foreign.R = &mechR{}
				}
				foreign.R.Owner = local
				break
			}
		}
	}

	return nil
}

// LoadToUserPendingTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadToUserPendingTransactions(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`pending_transactions`),
		qm.WhereIn(`pending_transactions.to_user_id in ?`, args...),
		qmhelper.WhereIsNull(`pending_transactions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load pending_transactions")
	}

	var resultSlice []*PendingTransaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice pending_transactions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on pending_transactions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for pending_transactions")
	}

	if len(pendingTransactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ToUserPendingTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pendingTransactionR{}
			}
			foreign.R.ToUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ToUserID {
				local.R.ToUserPendingTransactions = append(local.R.ToUserPendingTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &pendingTransactionR{}
				}
				foreign.R.ToUser = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerActiveLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerActiveLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_active_logs`),
		qm.WhereIn(`player_active_logs.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_active_logs")
	}

	var resultSlice []*PlayerActiveLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_active_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_active_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_active_logs")
	}

	if len(playerActiveLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerActiveLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerActiveLogR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerActiveLogs = append(local.R.PlayerActiveLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerActiveLogR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerKillLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerKillLogs(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_kill_log`),
		qm.WhereIn(`player_kill_log.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_kill_log")
	}

	var resultSlice []*PlayerKillLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_kill_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_kill_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_kill_log")
	}

	if len(playerKillLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerKillLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerKillLogR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerKillLogs = append(local.R.PlayerKillLogs, foreign)
				if foreign.R == nil {
					foreign.R = &playerKillLogR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerLanguages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerLanguages(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_languages`),
		qm.WhereIn(`player_languages.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_languages")
	}

	var resultSlice []*PlayerLanguage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_languages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_languages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_languages")
	}

	if len(playerLanguageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerLanguages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerLanguageR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerLanguages = append(local.R.PlayerLanguages, foreign)
				if foreign.R == nil {
					foreign.R = &playerLanguageR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerPreferences allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerPreferences(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_preferences`),
		qm.WhereIn(`player_preferences.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_preferences")
	}

	var resultSlice []*PlayerPreference
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_preferences")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_preferences")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_preferences")
	}

	if len(playerPreferenceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerPreferences = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerPreferenceR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerPreferences = append(local.R.PlayerPreferences, foreign)
				if foreign.R == nil {
					foreign.R = &playerPreferenceR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayersPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayersPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players_punish_votes`),
		qm.WhereIn(`players_punish_votes.player_id in ?`, args...),
		qmhelper.WhereIsNull(`players_punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players_punish_votes")
	}

	var resultSlice []*PlayersPunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players_punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players_punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players_punish_votes")
	}

	if len(playersPunishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayersPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playersPunishVoteR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayersPunishVotes = append(local.R.PlayersPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &playersPunishVoteR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadIssuedByPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadIssuedByPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.issued_by_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.IssuedByPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.IssuedBy = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.IssuedByID {
				local.R.IssuedByPunishVotes = append(local.R.IssuedByPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.IssuedBy = local
				break
			}
		}
	}

	return nil
}

// LoadReportedPlayerPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadReportedPlayerPunishVotes(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_votes`),
		qm.WhereIn(`punish_votes.reported_player_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_votes")
	}

	var resultSlice []*PunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_votes")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReportedPlayerPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteR{}
			}
			foreign.R.ReportedPlayer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReportedPlayerID {
				local.R.ReportedPlayerPunishVotes = append(local.R.ReportedPlayerPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteR{}
				}
				foreign.R.ReportedPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadPunishedPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPunishedPlayers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punished_players`),
		qm.WhereIn(`punished_players.player_id in ?`, args...),
		qmhelper.WhereIsNull(`punished_players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punished_players")
	}

	var resultSlice []*PunishedPlayer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punished_players")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punished_players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punished_players")
	}

	if len(punishedPlayerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PunishedPlayers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishedPlayerR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PunishedPlayers = append(local.R.PunishedPlayers, foreign)
				if foreign.R == nil {
					foreign.R = &punishedPlayerR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadTelegramPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadTelegramPlayers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`telegram_players`),
		qm.WhereIn(`telegram_players.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load telegram_players")
	}

	var resultSlice []*TelegramPlayer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice telegram_players")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on telegram_players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for telegram_players")
	}

	if len(telegramPlayerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.TelegramPlayers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &telegramPlayerR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.TelegramPlayers = append(local.R.TelegramPlayers, foreign)
				if foreign.R == nil {
					foreign.R = &telegramPlayerR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadUserMultipliers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadUserMultipliers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_multipliers`),
		qm.WhereIn(`user_multipliers.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_multipliers")
	}

	var resultSlice []*UserMultiplier
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_multipliers")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_multipliers")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_multipliers")
	}

	if len(userMultiplierAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserMultipliers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userMultiplierR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.UserMultipliers = append(local.R.UserMultipliers, foreign)
				if foreign.R == nil {
					foreign.R = &userMultiplierR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadUsers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadUsers(e boil.Executor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		object = maybePlayer.(*Player)
	} else {
		slice = *maybePlayer.(*[]*Player)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.player_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load users")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice users")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Users = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PlayerID) {
				local.R.Users = append(local.R.Users, foreign)
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// SetFaction of the player to the related item.
// Sets o.R.Faction to related.
// Adds o to related.R.Players.
func (o *Player) SetFaction(exec boil.Executor, insert bool, related *Faction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.FactionID, related.ID)
	if o.R == nil {
		o.R = &playerR{
			Faction: related,
		}
	} else {
		o.R.Faction = related
	}

	if related.R == nil {
		related.R = &factionR{
			Players: PlayerSlice{o},
		}
	} else {
		related.R.Players = append(related.R.Players, o)
	}

	return nil
}

// RemoveFaction relationship.
// Sets o.R.Faction to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Player) RemoveFaction(exec boil.Executor, related *Faction) error {
	var err error

	queries.SetScanner(&o.FactionID, nil)
	if _, err = o.Update(exec, boil.Whitelist("faction_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Faction = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Players {
		if queries.Equal(o.FactionID, ri.FactionID) {
			continue
		}

		ln := len(related.R.Players)
		if ln > 1 && i < ln-1 {
			related.R.Players[i] = related.R.Players[ln-1]
		}
		related.R.Players = related.R.Players[:ln-1]
		break
	}
	return nil
}

// SetIDUserStat of the player to the related item.
// Sets o.R.IDUserStat to related.
// Adds o to related.R.IDPlayer.
func (o *Player) SetIDUserStat(exec boil.Executor, insert bool, related *UserStat) error {
	var err error

	if insert {
		related.ID = o.ID

		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"user_stats\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"id"}),
			strmangle.WhereClause("\"", "\"", 2, userStatPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, updateQuery)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		if _, err = exec.Exec(updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.ID = o.ID

	}

	if o.R == nil {
		o.R = &playerR{
			IDUserStat: related,
		}
	} else {
		o.R.IDUserStat = related
	}

	if related.R == nil {
		related.R = &userStatR{
			IDPlayer: o,
		}
	} else {
		related.R.IDPlayer = o
	}
	return nil
}

// AddBattleAbilityTriggers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleAbilityTriggers.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_ability_triggers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleAbilityTriggerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleAbilityTriggers: related,
		}
	} else {
		o.R.BattleAbilityTriggers = append(o.R.BattleAbilityTriggers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleAbilityTriggerR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// SetBattleAbilityTriggers removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Player's BattleAbilityTriggers accordingly.
// Replaces o.R.BattleAbilityTriggers with related.
// Sets related.R.Player's BattleAbilityTriggers accordingly.
func (o *Player) SetBattleAbilityTriggers(exec boil.Executor, insert bool, related ...*BattleAbilityTrigger) error {
	query := "update \"battle_ability_triggers\" set \"player_id\" = null where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.BattleAbilityTriggers {
			queries.SetScanner(&rel.PlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Player = nil
		}

		o.R.BattleAbilityTriggers = nil
	}
	return o.AddBattleAbilityTriggers(exec, insert, related...)
}

// RemoveBattleAbilityTriggers relationships from objects passed in.
// Removes related items from R.BattleAbilityTriggers (uses pointer comparison, removal does not keep order)
// Sets related.R.Player.
func (o *Player) RemoveBattleAbilityTriggers(exec boil.Executor, related ...*BattleAbilityTrigger) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PlayerID, nil)
		if rel.R != nil {
			rel.R.Player = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.BattleAbilityTriggers {
			if rel != ri {
				continue
			}

			ln := len(o.R.BattleAbilityTriggers)
			if ln > 1 && i < ln-1 {
				o.R.BattleAbilityTriggers[i] = o.R.BattleAbilityTriggers[ln-1]
			}
			o.R.BattleAbilityTriggers = o.R.BattleAbilityTriggers[:ln-1]
			break
		}
	}

	return nil
}

// AddBattleContracts adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleContracts.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleContracts(exec boil.Executor, insert bool, related ...*BattleContract) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contracts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContractPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleContracts: related,
		}
	} else {
		o.R.BattleContracts = append(o.R.BattleContracts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContractR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddBattleContributions adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.BattleContributions.
// Sets related.R.Player appropriately.
func (o *Player) AddBattleContributions(exec boil.Executor, insert bool, related ...*BattleContribution) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_contributions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleContributionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			BattleContributions: related,
		}
	} else {
		o.R.BattleContributions = append(o.R.BattleContributions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleContributionR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddOwnerBattleMechs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleMechs.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleMechs(exec boil.Executor, insert bool, related ...*BattleMech) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_mechs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleMechPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleMechs: related,
		}
	} else {
		o.R.OwnerBattleMechs = append(o.R.OwnerBattleMechs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleMechR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddOwnerBattleQueues adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleQueues.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleQueues(exec boil.Executor, insert bool, related ...*BattleQueue) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_queue\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleQueuePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleQueues: related,
		}
	} else {
		o.R.OwnerBattleQueues = append(o.R.OwnerBattleQueues, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleQueueR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddOwnerBattleWins adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerBattleWins.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerBattleWins(exec boil.Executor, insert bool, related ...*BattleWin) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"battle_wins\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, battleWinPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.BattleID, rel.MechID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerBattleWins: related,
		}
	} else {
		o.R.OwnerBattleWins = append(o.R.OwnerBattleWins, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleWinR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddBattles adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Battles.
// Sets related.R.Players appropriately.
func (o *Player) AddBattles(exec boil.Executor, insert bool, related ...*Battle) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"battles_viewers\" (\"player_id\", \"battle_id\") values ($1, $2)"
		values := []interface{}{o.ID, rel.ID}

		if boil.DebugMode {
			fmt.Fprintln(boil.DebugWriter, query)
			fmt.Fprintln(boil.DebugWriter, values)
		}
		_, err = exec.Exec(query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &playerR{
			Battles: related,
		}
	} else {
		o.R.Battles = append(o.R.Battles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &battleR{
				Players: PlayerSlice{o},
			}
		} else {
			rel.R.Players = append(rel.R.Players, o)
		}
	}
	return nil
}

// SetBattles removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Players's Battles accordingly.
// Replaces o.R.Battles with related.
// Sets related.R.Players's Battles accordingly.
func (o *Player) SetBattles(exec boil.Executor, insert bool, related ...*Battle) error {
	query := "delete from \"battles_viewers\" where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeBattlesFromPlayersSlice(o, related)
	if o.R != nil {
		o.R.Battles = nil
	}
	return o.AddBattles(exec, insert, related...)
}

// RemoveBattles relationships from objects passed in.
// Removes related items from R.Battles (uses pointer comparison, removal does not keep order)
// Sets related.R.Players.
func (o *Player) RemoveBattles(exec boil.Executor, related ...*Battle) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"battles_viewers\" where \"player_id\" = $1 and \"battle_id\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeBattlesFromPlayersSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Battles {
			if rel != ri {
				continue
			}

			ln := len(o.R.Battles)
			if ln > 1 && i < ln-1 {
				o.R.Battles[i] = o.R.Battles[ln-1]
			}
			o.R.Battles = o.R.Battles[:ln-1]
			break
		}
	}

	return nil
}

func removeBattlesFromPlayersSlice(o *Player, related []*Battle) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Players {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Players)
			if ln > 1 && i < ln-1 {
				rel.R.Players[i] = rel.R.Players[ln-1]
			}
			rel.R.Players = rel.R.Players[:ln-1]
			break
		}
	}
}

// AddChatHistories adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ChatHistories.
// Sets related.R.Player appropriately.
func (o *Player) AddChatHistories(exec boil.Executor, insert bool, related ...*ChatHistory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"chat_history\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, chatHistoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ChatHistories: related,
		}
	} else {
		o.R.ChatHistories = append(o.R.ChatHistories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &chatHistoryR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddMVPPlayerFactionStats adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.MVPPlayerFactionStats.
// Sets related.R.MVPPlayer appropriately.
func (o *Player) AddMVPPlayerFactionStats(exec boil.Executor, insert bool, related ...*FactionStat) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MVPPlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"faction_stats\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"mvp_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, factionStatPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MVPPlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			MVPPlayerFactionStats: related,
		}
	} else {
		o.R.MVPPlayerFactionStats = append(o.R.MVPPlayerFactionStats, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &factionStatR{
				MVPPlayer: o,
			}
		} else {
			rel.R.MVPPlayer = o
		}
	}
	return nil
}

// SetMVPPlayerFactionStats removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MVPPlayer's MVPPlayerFactionStats accordingly.
// Replaces o.R.MVPPlayerFactionStats with related.
// Sets related.R.MVPPlayer's MVPPlayerFactionStats accordingly.
func (o *Player) SetMVPPlayerFactionStats(exec boil.Executor, insert bool, related ...*FactionStat) error {
	query := "update \"faction_stats\" set \"mvp_player_id\" = null where \"mvp_player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MVPPlayerFactionStats {
			queries.SetScanner(&rel.MVPPlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MVPPlayer = nil
		}

		o.R.MVPPlayerFactionStats = nil
	}
	return o.AddMVPPlayerFactionStats(exec, insert, related...)
}

// RemoveMVPPlayerFactionStats relationships from objects passed in.
// Removes related items from R.MVPPlayerFactionStats (uses pointer comparison, removal does not keep order)
// Sets related.R.MVPPlayer.
func (o *Player) RemoveMVPPlayerFactionStats(exec boil.Executor, related ...*FactionStat) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MVPPlayerID, nil)
		if rel.R != nil {
			rel.R.MVPPlayer = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("mvp_player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MVPPlayerFactionStats {
			if rel != ri {
				continue
			}

			ln := len(o.R.MVPPlayerFactionStats)
			if ln > 1 && i < ln-1 {
				o.R.MVPPlayerFactionStats[i] = o.R.MVPPlayerFactionStats[ln-1]
			}
			o.R.MVPPlayerFactionStats = o.R.MVPPlayerFactionStats[:ln-1]
			break
		}
	}

	return nil
}

// AddOwnerMechs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.OwnerMechs.
// Sets related.R.Owner appropriately.
func (o *Player) AddOwnerMechs(exec boil.Executor, insert bool, related ...*Mech) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OwnerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"mechs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
				strmangle.WhereClause("\"", "\"", 2, mechPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OwnerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			OwnerMechs: related,
		}
	} else {
		o.R.OwnerMechs = append(o.R.OwnerMechs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mechR{
				Owner: o,
			}
		} else {
			rel.R.Owner = o
		}
	}
	return nil
}

// AddToUserPendingTransactions adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ToUserPendingTransactions.
// Sets related.R.ToUser appropriately.
func (o *Player) AddToUserPendingTransactions(exec boil.Executor, insert bool, related ...*PendingTransaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ToUserID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"pending_transactions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"to_user_id"}),
				strmangle.WhereClause("\"", "\"", 2, pendingTransactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ToUserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ToUserPendingTransactions: related,
		}
	} else {
		o.R.ToUserPendingTransactions = append(o.R.ToUserPendingTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pendingTransactionR{
				ToUser: o,
			}
		} else {
			rel.R.ToUser = o
		}
	}
	return nil
}

// AddPlayerActiveLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerActiveLogs.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerActiveLogs(exec boil.Executor, insert bool, related ...*PlayerActiveLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_active_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerActiveLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerActiveLogs: related,
		}
	} else {
		o.R.PlayerActiveLogs = append(o.R.PlayerActiveLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerActiveLogR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerKillLogs adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerKillLogs.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerKillLogs(exec boil.Executor, insert bool, related ...*PlayerKillLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_kill_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerKillLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerKillLogs: related,
		}
	} else {
		o.R.PlayerKillLogs = append(o.R.PlayerKillLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerKillLogR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerLanguages adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerLanguages.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerLanguages(exec boil.Executor, insert bool, related ...*PlayerLanguage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_languages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerLanguagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerLanguages: related,
		}
	} else {
		o.R.PlayerLanguages = append(o.R.PlayerLanguages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerLanguageR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerPreferences adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerPreferences.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerPreferences(exec boil.Executor, insert bool, related ...*PlayerPreference) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_preferences\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerPreferencePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.Key}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerPreferences: related,
		}
	} else {
		o.R.PlayerPreferences = append(o.R.PlayerPreferences, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerPreferenceR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayersPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayersPunishVotes.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayersPunishVotes(exec boil.Executor, insert bool, related ...*PlayersPunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players_punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playersPunishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayersPunishVotes: related,
		}
	} else {
		o.R.PlayersPunishVotes = append(o.R.PlayersPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playersPunishVoteR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddIssuedByPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.IssuedByPunishVotes.
// Sets related.R.IssuedBy appropriately.
func (o *Player) AddIssuedByPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.IssuedByID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"issued_by_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.IssuedByID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			IssuedByPunishVotes: related,
		}
	} else {
		o.R.IssuedByPunishVotes = append(o.R.IssuedByPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				IssuedBy: o,
			}
		} else {
			rel.R.IssuedBy = o
		}
	}
	return nil
}

// AddReportedPlayerPunishVotes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.ReportedPlayerPunishVotes.
// Sets related.R.ReportedPlayer appropriately.
func (o *Player) AddReportedPlayerPunishVotes(exec boil.Executor, insert bool, related ...*PunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReportedPlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"reported_player_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReportedPlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			ReportedPlayerPunishVotes: related,
		}
	} else {
		o.R.ReportedPlayerPunishVotes = append(o.R.ReportedPlayerPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteR{
				ReportedPlayer: o,
			}
		} else {
			rel.R.ReportedPlayer = o
		}
	}
	return nil
}

// AddPunishedPlayers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PunishedPlayers.
// Sets related.R.Player appropriately.
func (o *Player) AddPunishedPlayers(exec boil.Executor, insert bool, related ...*PunishedPlayer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punished_players\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishedPlayerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PunishedPlayers: related,
		}
	} else {
		o.R.PunishedPlayers = append(o.R.PunishedPlayers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishedPlayerR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddTelegramPlayers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.TelegramPlayers.
// Sets related.R.Player appropriately.
func (o *Player) AddTelegramPlayers(exec boil.Executor, insert bool, related ...*TelegramPlayer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"telegram_players\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, telegramPlayerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			TelegramPlayers: related,
		}
	} else {
		o.R.TelegramPlayers = append(o.R.TelegramPlayers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &telegramPlayerR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddUserMultipliers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.UserMultipliers.
// Sets related.R.Player appropriately.
func (o *Player) AddUserMultipliers(exec boil.Executor, insert bool, related ...*UserMultiplier) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_multipliers\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, userMultiplierPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.FromBattleNumber, rel.MultiplierID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			UserMultipliers: related,
		}
	} else {
		o.R.UserMultipliers = append(o.R.UserMultipliers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userMultiplierR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddUsers adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Users.
// Sets related.R.Player appropriately.
func (o *Player) AddUsers(exec boil.Executor, insert bool, related ...*User) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PlayerID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"users\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			Users: related,
		}
	} else {
		o.R.Users = append(o.R.Users, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// SetUsers removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Player's Users accordingly.
// Replaces o.R.Users with related.
// Sets related.R.Player's Users accordingly.
func (o *Player) SetUsers(exec boil.Executor, insert bool, related ...*User) error {
	query := "update \"users\" set \"player_id\" = null where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Users {
			queries.SetScanner(&rel.PlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Player = nil
		}

		o.R.Users = nil
	}
	return o.AddUsers(exec, insert, related...)
}

// RemoveUsers relationships from objects passed in.
// Removes related items from R.Users (uses pointer comparison, removal does not keep order)
// Sets related.R.Player.
func (o *Player) RemoveUsers(exec boil.Executor, related ...*User) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PlayerID, nil)
		if rel.R != nil {
			rel.R.Player = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Users {
			if rel != ri {
				continue
			}

			ln := len(o.R.Users)
			if ln > 1 && i < ln-1 {
				o.R.Users[i] = o.R.Users[ln-1]
			}
			o.R.Users = o.R.Users[:ln-1]
			break
		}
	}

	return nil
}

// Players retrieves all the records using an executor.
func Players(mods ...qm.QueryMod) playerQuery {
	mods = append(mods, qm.From("\"players\""), qmhelper.WhereIsNull("\"players\".\"deleted_at\""))
	return playerQuery{NewQuery(mods...)}
}

// FindPlayer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPlayer(exec boil.Executor, iD string, selectCols ...string) (*Player, error) {
	playerObj := &Player{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"players\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, playerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from players")
	}

	if err = playerObj.doAfterSelectHooks(exec); err != nil {
		return playerObj, err
	}

	return playerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Player) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no players provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	playerInsertCacheMut.RLock()
	cache, cached := playerInsertCache[key]
	playerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(playerType, playerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"players\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"players\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into players")
	}

	if !cached {
		playerInsertCacheMut.Lock()
		playerInsertCache[key] = cache
		playerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the Player.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Player) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	playerUpdateCacheMut.RLock()
	cache, cached := playerUpdateCache[key]
	playerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update players, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, playerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update players row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for players")
	}

	if !cached {
		playerUpdateCacheMut.Lock()
		playerUpdateCache[key] = cache
		playerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q playerQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for players")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PlayerSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, playerPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all player")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Player) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no players provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	playerUpsertCacheMut.RLock()
	cache, cached := playerUpsertCache[key]
	playerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert players, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(playerPrimaryKeyColumns))
			copy(conflict, playerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"players\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(playerType, playerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert players")
	}

	if !cached {
		playerUpsertCacheMut.Lock()
		playerUpsertCache[key] = cache
		playerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single Player record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Player) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no Player provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), playerPrimaryKeyMapping)
		sql = "DELETE FROM \"players\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for players")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q playerQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no playerQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for players")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PlayerSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(playerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"players\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, playerPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for players")
	}

	if len(playerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Player) Reload(exec boil.Executor) error {
	ret, err := FindPlayer(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PlayerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"players\".* FROM \"players\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in PlayerSlice")
	}

	*o = slice

	return nil
}

// PlayerExists checks if the Player row exists.
func PlayerExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"players\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if players exists")
	}

	return exists, nil
}
