// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/shopspring/decimal"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// PunishVote is an object representing the database table.
type PunishVote struct {
	ID                     string          `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	PunishOptionID         string          `boiler:"punish_option_id" boil:"punish_option_id" json:"punish_option_id" toml:"punish_option_id" yaml:"punish_option_id"`
	Reason                 string          `boiler:"reason" boil:"reason" json:"reason" toml:"reason" yaml:"reason"`
	FactionID              string          `boiler:"faction_id" boil:"faction_id" json:"faction_id" toml:"faction_id" yaml:"faction_id"`
	IssuedByID             string          `boiler:"issued_by_id" boil:"issued_by_id" json:"issued_by_id" toml:"issued_by_id" yaml:"issued_by_id"`
	IssuedByUsername       string          `boiler:"issued_by_username" boil:"issued_by_username" json:"issued_by_username" toml:"issued_by_username" yaml:"issued_by_username"`
	IssuedByGid            int             `boiler:"issued_by_gid" boil:"issued_by_gid" json:"issued_by_gid" toml:"issued_by_gid" yaml:"issued_by_gid"`
	ReportedPlayerID       string          `boiler:"reported_player_id" boil:"reported_player_id" json:"reported_player_id" toml:"reported_player_id" yaml:"reported_player_id"`
	ReportedPlayerUsername string          `boiler:"reported_player_username" boil:"reported_player_username" json:"reported_player_username" toml:"reported_player_username" yaml:"reported_player_username"`
	ReportedPlayerGid      int             `boiler:"reported_player_gid" boil:"reported_player_gid" json:"reported_player_gid" toml:"reported_player_gid" yaml:"reported_player_gid"`
	Status                 string          `boiler:"status" boil:"status" json:"status" toml:"status" yaml:"status"`
	StartedAt              null.Time       `boiler:"started_at" boil:"started_at" json:"started_at,omitempty" toml:"started_at" yaml:"started_at,omitempty"`
	EndedAt                null.Time       `boiler:"ended_at" boil:"ended_at" json:"ended_at,omitempty" toml:"ended_at" yaml:"ended_at,omitempty"`
	CreatedAt              time.Time       `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt              time.Time       `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt              null.Time       `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	InstantPassByID        null.String     `boiler:"instant_pass_by_id" boil:"instant_pass_by_id" json:"instant_pass_by_id,omitempty" toml:"instant_pass_by_id" yaml:"instant_pass_by_id,omitempty"`
	InstantPassFee         decimal.Decimal `boiler:"instant_pass_fee" boil:"instant_pass_fee" json:"instant_pass_fee" toml:"instant_pass_fee" yaml:"instant_pass_fee"`
	InstantPassTXID        null.String     `boiler:"instant_pass_tx_id" boil:"instant_pass_tx_id" json:"instant_pass_tx_id,omitempty" toml:"instant_pass_tx_id" yaml:"instant_pass_tx_id,omitempty"`

	R *punishVoteR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L punishVoteL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PunishVoteColumns = struct {
	ID                     string
	PunishOptionID         string
	Reason                 string
	FactionID              string
	IssuedByID             string
	IssuedByUsername       string
	IssuedByGid            string
	ReportedPlayerID       string
	ReportedPlayerUsername string
	ReportedPlayerGid      string
	Status                 string
	StartedAt              string
	EndedAt                string
	CreatedAt              string
	UpdatedAt              string
	DeletedAt              string
	InstantPassByID        string
	InstantPassFee         string
	InstantPassTXID        string
}{
	ID:                     "id",
	PunishOptionID:         "punish_option_id",
	Reason:                 "reason",
	FactionID:              "faction_id",
	IssuedByID:             "issued_by_id",
	IssuedByUsername:       "issued_by_username",
	IssuedByGid:            "issued_by_gid",
	ReportedPlayerID:       "reported_player_id",
	ReportedPlayerUsername: "reported_player_username",
	ReportedPlayerGid:      "reported_player_gid",
	Status:                 "status",
	StartedAt:              "started_at",
	EndedAt:                "ended_at",
	CreatedAt:              "created_at",
	UpdatedAt:              "updated_at",
	DeletedAt:              "deleted_at",
	InstantPassByID:        "instant_pass_by_id",
	InstantPassFee:         "instant_pass_fee",
	InstantPassTXID:        "instant_pass_tx_id",
}

var PunishVoteTableColumns = struct {
	ID                     string
	PunishOptionID         string
	Reason                 string
	FactionID              string
	IssuedByID             string
	IssuedByUsername       string
	IssuedByGid            string
	ReportedPlayerID       string
	ReportedPlayerUsername string
	ReportedPlayerGid      string
	Status                 string
	StartedAt              string
	EndedAt                string
	CreatedAt              string
	UpdatedAt              string
	DeletedAt              string
	InstantPassByID        string
	InstantPassFee         string
	InstantPassTXID        string
}{
	ID:                     "punish_votes.id",
	PunishOptionID:         "punish_votes.punish_option_id",
	Reason:                 "punish_votes.reason",
	FactionID:              "punish_votes.faction_id",
	IssuedByID:             "punish_votes.issued_by_id",
	IssuedByUsername:       "punish_votes.issued_by_username",
	IssuedByGid:            "punish_votes.issued_by_gid",
	ReportedPlayerID:       "punish_votes.reported_player_id",
	ReportedPlayerUsername: "punish_votes.reported_player_username",
	ReportedPlayerGid:      "punish_votes.reported_player_gid",
	Status:                 "punish_votes.status",
	StartedAt:              "punish_votes.started_at",
	EndedAt:                "punish_votes.ended_at",
	CreatedAt:              "punish_votes.created_at",
	UpdatedAt:              "punish_votes.updated_at",
	DeletedAt:              "punish_votes.deleted_at",
	InstantPassByID:        "punish_votes.instant_pass_by_id",
	InstantPassFee:         "punish_votes.instant_pass_fee",
	InstantPassTXID:        "punish_votes.instant_pass_tx_id",
}

// Generated where

var PunishVoteWhere = struct {
	ID                     whereHelperstring
	PunishOptionID         whereHelperstring
	Reason                 whereHelperstring
	FactionID              whereHelperstring
	IssuedByID             whereHelperstring
	IssuedByUsername       whereHelperstring
	IssuedByGid            whereHelperint
	ReportedPlayerID       whereHelperstring
	ReportedPlayerUsername whereHelperstring
	ReportedPlayerGid      whereHelperint
	Status                 whereHelperstring
	StartedAt              whereHelpernull_Time
	EndedAt                whereHelpernull_Time
	CreatedAt              whereHelpertime_Time
	UpdatedAt              whereHelpertime_Time
	DeletedAt              whereHelpernull_Time
	InstantPassByID        whereHelpernull_String
	InstantPassFee         whereHelperdecimal_Decimal
	InstantPassTXID        whereHelpernull_String
}{
	ID:                     whereHelperstring{field: "\"punish_votes\".\"id\""},
	PunishOptionID:         whereHelperstring{field: "\"punish_votes\".\"punish_option_id\""},
	Reason:                 whereHelperstring{field: "\"punish_votes\".\"reason\""},
	FactionID:              whereHelperstring{field: "\"punish_votes\".\"faction_id\""},
	IssuedByID:             whereHelperstring{field: "\"punish_votes\".\"issued_by_id\""},
	IssuedByUsername:       whereHelperstring{field: "\"punish_votes\".\"issued_by_username\""},
	IssuedByGid:            whereHelperint{field: "\"punish_votes\".\"issued_by_gid\""},
	ReportedPlayerID:       whereHelperstring{field: "\"punish_votes\".\"reported_player_id\""},
	ReportedPlayerUsername: whereHelperstring{field: "\"punish_votes\".\"reported_player_username\""},
	ReportedPlayerGid:      whereHelperint{field: "\"punish_votes\".\"reported_player_gid\""},
	Status:                 whereHelperstring{field: "\"punish_votes\".\"status\""},
	StartedAt:              whereHelpernull_Time{field: "\"punish_votes\".\"started_at\""},
	EndedAt:                whereHelpernull_Time{field: "\"punish_votes\".\"ended_at\""},
	CreatedAt:              whereHelpertime_Time{field: "\"punish_votes\".\"created_at\""},
	UpdatedAt:              whereHelpertime_Time{field: "\"punish_votes\".\"updated_at\""},
	DeletedAt:              whereHelpernull_Time{field: "\"punish_votes\".\"deleted_at\""},
	InstantPassByID:        whereHelpernull_String{field: "\"punish_votes\".\"instant_pass_by_id\""},
	InstantPassFee:         whereHelperdecimal_Decimal{field: "\"punish_votes\".\"instant_pass_fee\""},
	InstantPassTXID:        whereHelpernull_String{field: "\"punish_votes\".\"instant_pass_tx_id\""},
}

// PunishVoteRels is where relationship names are stored.
var PunishVoteRels = struct {
	Faction                      string
	InstantPassBy                string
	IssuedBy                     string
	PunishOption                 string
	ReportedPlayer               string
	RelatedPunishVotePlayerBans  string
	PlayersPunishVotes           string
	PunishVoteInstantPassRecords string
}{
	Faction:                      "Faction",
	InstantPassBy:                "InstantPassBy",
	IssuedBy:                     "IssuedBy",
	PunishOption:                 "PunishOption",
	ReportedPlayer:               "ReportedPlayer",
	RelatedPunishVotePlayerBans:  "RelatedPunishVotePlayerBans",
	PlayersPunishVotes:           "PlayersPunishVotes",
	PunishVoteInstantPassRecords: "PunishVoteInstantPassRecords",
}

// punishVoteR is where relationships are stored.
type punishVoteR struct {
	Faction                      *Faction                         `boiler:"Faction" boil:"Faction" json:"Faction" toml:"Faction" yaml:"Faction"`
	InstantPassBy                *Player                          `boiler:"InstantPassBy" boil:"InstantPassBy" json:"InstantPassBy" toml:"InstantPassBy" yaml:"InstantPassBy"`
	IssuedBy                     *Player                          `boiler:"IssuedBy" boil:"IssuedBy" json:"IssuedBy" toml:"IssuedBy" yaml:"IssuedBy"`
	PunishOption                 *PunishOption                    `boiler:"PunishOption" boil:"PunishOption" json:"PunishOption" toml:"PunishOption" yaml:"PunishOption"`
	ReportedPlayer               *Player                          `boiler:"ReportedPlayer" boil:"ReportedPlayer" json:"ReportedPlayer" toml:"ReportedPlayer" yaml:"ReportedPlayer"`
	RelatedPunishVotePlayerBans  PlayerBanSlice                   `boiler:"RelatedPunishVotePlayerBans" boil:"RelatedPunishVotePlayerBans" json:"RelatedPunishVotePlayerBans" toml:"RelatedPunishVotePlayerBans" yaml:"RelatedPunishVotePlayerBans"`
	PlayersPunishVotes           PlayersPunishVoteSlice           `boiler:"PlayersPunishVotes" boil:"PlayersPunishVotes" json:"PlayersPunishVotes" toml:"PlayersPunishVotes" yaml:"PlayersPunishVotes"`
	PunishVoteInstantPassRecords PunishVoteInstantPassRecordSlice `boiler:"PunishVoteInstantPassRecords" boil:"PunishVoteInstantPassRecords" json:"PunishVoteInstantPassRecords" toml:"PunishVoteInstantPassRecords" yaml:"PunishVoteInstantPassRecords"`
}

// NewStruct creates a new relationship struct
func (*punishVoteR) NewStruct() *punishVoteR {
	return &punishVoteR{}
}

// punishVoteL is where Load methods for each relationship are stored.
type punishVoteL struct{}

var (
	punishVoteAllColumns            = []string{"id", "punish_option_id", "reason", "faction_id", "issued_by_id", "issued_by_username", "issued_by_gid", "reported_player_id", "reported_player_username", "reported_player_gid", "status", "started_at", "ended_at", "created_at", "updated_at", "deleted_at", "instant_pass_by_id", "instant_pass_fee", "instant_pass_tx_id"}
	punishVoteColumnsWithoutDefault = []string{"punish_option_id", "reason", "faction_id", "issued_by_id", "issued_by_username", "issued_by_gid", "reported_player_id", "reported_player_username", "reported_player_gid", "status"}
	punishVoteColumnsWithDefault    = []string{"id", "started_at", "ended_at", "created_at", "updated_at", "deleted_at", "instant_pass_by_id", "instant_pass_fee", "instant_pass_tx_id"}
	punishVotePrimaryKeyColumns     = []string{"id"}
	punishVoteGeneratedColumns      = []string{}
)

type (
	// PunishVoteSlice is an alias for a slice of pointers to PunishVote.
	// This should almost always be used instead of []PunishVote.
	PunishVoteSlice []*PunishVote
	// PunishVoteHook is the signature for custom PunishVote hook methods
	PunishVoteHook func(boil.Executor, *PunishVote) error

	punishVoteQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	punishVoteType                 = reflect.TypeOf(&PunishVote{})
	punishVoteMapping              = queries.MakeStructMapping(punishVoteType)
	punishVotePrimaryKeyMapping, _ = queries.BindMapping(punishVoteType, punishVoteMapping, punishVotePrimaryKeyColumns)
	punishVoteInsertCacheMut       sync.RWMutex
	punishVoteInsertCache          = make(map[string]insertCache)
	punishVoteUpdateCacheMut       sync.RWMutex
	punishVoteUpdateCache          = make(map[string]updateCache)
	punishVoteUpsertCacheMut       sync.RWMutex
	punishVoteUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var punishVoteAfterSelectHooks []PunishVoteHook

var punishVoteBeforeInsertHooks []PunishVoteHook
var punishVoteAfterInsertHooks []PunishVoteHook

var punishVoteBeforeUpdateHooks []PunishVoteHook
var punishVoteAfterUpdateHooks []PunishVoteHook

var punishVoteBeforeDeleteHooks []PunishVoteHook
var punishVoteAfterDeleteHooks []PunishVoteHook

var punishVoteBeforeUpsertHooks []PunishVoteHook
var punishVoteAfterUpsertHooks []PunishVoteHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PunishVote) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *PunishVote) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *PunishVote) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *PunishVote) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *PunishVote) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *PunishVote) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *PunishVote) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *PunishVote) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *PunishVote) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range punishVoteAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPunishVoteHook registers your hook function for all future operations.
func AddPunishVoteHook(hookPoint boil.HookPoint, punishVoteHook PunishVoteHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		punishVoteAfterSelectHooks = append(punishVoteAfterSelectHooks, punishVoteHook)
	case boil.BeforeInsertHook:
		punishVoteBeforeInsertHooks = append(punishVoteBeforeInsertHooks, punishVoteHook)
	case boil.AfterInsertHook:
		punishVoteAfterInsertHooks = append(punishVoteAfterInsertHooks, punishVoteHook)
	case boil.BeforeUpdateHook:
		punishVoteBeforeUpdateHooks = append(punishVoteBeforeUpdateHooks, punishVoteHook)
	case boil.AfterUpdateHook:
		punishVoteAfterUpdateHooks = append(punishVoteAfterUpdateHooks, punishVoteHook)
	case boil.BeforeDeleteHook:
		punishVoteBeforeDeleteHooks = append(punishVoteBeforeDeleteHooks, punishVoteHook)
	case boil.AfterDeleteHook:
		punishVoteAfterDeleteHooks = append(punishVoteAfterDeleteHooks, punishVoteHook)
	case boil.BeforeUpsertHook:
		punishVoteBeforeUpsertHooks = append(punishVoteBeforeUpsertHooks, punishVoteHook)
	case boil.AfterUpsertHook:
		punishVoteAfterUpsertHooks = append(punishVoteAfterUpsertHooks, punishVoteHook)
	}
}

// One returns a single punishVote record from the query.
func (q punishVoteQuery) One(exec boil.Executor) (*PunishVote, error) {
	o := &PunishVote{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for punish_votes")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PunishVote records from the query.
func (q punishVoteQuery) All(exec boil.Executor) (PunishVoteSlice, error) {
	var o []*PunishVote

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to PunishVote slice")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PunishVote records in the query.
func (q punishVoteQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count punish_votes rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q punishVoteQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if punish_votes exists")
	}

	return count > 0, nil
}

// Faction pointed to by the foreign key.
func (o *PunishVote) Faction(mods ...qm.QueryMod) factionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.FactionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Factions(queryMods...)
	queries.SetFrom(query.Query, "\"factions\"")

	return query
}

// InstantPassBy pointed to by the foreign key.
func (o *PunishVote) InstantPassBy(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.InstantPassByID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Players(queryMods...)
	queries.SetFrom(query.Query, "\"players\"")

	return query
}

// IssuedBy pointed to by the foreign key.
func (o *PunishVote) IssuedBy(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.IssuedByID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Players(queryMods...)
	queries.SetFrom(query.Query, "\"players\"")

	return query
}

// PunishOption pointed to by the foreign key.
func (o *PunishVote) PunishOption(mods ...qm.QueryMod) punishOptionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PunishOptionID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := PunishOptions(queryMods...)
	queries.SetFrom(query.Query, "\"punish_options\"")

	return query
}

// ReportedPlayer pointed to by the foreign key.
func (o *PunishVote) ReportedPlayer(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ReportedPlayerID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Players(queryMods...)
	queries.SetFrom(query.Query, "\"players\"")

	return query
}

// RelatedPunishVotePlayerBans retrieves all the player_ban's PlayerBans with an executor via related_punish_vote_id column.
func (o *PunishVote) RelatedPunishVotePlayerBans(mods ...qm.QueryMod) playerBanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_bans\".\"related_punish_vote_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"player_bans\".\"deleted_at\""),
	)

	query := PlayerBans(queryMods...)
	queries.SetFrom(query.Query, "\"player_bans\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"player_bans\".*"})
	}

	return query
}

// PlayersPunishVotes retrieves all the players_punish_vote's PlayersPunishVotes with an executor.
func (o *PunishVote) PlayersPunishVotes(mods ...qm.QueryMod) playersPunishVoteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"players_punish_votes\".\"punish_vote_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"players_punish_votes\".\"deleted_at\""),
	)

	query := PlayersPunishVotes(queryMods...)
	queries.SetFrom(query.Query, "\"players_punish_votes\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"players_punish_votes\".*"})
	}

	return query
}

// PunishVoteInstantPassRecords retrieves all the punish_vote_instant_pass_record's PunishVoteInstantPassRecords with an executor.
func (o *PunishVote) PunishVoteInstantPassRecords(mods ...qm.QueryMod) punishVoteInstantPassRecordQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"punish_vote_instant_pass_records\".\"punish_vote_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"punish_vote_instant_pass_records\".\"deleted_at\""),
	)

	query := PunishVoteInstantPassRecords(queryMods...)
	queries.SetFrom(query.Query, "\"punish_vote_instant_pass_records\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"punish_vote_instant_pass_records\".*"})
	}

	return query
}

// LoadFaction allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (punishVoteL) LoadFaction(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		args = append(args, object.FactionID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if a == obj.FactionID {
					continue Outer
				}
			}

			args = append(args, obj.FactionID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`factions`),
		qm.WhereIn(`factions.id in ?`, args...),
		qmhelper.WhereIsNull(`factions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Faction")
	}

	var resultSlice []*Faction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Faction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factions")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Faction = foreign
		if foreign.R == nil {
			foreign.R = &factionR{}
		}
		foreign.R.PunishVotes = append(foreign.R.PunishVotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FactionID == foreign.ID {
				local.R.Faction = foreign
				if foreign.R == nil {
					foreign.R = &factionR{}
				}
				foreign.R.PunishVotes = append(foreign.R.PunishVotes, local)
				break
			}
		}
	}

	return nil
}

// LoadInstantPassBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (punishVoteL) LoadInstantPassBy(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		if !queries.IsNil(object.InstantPassByID) {
			args = append(args, object.InstantPassByID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InstantPassByID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InstantPassByID) {
				args = append(args, obj.InstantPassByID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.id in ?`, args...),
		qmhelper.WhereIsNull(`players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InstantPassBy = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.InstantPassByPunishVotes = append(foreign.R.InstantPassByPunishVotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InstantPassByID, foreign.ID) {
				local.R.InstantPassBy = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.InstantPassByPunishVotes = append(foreign.R.InstantPassByPunishVotes, local)
				break
			}
		}
	}

	return nil
}

// LoadIssuedBy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (punishVoteL) LoadIssuedBy(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		args = append(args, object.IssuedByID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if a == obj.IssuedByID {
					continue Outer
				}
			}

			args = append(args, obj.IssuedByID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.id in ?`, args...),
		qmhelper.WhereIsNull(`players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IssuedBy = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.IssuedByPunishVotes = append(foreign.R.IssuedByPunishVotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.IssuedByID == foreign.ID {
				local.R.IssuedBy = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.IssuedByPunishVotes = append(foreign.R.IssuedByPunishVotes, local)
				break
			}
		}
	}

	return nil
}

// LoadPunishOption allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (punishVoteL) LoadPunishOption(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		args = append(args, object.PunishOptionID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if a == obj.PunishOptionID {
					continue Outer
				}
			}

			args = append(args, obj.PunishOptionID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_options`),
		qm.WhereIn(`punish_options.id in ?`, args...),
		qmhelper.WhereIsNull(`punish_options.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PunishOption")
	}

	var resultSlice []*PunishOption
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PunishOption")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for punish_options")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_options")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PunishOption = foreign
		if foreign.R == nil {
			foreign.R = &punishOptionR{}
		}
		foreign.R.PunishVotes = append(foreign.R.PunishVotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PunishOptionID == foreign.ID {
				local.R.PunishOption = foreign
				if foreign.R == nil {
					foreign.R = &punishOptionR{}
				}
				foreign.R.PunishVotes = append(foreign.R.PunishVotes, local)
				break
			}
		}
	}

	return nil
}

// LoadReportedPlayer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (punishVoteL) LoadReportedPlayer(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		args = append(args, object.ReportedPlayerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if a == obj.ReportedPlayerID {
					continue Outer
				}
			}

			args = append(args, obj.ReportedPlayerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.id in ?`, args...),
		qmhelper.WhereIsNull(`players.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(punishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ReportedPlayer = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.ReportedPlayerPunishVotes = append(foreign.R.ReportedPlayerPunishVotes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ReportedPlayerID == foreign.ID {
				local.R.ReportedPlayer = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.ReportedPlayerPunishVotes = append(foreign.R.ReportedPlayerPunishVotes, local)
				break
			}
		}
	}

	return nil
}

// LoadRelatedPunishVotePlayerBans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (punishVoteL) LoadRelatedPunishVotePlayerBans(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player_bans`),
		qm.WhereIn(`player_bans.related_punish_vote_id in ?`, args...),
		qmhelper.WhereIsNull(`player_bans.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_bans")
	}

	var resultSlice []*PlayerBan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_bans")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_bans")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_bans")
	}

	if len(playerBanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RelatedPunishVotePlayerBans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerBanR{}
			}
			foreign.R.RelatedPunishVote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.RelatedPunishVoteID) {
				local.R.RelatedPunishVotePlayerBans = append(local.R.RelatedPunishVotePlayerBans, foreign)
				if foreign.R == nil {
					foreign.R = &playerBanR{}
				}
				foreign.R.RelatedPunishVote = local
				break
			}
		}
	}

	return nil
}

// LoadPlayersPunishVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (punishVoteL) LoadPlayersPunishVotes(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`players_punish_votes`),
		qm.WhereIn(`players_punish_votes.punish_vote_id in ?`, args...),
		qmhelper.WhereIsNull(`players_punish_votes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load players_punish_votes")
	}

	var resultSlice []*PlayersPunishVote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice players_punish_votes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on players_punish_votes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players_punish_votes")
	}

	if len(playersPunishVoteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayersPunishVotes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playersPunishVoteR{}
			}
			foreign.R.PunishVote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PunishVoteID {
				local.R.PlayersPunishVotes = append(local.R.PlayersPunishVotes, foreign)
				if foreign.R == nil {
					foreign.R = &playersPunishVoteR{}
				}
				foreign.R.PunishVote = local
				break
			}
		}
	}

	return nil
}

// LoadPunishVoteInstantPassRecords allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (punishVoteL) LoadPunishVoteInstantPassRecords(e boil.Executor, singular bool, maybePunishVote interface{}, mods queries.Applicator) error {
	var slice []*PunishVote
	var object *PunishVote

	if singular {
		object = maybePunishVote.(*PunishVote)
	} else {
		slice = *maybePunishVote.(*[]*PunishVote)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &punishVoteR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &punishVoteR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`punish_vote_instant_pass_records`),
		qm.WhereIn(`punish_vote_instant_pass_records.punish_vote_id in ?`, args...),
		qmhelper.WhereIsNull(`punish_vote_instant_pass_records.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load punish_vote_instant_pass_records")
	}

	var resultSlice []*PunishVoteInstantPassRecord
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice punish_vote_instant_pass_records")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on punish_vote_instant_pass_records")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for punish_vote_instant_pass_records")
	}

	if len(punishVoteInstantPassRecordAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PunishVoteInstantPassRecords = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &punishVoteInstantPassRecordR{}
			}
			foreign.R.PunishVote = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PunishVoteID {
				local.R.PunishVoteInstantPassRecords = append(local.R.PunishVoteInstantPassRecords, foreign)
				if foreign.R == nil {
					foreign.R = &punishVoteInstantPassRecordR{}
				}
				foreign.R.PunishVote = local
				break
			}
		}
	}

	return nil
}

// SetFaction of the punishVote to the related item.
// Sets o.R.Faction to related.
// Adds o to related.R.PunishVotes.
func (o *PunishVote) SetFaction(exec boil.Executor, insert bool, related *Faction) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"punish_votes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"faction_id"}),
		strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FactionID = related.ID
	if o.R == nil {
		o.R = &punishVoteR{
			Faction: related,
		}
	} else {
		o.R.Faction = related
	}

	if related.R == nil {
		related.R = &factionR{
			PunishVotes: PunishVoteSlice{o},
		}
	} else {
		related.R.PunishVotes = append(related.R.PunishVotes, o)
	}

	return nil
}

// SetInstantPassBy of the punishVote to the related item.
// Sets o.R.InstantPassBy to related.
// Adds o to related.R.InstantPassByPunishVotes.
func (o *PunishVote) SetInstantPassBy(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"punish_votes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"instant_pass_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InstantPassByID, related.ID)
	if o.R == nil {
		o.R = &punishVoteR{
			InstantPassBy: related,
		}
	} else {
		o.R.InstantPassBy = related
	}

	if related.R == nil {
		related.R = &playerR{
			InstantPassByPunishVotes: PunishVoteSlice{o},
		}
	} else {
		related.R.InstantPassByPunishVotes = append(related.R.InstantPassByPunishVotes, o)
	}

	return nil
}

// RemoveInstantPassBy relationship.
// Sets o.R.InstantPassBy to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *PunishVote) RemoveInstantPassBy(exec boil.Executor, related *Player) error {
	var err error

	queries.SetScanner(&o.InstantPassByID, nil)
	if _, err = o.Update(exec, boil.Whitelist("instant_pass_by_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InstantPassBy = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.InstantPassByPunishVotes {
		if queries.Equal(o.InstantPassByID, ri.InstantPassByID) {
			continue
		}

		ln := len(related.R.InstantPassByPunishVotes)
		if ln > 1 && i < ln-1 {
			related.R.InstantPassByPunishVotes[i] = related.R.InstantPassByPunishVotes[ln-1]
		}
		related.R.InstantPassByPunishVotes = related.R.InstantPassByPunishVotes[:ln-1]
		break
	}
	return nil
}

// SetIssuedBy of the punishVote to the related item.
// Sets o.R.IssuedBy to related.
// Adds o to related.R.IssuedByPunishVotes.
func (o *PunishVote) SetIssuedBy(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"punish_votes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"issued_by_id"}),
		strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.IssuedByID = related.ID
	if o.R == nil {
		o.R = &punishVoteR{
			IssuedBy: related,
		}
	} else {
		o.R.IssuedBy = related
	}

	if related.R == nil {
		related.R = &playerR{
			IssuedByPunishVotes: PunishVoteSlice{o},
		}
	} else {
		related.R.IssuedByPunishVotes = append(related.R.IssuedByPunishVotes, o)
	}

	return nil
}

// SetPunishOption of the punishVote to the related item.
// Sets o.R.PunishOption to related.
// Adds o to related.R.PunishVotes.
func (o *PunishVote) SetPunishOption(exec boil.Executor, insert bool, related *PunishOption) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"punish_votes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"punish_option_id"}),
		strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PunishOptionID = related.ID
	if o.R == nil {
		o.R = &punishVoteR{
			PunishOption: related,
		}
	} else {
		o.R.PunishOption = related
	}

	if related.R == nil {
		related.R = &punishOptionR{
			PunishVotes: PunishVoteSlice{o},
		}
	} else {
		related.R.PunishVotes = append(related.R.PunishVotes, o)
	}

	return nil
}

// SetReportedPlayer of the punishVote to the related item.
// Sets o.R.ReportedPlayer to related.
// Adds o to related.R.ReportedPlayerPunishVotes.
func (o *PunishVote) SetReportedPlayer(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"punish_votes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"reported_player_id"}),
		strmangle.WhereClause("\"", "\"", 2, punishVotePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ReportedPlayerID = related.ID
	if o.R == nil {
		o.R = &punishVoteR{
			ReportedPlayer: related,
		}
	} else {
		o.R.ReportedPlayer = related
	}

	if related.R == nil {
		related.R = &playerR{
			ReportedPlayerPunishVotes: PunishVoteSlice{o},
		}
	} else {
		related.R.ReportedPlayerPunishVotes = append(related.R.ReportedPlayerPunishVotes, o)
	}

	return nil
}

// AddRelatedPunishVotePlayerBans adds the given related objects to the existing relationships
// of the punish_vote, optionally inserting them as new records.
// Appends related to o.R.RelatedPunishVotePlayerBans.
// Sets related.R.RelatedPunishVote appropriately.
func (o *PunishVote) AddRelatedPunishVotePlayerBans(exec boil.Executor, insert bool, related ...*PlayerBan) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.RelatedPunishVoteID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_bans\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"related_punish_vote_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerBanPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.RelatedPunishVoteID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &punishVoteR{
			RelatedPunishVotePlayerBans: related,
		}
	} else {
		o.R.RelatedPunishVotePlayerBans = append(o.R.RelatedPunishVotePlayerBans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerBanR{
				RelatedPunishVote: o,
			}
		} else {
			rel.R.RelatedPunishVote = o
		}
	}
	return nil
}

// SetRelatedPunishVotePlayerBans removes all previously related items of the
// punish_vote replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.RelatedPunishVote's RelatedPunishVotePlayerBans accordingly.
// Replaces o.R.RelatedPunishVotePlayerBans with related.
// Sets related.R.RelatedPunishVote's RelatedPunishVotePlayerBans accordingly.
func (o *PunishVote) SetRelatedPunishVotePlayerBans(exec boil.Executor, insert bool, related ...*PlayerBan) error {
	query := "update \"player_bans\" set \"related_punish_vote_id\" = null where \"related_punish_vote_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.RelatedPunishVotePlayerBans {
			queries.SetScanner(&rel.RelatedPunishVoteID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.RelatedPunishVote = nil
		}

		o.R.RelatedPunishVotePlayerBans = nil
	}
	return o.AddRelatedPunishVotePlayerBans(exec, insert, related...)
}

// RemoveRelatedPunishVotePlayerBans relationships from objects passed in.
// Removes related items from R.RelatedPunishVotePlayerBans (uses pointer comparison, removal does not keep order)
// Sets related.R.RelatedPunishVote.
func (o *PunishVote) RemoveRelatedPunishVotePlayerBans(exec boil.Executor, related ...*PlayerBan) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.RelatedPunishVoteID, nil)
		if rel.R != nil {
			rel.R.RelatedPunishVote = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("related_punish_vote_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.RelatedPunishVotePlayerBans {
			if rel != ri {
				continue
			}

			ln := len(o.R.RelatedPunishVotePlayerBans)
			if ln > 1 && i < ln-1 {
				o.R.RelatedPunishVotePlayerBans[i] = o.R.RelatedPunishVotePlayerBans[ln-1]
			}
			o.R.RelatedPunishVotePlayerBans = o.R.RelatedPunishVotePlayerBans[:ln-1]
			break
		}
	}

	return nil
}

// AddPlayersPunishVotes adds the given related objects to the existing relationships
// of the punish_vote, optionally inserting them as new records.
// Appends related to o.R.PlayersPunishVotes.
// Sets related.R.PunishVote appropriately.
func (o *PunishVote) AddPlayersPunishVotes(exec boil.Executor, insert bool, related ...*PlayersPunishVote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PunishVoteID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"players_punish_votes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"punish_vote_id"}),
				strmangle.WhereClause("\"", "\"", 2, playersPunishVotePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PunishVoteID = o.ID
		}
	}

	if o.R == nil {
		o.R = &punishVoteR{
			PlayersPunishVotes: related,
		}
	} else {
		o.R.PlayersPunishVotes = append(o.R.PlayersPunishVotes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playersPunishVoteR{
				PunishVote: o,
			}
		} else {
			rel.R.PunishVote = o
		}
	}
	return nil
}

// AddPunishVoteInstantPassRecords adds the given related objects to the existing relationships
// of the punish_vote, optionally inserting them as new records.
// Appends related to o.R.PunishVoteInstantPassRecords.
// Sets related.R.PunishVote appropriately.
func (o *PunishVote) AddPunishVoteInstantPassRecords(exec boil.Executor, insert bool, related ...*PunishVoteInstantPassRecord) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PunishVoteID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"punish_vote_instant_pass_records\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"punish_vote_id"}),
				strmangle.WhereClause("\"", "\"", 2, punishVoteInstantPassRecordPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PunishVoteID = o.ID
		}
	}

	if o.R == nil {
		o.R = &punishVoteR{
			PunishVoteInstantPassRecords: related,
		}
	} else {
		o.R.PunishVoteInstantPassRecords = append(o.R.PunishVoteInstantPassRecords, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &punishVoteInstantPassRecordR{
				PunishVote: o,
			}
		} else {
			rel.R.PunishVote = o
		}
	}
	return nil
}

// PunishVotes retrieves all the records using an executor.
func PunishVotes(mods ...qm.QueryMod) punishVoteQuery {
	mods = append(mods, qm.From("\"punish_votes\""), qmhelper.WhereIsNull("\"punish_votes\".\"deleted_at\""))
	return punishVoteQuery{NewQuery(mods...)}
}

// FindPunishVote retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPunishVote(exec boil.Executor, iD string, selectCols ...string) (*PunishVote, error) {
	punishVoteObj := &PunishVote{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"punish_votes\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, punishVoteObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from punish_votes")
	}

	if err = punishVoteObj.doAfterSelectHooks(exec); err != nil {
		return punishVoteObj, err
	}

	return punishVoteObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PunishVote) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no punish_votes provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(punishVoteColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	punishVoteInsertCacheMut.RLock()
	cache, cached := punishVoteInsertCache[key]
	punishVoteInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			punishVoteAllColumns,
			punishVoteColumnsWithDefault,
			punishVoteColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(punishVoteType, punishVoteMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(punishVoteType, punishVoteMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"punish_votes\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"punish_votes\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into punish_votes")
	}

	if !cached {
		punishVoteInsertCacheMut.Lock()
		punishVoteInsertCache[key] = cache
		punishVoteInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the PunishVote.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PunishVote) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	punishVoteUpdateCacheMut.RLock()
	cache, cached := punishVoteUpdateCache[key]
	punishVoteUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			punishVoteAllColumns,
			punishVotePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update punish_votes, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"punish_votes\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, punishVotePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(punishVoteType, punishVoteMapping, append(wl, punishVotePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update punish_votes row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for punish_votes")
	}

	if !cached {
		punishVoteUpdateCacheMut.Lock()
		punishVoteUpdateCache[key] = cache
		punishVoteUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q punishVoteQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for punish_votes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for punish_votes")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PunishVoteSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), punishVotePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"punish_votes\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, punishVotePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in punishVote slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all punishVote")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PunishVote) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no punish_votes provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(punishVoteColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	punishVoteUpsertCacheMut.RLock()
	cache, cached := punishVoteUpsertCache[key]
	punishVoteUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			punishVoteAllColumns,
			punishVoteColumnsWithDefault,
			punishVoteColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			punishVoteAllColumns,
			punishVotePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert punish_votes, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(punishVotePrimaryKeyColumns))
			copy(conflict, punishVotePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"punish_votes\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(punishVoteType, punishVoteMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(punishVoteType, punishVoteMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert punish_votes")
	}

	if !cached {
		punishVoteUpsertCacheMut.Lock()
		punishVoteUpsertCache[key] = cache
		punishVoteUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single PunishVote record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PunishVote) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no PunishVote provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), punishVotePrimaryKeyMapping)
		sql = "DELETE FROM \"punish_votes\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"punish_votes\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(punishVoteType, punishVoteMapping, append(wl, punishVotePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from punish_votes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for punish_votes")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q punishVoteQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no punishVoteQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from punish_votes")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for punish_votes")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PunishVoteSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(punishVoteBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), punishVotePrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"punish_votes\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, punishVotePrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), punishVotePrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"punish_votes\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, punishVotePrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from punishVote slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for punish_votes")
	}

	if len(punishVoteAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PunishVote) Reload(exec boil.Executor) error {
	ret, err := FindPunishVote(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PunishVoteSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PunishVoteSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), punishVotePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"punish_votes\".* FROM \"punish_votes\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, punishVotePrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in PunishVoteSlice")
	}

	*o = slice

	return nil
}

// PunishVoteExists checks if the PunishVote row exists.
func PunishVoteExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"punish_votes\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if punish_votes exists")
	}

	return exists, nil
}
