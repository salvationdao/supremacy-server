// Code generated by SQLBoiler 4.8.6 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/shopspring/decimal"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// BlueprintPowerCore is an object representing the database table.
type BlueprintPowerCore struct {
	ID               string          `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	Collection       string          `boiler:"collection" boil:"collection" json:"collection" toml:"collection" yaml:"collection"`
	Label            string          `boiler:"label" boil:"label" json:"label" toml:"label" yaml:"label"`
	Size             string          `boiler:"size" boil:"size" json:"size" toml:"size" yaml:"size"`
	Capacity         decimal.Decimal `boiler:"capacity" boil:"capacity" json:"capacity" toml:"capacity" yaml:"capacity"`
	MaxDrawRate      decimal.Decimal `boiler:"max_draw_rate" boil:"max_draw_rate" json:"max_draw_rate" toml:"max_draw_rate" yaml:"max_draw_rate"`
	RechargeRate     decimal.Decimal `boiler:"recharge_rate" boil:"recharge_rate" json:"recharge_rate" toml:"recharge_rate" yaml:"recharge_rate"`
	Armour           decimal.Decimal `boiler:"armour" boil:"armour" json:"armour" toml:"armour" yaml:"armour"`
	MaxHitpoints     decimal.Decimal `boiler:"max_hitpoints" boil:"max_hitpoints" json:"max_hitpoints" toml:"max_hitpoints" yaml:"max_hitpoints"`
	Tier             string          `boiler:"tier" boil:"tier" json:"tier" toml:"tier" yaml:"tier"`
	CreatedAt        time.Time       `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	ImageURL         null.String     `boiler:"image_url" boil:"image_url" json:"image_url,omitempty" toml:"image_url" yaml:"image_url,omitempty"`
	CardAnimationURL null.String     `boiler:"card_animation_url" boil:"card_animation_url" json:"card_animation_url,omitempty" toml:"card_animation_url" yaml:"card_animation_url,omitempty"`
	AvatarURL        null.String     `boiler:"avatar_url" boil:"avatar_url" json:"avatar_url,omitempty" toml:"avatar_url" yaml:"avatar_url,omitempty"`
	LargeImageURL    null.String     `boiler:"large_image_url" boil:"large_image_url" json:"large_image_url,omitempty" toml:"large_image_url" yaml:"large_image_url,omitempty"`
	BackgroundColor  null.String     `boiler:"background_color" boil:"background_color" json:"background_color,omitempty" toml:"background_color" yaml:"background_color,omitempty"`
	AnimationURL     null.String     `boiler:"animation_url" boil:"animation_url" json:"animation_url,omitempty" toml:"animation_url" yaml:"animation_url,omitempty"`
	YoutubeURL       null.String     `boiler:"youtube_url" boil:"youtube_url" json:"youtube_url,omitempty" toml:"youtube_url" yaml:"youtube_url,omitempty"`
	WeaponShare      int             `boiler:"weapon_share" boil:"weapon_share" json:"weapon_share" toml:"weapon_share" yaml:"weapon_share"`
	MovementShare    int             `boiler:"movement_share" boil:"movement_share" json:"movement_share" toml:"movement_share" yaml:"movement_share"`
	UtilityShare     int             `boiler:"utility_share" boil:"utility_share" json:"utility_share" toml:"utility_share" yaml:"utility_share"`

	R *blueprintPowerCoreR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L blueprintPowerCoreL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var BlueprintPowerCoreColumns = struct {
	ID               string
	Collection       string
	Label            string
	Size             string
	Capacity         string
	MaxDrawRate      string
	RechargeRate     string
	Armour           string
	MaxHitpoints     string
	Tier             string
	CreatedAt        string
	ImageURL         string
	CardAnimationURL string
	AvatarURL        string
	LargeImageURL    string
	BackgroundColor  string
	AnimationURL     string
	YoutubeURL       string
	WeaponShare      string
	MovementShare    string
	UtilityShare     string
}{
	ID:               "id",
	Collection:       "collection",
	Label:            "label",
	Size:             "size",
	Capacity:         "capacity",
	MaxDrawRate:      "max_draw_rate",
	RechargeRate:     "recharge_rate",
	Armour:           "armour",
	MaxHitpoints:     "max_hitpoints",
	Tier:             "tier",
	CreatedAt:        "created_at",
	ImageURL:         "image_url",
	CardAnimationURL: "card_animation_url",
	AvatarURL:        "avatar_url",
	LargeImageURL:    "large_image_url",
	BackgroundColor:  "background_color",
	AnimationURL:     "animation_url",
	YoutubeURL:       "youtube_url",
	WeaponShare:      "weapon_share",
	MovementShare:    "movement_share",
	UtilityShare:     "utility_share",
}

var BlueprintPowerCoreTableColumns = struct {
	ID               string
	Collection       string
	Label            string
	Size             string
	Capacity         string
	MaxDrawRate      string
	RechargeRate     string
	Armour           string
	MaxHitpoints     string
	Tier             string
	CreatedAt        string
	ImageURL         string
	CardAnimationURL string
	AvatarURL        string
	LargeImageURL    string
	BackgroundColor  string
	AnimationURL     string
	YoutubeURL       string
	WeaponShare      string
	MovementShare    string
	UtilityShare     string
}{
	ID:               "blueprint_power_cores.id",
	Collection:       "blueprint_power_cores.collection",
	Label:            "blueprint_power_cores.label",
	Size:             "blueprint_power_cores.size",
	Capacity:         "blueprint_power_cores.capacity",
	MaxDrawRate:      "blueprint_power_cores.max_draw_rate",
	RechargeRate:     "blueprint_power_cores.recharge_rate",
	Armour:           "blueprint_power_cores.armour",
	MaxHitpoints:     "blueprint_power_cores.max_hitpoints",
	Tier:             "blueprint_power_cores.tier",
	CreatedAt:        "blueprint_power_cores.created_at",
	ImageURL:         "blueprint_power_cores.image_url",
	CardAnimationURL: "blueprint_power_cores.card_animation_url",
	AvatarURL:        "blueprint_power_cores.avatar_url",
	LargeImageURL:    "blueprint_power_cores.large_image_url",
	BackgroundColor:  "blueprint_power_cores.background_color",
	AnimationURL:     "blueprint_power_cores.animation_url",
	YoutubeURL:       "blueprint_power_cores.youtube_url",
	WeaponShare:      "blueprint_power_cores.weapon_share",
	MovementShare:    "blueprint_power_cores.movement_share",
	UtilityShare:     "blueprint_power_cores.utility_share",
}

// Generated where

var BlueprintPowerCoreWhere = struct {
	ID               whereHelperstring
	Collection       whereHelperstring
	Label            whereHelperstring
	Size             whereHelperstring
	Capacity         whereHelperdecimal_Decimal
	MaxDrawRate      whereHelperdecimal_Decimal
	RechargeRate     whereHelperdecimal_Decimal
	Armour           whereHelperdecimal_Decimal
	MaxHitpoints     whereHelperdecimal_Decimal
	Tier             whereHelperstring
	CreatedAt        whereHelpertime_Time
	ImageURL         whereHelpernull_String
	CardAnimationURL whereHelpernull_String
	AvatarURL        whereHelpernull_String
	LargeImageURL    whereHelpernull_String
	BackgroundColor  whereHelpernull_String
	AnimationURL     whereHelpernull_String
	YoutubeURL       whereHelpernull_String
	WeaponShare      whereHelperint
	MovementShare    whereHelperint
	UtilityShare     whereHelperint
}{
	ID:               whereHelperstring{field: "\"blueprint_power_cores\".\"id\""},
	Collection:       whereHelperstring{field: "\"blueprint_power_cores\".\"collection\""},
	Label:            whereHelperstring{field: "\"blueprint_power_cores\".\"label\""},
	Size:             whereHelperstring{field: "\"blueprint_power_cores\".\"size\""},
	Capacity:         whereHelperdecimal_Decimal{field: "\"blueprint_power_cores\".\"capacity\""},
	MaxDrawRate:      whereHelperdecimal_Decimal{field: "\"blueprint_power_cores\".\"max_draw_rate\""},
	RechargeRate:     whereHelperdecimal_Decimal{field: "\"blueprint_power_cores\".\"recharge_rate\""},
	Armour:           whereHelperdecimal_Decimal{field: "\"blueprint_power_cores\".\"armour\""},
	MaxHitpoints:     whereHelperdecimal_Decimal{field: "\"blueprint_power_cores\".\"max_hitpoints\""},
	Tier:             whereHelperstring{field: "\"blueprint_power_cores\".\"tier\""},
	CreatedAt:        whereHelpertime_Time{field: "\"blueprint_power_cores\".\"created_at\""},
	ImageURL:         whereHelpernull_String{field: "\"blueprint_power_cores\".\"image_url\""},
	CardAnimationURL: whereHelpernull_String{field: "\"blueprint_power_cores\".\"card_animation_url\""},
	AvatarURL:        whereHelpernull_String{field: "\"blueprint_power_cores\".\"avatar_url\""},
	LargeImageURL:    whereHelpernull_String{field: "\"blueprint_power_cores\".\"large_image_url\""},
	BackgroundColor:  whereHelpernull_String{field: "\"blueprint_power_cores\".\"background_color\""},
	AnimationURL:     whereHelpernull_String{field: "\"blueprint_power_cores\".\"animation_url\""},
	YoutubeURL:       whereHelpernull_String{field: "\"blueprint_power_cores\".\"youtube_url\""},
	WeaponShare:      whereHelperint{field: "\"blueprint_power_cores\".\"weapon_share\""},
	MovementShare:    whereHelperint{field: "\"blueprint_power_cores\".\"movement_share\""},
	UtilityShare:     whereHelperint{field: "\"blueprint_power_cores\".\"utility_share\""},
}

// BlueprintPowerCoreRels is where relationship names are stored.
var BlueprintPowerCoreRels = struct {
	PowerCoreBlueprintFiatProductItemBlueprints string
	BlueprintPowerCores                         string
}{
	PowerCoreBlueprintFiatProductItemBlueprints: "PowerCoreBlueprintFiatProductItemBlueprints",
	BlueprintPowerCores:                         "BlueprintPowerCores",
}

// blueprintPowerCoreR is where relationships are stored.
type blueprintPowerCoreR struct {
	PowerCoreBlueprintFiatProductItemBlueprints FiatProductItemBlueprintSlice `boiler:"PowerCoreBlueprintFiatProductItemBlueprints" boil:"PowerCoreBlueprintFiatProductItemBlueprints" json:"PowerCoreBlueprintFiatProductItemBlueprints" toml:"PowerCoreBlueprintFiatProductItemBlueprints" yaml:"PowerCoreBlueprintFiatProductItemBlueprints"`
	BlueprintPowerCores                         PowerCoreSlice                `boiler:"BlueprintPowerCores" boil:"BlueprintPowerCores" json:"BlueprintPowerCores" toml:"BlueprintPowerCores" yaml:"BlueprintPowerCores"`
}

// NewStruct creates a new relationship struct
func (*blueprintPowerCoreR) NewStruct() *blueprintPowerCoreR {
	return &blueprintPowerCoreR{}
}

// blueprintPowerCoreL is where Load methods for each relationship are stored.
type blueprintPowerCoreL struct{}

var (
	blueprintPowerCoreAllColumns            = []string{"id", "collection", "label", "size", "capacity", "max_draw_rate", "recharge_rate", "armour", "max_hitpoints", "tier", "created_at", "image_url", "card_animation_url", "avatar_url", "large_image_url", "background_color", "animation_url", "youtube_url", "weapon_share", "movement_share", "utility_share"}
	blueprintPowerCoreColumnsWithoutDefault = []string{"label"}
	blueprintPowerCoreColumnsWithDefault    = []string{"id", "collection", "size", "capacity", "max_draw_rate", "recharge_rate", "armour", "max_hitpoints", "tier", "created_at", "image_url", "card_animation_url", "avatar_url", "large_image_url", "background_color", "animation_url", "youtube_url", "weapon_share", "movement_share", "utility_share"}
	blueprintPowerCorePrimaryKeyColumns     = []string{"id"}
	blueprintPowerCoreGeneratedColumns      = []string{}
)

type (
	// BlueprintPowerCoreSlice is an alias for a slice of pointers to BlueprintPowerCore.
	// This should almost always be used instead of []BlueprintPowerCore.
	BlueprintPowerCoreSlice []*BlueprintPowerCore
	// BlueprintPowerCoreHook is the signature for custom BlueprintPowerCore hook methods
	BlueprintPowerCoreHook func(boil.Executor, *BlueprintPowerCore) error

	blueprintPowerCoreQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	blueprintPowerCoreType                 = reflect.TypeOf(&BlueprintPowerCore{})
	blueprintPowerCoreMapping              = queries.MakeStructMapping(blueprintPowerCoreType)
	blueprintPowerCorePrimaryKeyMapping, _ = queries.BindMapping(blueprintPowerCoreType, blueprintPowerCoreMapping, blueprintPowerCorePrimaryKeyColumns)
	blueprintPowerCoreInsertCacheMut       sync.RWMutex
	blueprintPowerCoreInsertCache          = make(map[string]insertCache)
	blueprintPowerCoreUpdateCacheMut       sync.RWMutex
	blueprintPowerCoreUpdateCache          = make(map[string]updateCache)
	blueprintPowerCoreUpsertCacheMut       sync.RWMutex
	blueprintPowerCoreUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var blueprintPowerCoreAfterSelectHooks []BlueprintPowerCoreHook

var blueprintPowerCoreBeforeInsertHooks []BlueprintPowerCoreHook
var blueprintPowerCoreAfterInsertHooks []BlueprintPowerCoreHook

var blueprintPowerCoreBeforeUpdateHooks []BlueprintPowerCoreHook
var blueprintPowerCoreAfterUpdateHooks []BlueprintPowerCoreHook

var blueprintPowerCoreBeforeDeleteHooks []BlueprintPowerCoreHook
var blueprintPowerCoreAfterDeleteHooks []BlueprintPowerCoreHook

var blueprintPowerCoreBeforeUpsertHooks []BlueprintPowerCoreHook
var blueprintPowerCoreAfterUpsertHooks []BlueprintPowerCoreHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *BlueprintPowerCore) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *BlueprintPowerCore) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *BlueprintPowerCore) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *BlueprintPowerCore) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *BlueprintPowerCore) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *BlueprintPowerCore) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *BlueprintPowerCore) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *BlueprintPowerCore) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *BlueprintPowerCore) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range blueprintPowerCoreAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddBlueprintPowerCoreHook registers your hook function for all future operations.
func AddBlueprintPowerCoreHook(hookPoint boil.HookPoint, blueprintPowerCoreHook BlueprintPowerCoreHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		blueprintPowerCoreAfterSelectHooks = append(blueprintPowerCoreAfterSelectHooks, blueprintPowerCoreHook)
	case boil.BeforeInsertHook:
		blueprintPowerCoreBeforeInsertHooks = append(blueprintPowerCoreBeforeInsertHooks, blueprintPowerCoreHook)
	case boil.AfterInsertHook:
		blueprintPowerCoreAfterInsertHooks = append(blueprintPowerCoreAfterInsertHooks, blueprintPowerCoreHook)
	case boil.BeforeUpdateHook:
		blueprintPowerCoreBeforeUpdateHooks = append(blueprintPowerCoreBeforeUpdateHooks, blueprintPowerCoreHook)
	case boil.AfterUpdateHook:
		blueprintPowerCoreAfterUpdateHooks = append(blueprintPowerCoreAfterUpdateHooks, blueprintPowerCoreHook)
	case boil.BeforeDeleteHook:
		blueprintPowerCoreBeforeDeleteHooks = append(blueprintPowerCoreBeforeDeleteHooks, blueprintPowerCoreHook)
	case boil.AfterDeleteHook:
		blueprintPowerCoreAfterDeleteHooks = append(blueprintPowerCoreAfterDeleteHooks, blueprintPowerCoreHook)
	case boil.BeforeUpsertHook:
		blueprintPowerCoreBeforeUpsertHooks = append(blueprintPowerCoreBeforeUpsertHooks, blueprintPowerCoreHook)
	case boil.AfterUpsertHook:
		blueprintPowerCoreAfterUpsertHooks = append(blueprintPowerCoreAfterUpsertHooks, blueprintPowerCoreHook)
	}
}

// One returns a single blueprintPowerCore record from the query.
func (q blueprintPowerCoreQuery) One(exec boil.Executor) (*BlueprintPowerCore, error) {
	o := &BlueprintPowerCore{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for blueprint_power_cores")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all BlueprintPowerCore records from the query.
func (q blueprintPowerCoreQuery) All(exec boil.Executor) (BlueprintPowerCoreSlice, error) {
	var o []*BlueprintPowerCore

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to BlueprintPowerCore slice")
	}

	if len(blueprintPowerCoreAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all BlueprintPowerCore records in the query.
func (q blueprintPowerCoreQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count blueprint_power_cores rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q blueprintPowerCoreQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if blueprint_power_cores exists")
	}

	return count > 0, nil
}

// PowerCoreBlueprintFiatProductItemBlueprints retrieves all the fiat_product_item_blueprint's FiatProductItemBlueprints with an executor via power_core_blueprint_id column.
func (o *BlueprintPowerCore) PowerCoreBlueprintFiatProductItemBlueprints(mods ...qm.QueryMod) fiatProductItemBlueprintQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"fiat_product_item_blueprints\".\"power_core_blueprint_id\"=?", o.ID),
	)

	query := FiatProductItemBlueprints(queryMods...)
	queries.SetFrom(query.Query, "\"fiat_product_item_blueprints\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"fiat_product_item_blueprints\".*"})
	}

	return query
}

// BlueprintPowerCores retrieves all the power_core's PowerCores with an executor via blueprint_id column.
func (o *BlueprintPowerCore) BlueprintPowerCores(mods ...qm.QueryMod) powerCoreQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"power_cores\".\"blueprint_id\"=?", o.ID),
	)

	query := PowerCores(queryMods...)
	queries.SetFrom(query.Query, "\"power_cores\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"power_cores\".*"})
	}

	return query
}

// LoadPowerCoreBlueprintFiatProductItemBlueprints allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (blueprintPowerCoreL) LoadPowerCoreBlueprintFiatProductItemBlueprints(e boil.Executor, singular bool, maybeBlueprintPowerCore interface{}, mods queries.Applicator) error {
	var slice []*BlueprintPowerCore
	var object *BlueprintPowerCore

	if singular {
		object = maybeBlueprintPowerCore.(*BlueprintPowerCore)
	} else {
		slice = *maybeBlueprintPowerCore.(*[]*BlueprintPowerCore)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &blueprintPowerCoreR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &blueprintPowerCoreR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`fiat_product_item_blueprints`),
		qm.WhereIn(`fiat_product_item_blueprints.power_core_blueprint_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load fiat_product_item_blueprints")
	}

	var resultSlice []*FiatProductItemBlueprint
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice fiat_product_item_blueprints")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on fiat_product_item_blueprints")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for fiat_product_item_blueprints")
	}

	if len(fiatProductItemBlueprintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PowerCoreBlueprintFiatProductItemBlueprints = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &fiatProductItemBlueprintR{}
			}
			foreign.R.PowerCoreBlueprint = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PowerCoreBlueprintID) {
				local.R.PowerCoreBlueprintFiatProductItemBlueprints = append(local.R.PowerCoreBlueprintFiatProductItemBlueprints, foreign)
				if foreign.R == nil {
					foreign.R = &fiatProductItemBlueprintR{}
				}
				foreign.R.PowerCoreBlueprint = local
				break
			}
		}
	}

	return nil
}

// LoadBlueprintPowerCores allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (blueprintPowerCoreL) LoadBlueprintPowerCores(e boil.Executor, singular bool, maybeBlueprintPowerCore interface{}, mods queries.Applicator) error {
	var slice []*BlueprintPowerCore
	var object *BlueprintPowerCore

	if singular {
		object = maybeBlueprintPowerCore.(*BlueprintPowerCore)
	} else {
		slice = *maybeBlueprintPowerCore.(*[]*BlueprintPowerCore)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &blueprintPowerCoreR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &blueprintPowerCoreR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`power_cores`),
		qm.WhereIn(`power_cores.blueprint_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load power_cores")
	}

	var resultSlice []*PowerCore
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice power_cores")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on power_cores")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for power_cores")
	}

	if len(powerCoreAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.BlueprintPowerCores = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &powerCoreR{}
			}
			foreign.R.Blueprint = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.BlueprintID {
				local.R.BlueprintPowerCores = append(local.R.BlueprintPowerCores, foreign)
				if foreign.R == nil {
					foreign.R = &powerCoreR{}
				}
				foreign.R.Blueprint = local
				break
			}
		}
	}

	return nil
}

// AddPowerCoreBlueprintFiatProductItemBlueprints adds the given related objects to the existing relationships
// of the blueprint_power_core, optionally inserting them as new records.
// Appends related to o.R.PowerCoreBlueprintFiatProductItemBlueprints.
// Sets related.R.PowerCoreBlueprint appropriately.
func (o *BlueprintPowerCore) AddPowerCoreBlueprintFiatProductItemBlueprints(exec boil.Executor, insert bool, related ...*FiatProductItemBlueprint) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PowerCoreBlueprintID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"fiat_product_item_blueprints\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"power_core_blueprint_id"}),
				strmangle.WhereClause("\"", "\"", 2, fiatProductItemBlueprintPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PowerCoreBlueprintID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &blueprintPowerCoreR{
			PowerCoreBlueprintFiatProductItemBlueprints: related,
		}
	} else {
		o.R.PowerCoreBlueprintFiatProductItemBlueprints = append(o.R.PowerCoreBlueprintFiatProductItemBlueprints, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &fiatProductItemBlueprintR{
				PowerCoreBlueprint: o,
			}
		} else {
			rel.R.PowerCoreBlueprint = o
		}
	}
	return nil
}

// SetPowerCoreBlueprintFiatProductItemBlueprints removes all previously related items of the
// blueprint_power_core replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.PowerCoreBlueprint's PowerCoreBlueprintFiatProductItemBlueprints accordingly.
// Replaces o.R.PowerCoreBlueprintFiatProductItemBlueprints with related.
// Sets related.R.PowerCoreBlueprint's PowerCoreBlueprintFiatProductItemBlueprints accordingly.
func (o *BlueprintPowerCore) SetPowerCoreBlueprintFiatProductItemBlueprints(exec boil.Executor, insert bool, related ...*FiatProductItemBlueprint) error {
	query := "update \"fiat_product_item_blueprints\" set \"power_core_blueprint_id\" = null where \"power_core_blueprint_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PowerCoreBlueprintFiatProductItemBlueprints {
			queries.SetScanner(&rel.PowerCoreBlueprintID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.PowerCoreBlueprint = nil
		}

		o.R.PowerCoreBlueprintFiatProductItemBlueprints = nil
	}
	return o.AddPowerCoreBlueprintFiatProductItemBlueprints(exec, insert, related...)
}

// RemovePowerCoreBlueprintFiatProductItemBlueprints relationships from objects passed in.
// Removes related items from R.PowerCoreBlueprintFiatProductItemBlueprints (uses pointer comparison, removal does not keep order)
// Sets related.R.PowerCoreBlueprint.
func (o *BlueprintPowerCore) RemovePowerCoreBlueprintFiatProductItemBlueprints(exec boil.Executor, related ...*FiatProductItemBlueprint) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PowerCoreBlueprintID, nil)
		if rel.R != nil {
			rel.R.PowerCoreBlueprint = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("power_core_blueprint_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PowerCoreBlueprintFiatProductItemBlueprints {
			if rel != ri {
				continue
			}

			ln := len(o.R.PowerCoreBlueprintFiatProductItemBlueprints)
			if ln > 1 && i < ln-1 {
				o.R.PowerCoreBlueprintFiatProductItemBlueprints[i] = o.R.PowerCoreBlueprintFiatProductItemBlueprints[ln-1]
			}
			o.R.PowerCoreBlueprintFiatProductItemBlueprints = o.R.PowerCoreBlueprintFiatProductItemBlueprints[:ln-1]
			break
		}
	}

	return nil
}

// AddBlueprintPowerCores adds the given related objects to the existing relationships
// of the blueprint_power_core, optionally inserting them as new records.
// Appends related to o.R.BlueprintPowerCores.
// Sets related.R.Blueprint appropriately.
func (o *BlueprintPowerCore) AddBlueprintPowerCores(exec boil.Executor, insert bool, related ...*PowerCore) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BlueprintID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"power_cores\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"blueprint_id"}),
				strmangle.WhereClause("\"", "\"", 2, powerCorePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BlueprintID = o.ID
		}
	}

	if o.R == nil {
		o.R = &blueprintPowerCoreR{
			BlueprintPowerCores: related,
		}
	} else {
		o.R.BlueprintPowerCores = append(o.R.BlueprintPowerCores, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &powerCoreR{
				Blueprint: o,
			}
		} else {
			rel.R.Blueprint = o
		}
	}
	return nil
}

// BlueprintPowerCores retrieves all the records using an executor.
func BlueprintPowerCores(mods ...qm.QueryMod) blueprintPowerCoreQuery {
	mods = append(mods, qm.From("\"blueprint_power_cores\""))
	return blueprintPowerCoreQuery{NewQuery(mods...)}
}

// FindBlueprintPowerCore retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindBlueprintPowerCore(exec boil.Executor, iD string, selectCols ...string) (*BlueprintPowerCore, error) {
	blueprintPowerCoreObj := &BlueprintPowerCore{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"blueprint_power_cores\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, blueprintPowerCoreObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from blueprint_power_cores")
	}

	if err = blueprintPowerCoreObj.doAfterSelectHooks(exec); err != nil {
		return blueprintPowerCoreObj, err
	}

	return blueprintPowerCoreObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *BlueprintPowerCore) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no blueprint_power_cores provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(blueprintPowerCoreColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	blueprintPowerCoreInsertCacheMut.RLock()
	cache, cached := blueprintPowerCoreInsertCache[key]
	blueprintPowerCoreInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			blueprintPowerCoreAllColumns,
			blueprintPowerCoreColumnsWithDefault,
			blueprintPowerCoreColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(blueprintPowerCoreType, blueprintPowerCoreMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(blueprintPowerCoreType, blueprintPowerCoreMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"blueprint_power_cores\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"blueprint_power_cores\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into blueprint_power_cores")
	}

	if !cached {
		blueprintPowerCoreInsertCacheMut.Lock()
		blueprintPowerCoreInsertCache[key] = cache
		blueprintPowerCoreInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the BlueprintPowerCore.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *BlueprintPowerCore) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	blueprintPowerCoreUpdateCacheMut.RLock()
	cache, cached := blueprintPowerCoreUpdateCache[key]
	blueprintPowerCoreUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			blueprintPowerCoreAllColumns,
			blueprintPowerCorePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update blueprint_power_cores, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"blueprint_power_cores\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, blueprintPowerCorePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(blueprintPowerCoreType, blueprintPowerCoreMapping, append(wl, blueprintPowerCorePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update blueprint_power_cores row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for blueprint_power_cores")
	}

	if !cached {
		blueprintPowerCoreUpdateCacheMut.Lock()
		blueprintPowerCoreUpdateCache[key] = cache
		blueprintPowerCoreUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q blueprintPowerCoreQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for blueprint_power_cores")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for blueprint_power_cores")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o BlueprintPowerCoreSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), blueprintPowerCorePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"blueprint_power_cores\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, blueprintPowerCorePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in blueprintPowerCore slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all blueprintPowerCore")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *BlueprintPowerCore) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no blueprint_power_cores provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(blueprintPowerCoreColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	blueprintPowerCoreUpsertCacheMut.RLock()
	cache, cached := blueprintPowerCoreUpsertCache[key]
	blueprintPowerCoreUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			blueprintPowerCoreAllColumns,
			blueprintPowerCoreColumnsWithDefault,
			blueprintPowerCoreColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			blueprintPowerCoreAllColumns,
			blueprintPowerCorePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert blueprint_power_cores, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(blueprintPowerCorePrimaryKeyColumns))
			copy(conflict, blueprintPowerCorePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"blueprint_power_cores\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(blueprintPowerCoreType, blueprintPowerCoreMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(blueprintPowerCoreType, blueprintPowerCoreMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert blueprint_power_cores")
	}

	if !cached {
		blueprintPowerCoreUpsertCacheMut.Lock()
		blueprintPowerCoreUpsertCache[key] = cache
		blueprintPowerCoreUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single BlueprintPowerCore record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *BlueprintPowerCore) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no BlueprintPowerCore provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), blueprintPowerCorePrimaryKeyMapping)
	sql := "DELETE FROM \"blueprint_power_cores\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from blueprint_power_cores")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for blueprint_power_cores")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q blueprintPowerCoreQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no blueprintPowerCoreQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from blueprint_power_cores")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for blueprint_power_cores")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o BlueprintPowerCoreSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(blueprintPowerCoreBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), blueprintPowerCorePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"blueprint_power_cores\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, blueprintPowerCorePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from blueprintPowerCore slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for blueprint_power_cores")
	}

	if len(blueprintPowerCoreAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *BlueprintPowerCore) Reload(exec boil.Executor) error {
	ret, err := FindBlueprintPowerCore(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *BlueprintPowerCoreSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := BlueprintPowerCoreSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), blueprintPowerCorePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"blueprint_power_cores\".* FROM \"blueprint_power_cores\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, blueprintPowerCorePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in BlueprintPowerCoreSlice")
	}

	*o = slice

	return nil
}

// BlueprintPowerCoreExists checks if the BlueprintPowerCore row exists.
func BlueprintPowerCoreExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"blueprint_power_cores\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if blueprint_power_cores exists")
	}

	return exists, nil
}
